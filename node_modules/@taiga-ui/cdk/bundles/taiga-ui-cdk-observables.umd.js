(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@taiga-ui/cdk/utils/miscellaneous'), require('rxjs'), require('rxjs/operators'), require('@taiga-ui/cdk/utils/focus')) :
    typeof define === 'function' && define.amd ? define('@taiga-ui/cdk/observables', ['exports', '@taiga-ui/cdk/utils/miscellaneous', 'rxjs', 'rxjs/operators', '@taiga-ui/cdk/utils/focus'], factory) :
    (global = global || self, factory((global['taiga-ui'] = global['taiga-ui'] || {}, global['taiga-ui'].cdk = global['taiga-ui'].cdk || {}, global['taiga-ui'].cdk.observables = {}), global['taiga-ui'].cdk.utils.miscellaneous, global.rxjs, global.rxjs.operators, global['taiga-ui'].cdk.utils.focus));
}(this, (function (exports, miscellaneous, rxjs, operators, focus) { 'use strict';

    function typedFromEvent(target, event, options) {
        if (options === void 0) { options = {}; }
        return rxjs.fromEvent(target, event, options);
    }

    /**
     * Letting go of the mouse after it was pressed
     * @param target
     */
    function mouseDragFinishFrom(target) {
        return rxjs.merge(typedFromEvent(target, 'mouseup'), typedFromEvent(target, 'dragend'));
    }

    var TuiDragState = /** @class */ (function () {
        function TuiDragState(stage, event) {
            this.stage = stage;
            this.event = event;
        }
        return TuiDragState;
    }());
    function dragAndDropFrom(element) {
        var ownerDocument = element.ownerDocument;
        if (!ownerDocument) {
            throw new Error('element does not have ownerDocument');
        }
        return rxjs.concat(typedFromEvent(element, 'mousedown').pipe(operators.first(), operators.map(function (event) { return new TuiDragState(0 /* Start */, event); })), rxjs.merge(typedFromEvent(ownerDocument, 'mousemove').pipe(operators.map(function (event) { return new TuiDragState(1 /* Continues */, event); })), mouseDragFinishFrom(ownerDocument).pipe(operators.first(), operators.map(function (event) { return new TuiDragState(2 /* End */, event); }), operators.endWith(null))).pipe(operators.takeWhile(miscellaneous.isPresent))).pipe(operators.repeat());
    }

    /**
     * Operator to set lifespan after which current value is considered obsolete
     */
    function tuiIsAlive(lifespan) {
        if (lifespan === void 0) { lifespan = 0; }
        return rxjs.pipe(operators.switchMapTo(rxjs.timer(lifespan).pipe(operators.mapTo(false), operators.startWith(true))), operators.distinctUntilChanged());
    }

    var documentMouseUpIsAlive$;
    var documentMouseDownIsAlive$;
    function focusVisibleObservable(element) {
        var elementBlur$ = typedFromEvent(element, 'blur');
        var ownerDocument = element.ownerDocument;
        if (!ownerDocument) {
            throw new Error('element does not have ownerDocument');
        }
        if (!documentMouseDownIsAlive$ || !documentMouseUpIsAlive$) {
            documentMouseUpIsAlive$ = typedFromEvent(ownerDocument, 'mouseup', {
                capture: true,
            }).pipe(tuiIsAlive(), operators.startWith(false), operators.shareReplay(1));
            documentMouseDownIsAlive$ = typedFromEvent(ownerDocument, 'mousedown', {
                capture: true,
            }).pipe(tuiIsAlive(), operators.startWith(false), operators.shareReplay(1));
        }
        return rxjs.merge(
        // focus events excluding ones that came right after mouse action
        rxjs.concat(typedFromEvent(element, 'focus').pipe(operators.take(1)), 
        // filtering out blur events when element remains focused so that we ignore browser tab focus loss
        elementBlur$.pipe(operators.filter(function () { return !focus.isNativeFocused(element); }), operators.take(1), operators.ignoreElements())).pipe(operators.repeat(), operators.withLatestFrom(documentMouseDownIsAlive$, documentMouseUpIsAlive$, function (_event, elementActual, documentActual) {
            return elementActual || documentActual;
        }), operators.filter(function (isUserFocus) { return !isUserFocus; }))).pipe(operators.switchMapTo(elementBlur$.pipe(operators.mapTo(false), operators.take(1), operators.startWith(true))), operators.distinctUntilChanged());
    }

    /**
     * Converts changes observable of a QueryList to an Observable of arrays
     */
    function itemsQueryListObservable(queryList) {
        return queryList.changes.pipe(operators.map(function () { return miscellaneous.getOriginalArrayFromQueryList(queryList); }), operators.startWith(miscellaneous.getOriginalArrayFromQueryList(queryList)));
    }

    function mustBePresent() {
        return operators.map(function (value) {
            if (!miscellaneous.isPresent(value)) {
                throw new Error('Value must present');
            }
            return value;
        });
    }

    function pressedObservable(element) {
        var ownerDocument = element.ownerDocument;
        if (!ownerDocument) {
            throw new Error('element does not have ownerDocument');
        }
        return typedFromEvent(element, 'mousedown').pipe(operators.filter(function (_a) {
            var isTrusted = _a.isTrusted;
            return isTrusted;
        }), operators.switchMapTo(mouseDragFinishFrom(ownerDocument).pipe(operators.mapTo(false), operators.take(1), operators.startWith(true))));
    }

    function preventDefault() {
        return operators.tap(function (e) {
            e.preventDefault();
        });
    }

    /**
     * Turns AbstractControl/Abstract-control-directive valueChanges into ReplaySubject(1)
     */
    function tuiReplayedValueChangesFrom(control) {
        return new rxjs.Observable(function (subscriber) {
            if (!control.valueChanges) {
                throw new Error('Control does not have valueChanges');
            }
            control.valueChanges.pipe(operators.startWith(control.value)).subscribe(subscriber);
        });
    }

    function watch(changeDetectorRef) {
        return operators.tap(function () {
            changeDetectorRef.markForCheck();
        });
    }

    var TuiZonefreeOperator = /** @class */ (function () {
        function TuiZonefreeOperator(ngZone) {
            this.ngZone = ngZone;
        }
        TuiZonefreeOperator.prototype.call = function (observer, source) {
            return this.ngZone.runOutsideAngular(function () { return source.subscribe(observer); });
        };
        return TuiZonefreeOperator;
    }());
    function tuiZonefull(ngZone) {
        return function (source) {
            return new rxjs.Observable(function (subscriber) {
                return source.subscribe({
                    next: function (value) { return ngZone.run(function () { return subscriber.next(value); }); },
                    error: function (error) { return ngZone.run(function () { return subscriber.error(error); }); },
                    complete: function () { return ngZone.run(function () { return subscriber.complete(); }); },
                });
            });
        };
    }
    function tuiZonefree(ngZone) {
        return function (source) { return source.lift(new TuiZonefreeOperator(ngZone)); };
    }
    function tuiZoneOptimized(ngZone) {
        return rxjs.pipe(tuiZonefree(ngZone), tuiZonefull(ngZone));
    }

    exports.TuiDragState = TuiDragState;
    exports.dragAndDropFrom = dragAndDropFrom;
    exports.focusVisibleObservable = focusVisibleObservable;
    exports.itemsQueryListObservable = itemsQueryListObservable;
    exports.mouseDragFinishFrom = mouseDragFinishFrom;
    exports.mustBePresent = mustBePresent;
    exports.pressedObservable = pressedObservable;
    exports.preventDefault = preventDefault;
    exports.tuiIsAlive = tuiIsAlive;
    exports.tuiReplayedValueChangesFrom = tuiReplayedValueChangesFrom;
    exports.tuiZoneOptimized = tuiZoneOptimized;
    exports.tuiZonefree = tuiZonefree;
    exports.tuiZonefull = tuiZonefull;
    exports.typedFromEvent = typedFromEvent;
    exports.watch = watch;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=taiga-ui-cdk-observables.umd.js.map
