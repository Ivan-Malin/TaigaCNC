{"version":3,"sources":["ng://@taiga-ui/cdk/observables/typed-from-event.ts","ng://@taiga-ui/cdk/observables/mouse-drag-finish-from.ts","ng://@taiga-ui/cdk/observables/focus-visible-observable.ts","ng://@taiga-ui/cdk/observables/drag-and-drop-from.ts","ng://@taiga-ui/cdk/observables/is-alive.ts","ng://@taiga-ui/cdk/observables/zone-free.ts","ng://@taiga-ui/cdk/observables/items-query-list-observable.ts","ng://@taiga-ui/cdk/observables/must-be-present.ts","ng://@taiga-ui/cdk/observables/pressed-observable.ts","ng://@taiga-ui/cdk/observables/prevent-default.ts","ng://@taiga-ui/cdk/observables/replay-control-value-changes.ts","ng://@taiga-ui/cdk/observables/watch.ts"],"names":["typedFromEvent","target","event","options","fromEvent","mouseDragFinishFrom","merge","documentMouseUpIsAlive$","documentMouseDownIsAlive$","stage","this","tuiIsAlive","lifespan","pipe","switchMapTo","timer","mapTo","startWith","distinctUntilChanged","TuiZonefreeOperator","ngZone","prototype","call","observer","source","runOutsideAngular","subscribe","tuiZonefull","Observable","subscriber","next","value","run","error","complete","tuiZonefree","lift","element","ownerDocument","Error","concat","first","map","TuiDragState","endWith","takeWhile","isPresent","repeat","elementBlur$","capture","shareReplay","take","filter","isNativeFocused","ignoreElements","withLatestFrom","_event","elementActual","documentActual","isUserFocus","queryList","changes","getOriginalArrayFromQueryList","_a","isTrusted","tap","e","preventDefault","control","valueChanges","changeDetectorRef","markForCheck"],"mappings":"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","sourcesContent":["import {TuiEventWith, TuiTypedEventTarget} from '@taiga-ui/cdk/types';\nimport {fromEvent, Observable} from 'rxjs';\n\nexport function typedFromEvent<E extends keyof WindowEventMap>(\n    target: Window,\n    event: E,\n    options?: AddEventListenerOptions,\n): Observable<TuiEventWith<WindowEventMap[E], typeof target>>;\nexport function typedFromEvent<E extends keyof DocumentEventMap>(\n    target: Document,\n    event: E,\n    options?: AddEventListenerOptions,\n): Observable<TuiEventWith<DocumentEventMap[E], typeof target>>;\nexport function typedFromEvent<T extends Element, E extends keyof HTMLElementEventMap>(\n    target: T,\n    event: E,\n    options?: AddEventListenerOptions,\n): Observable<TuiEventWith<HTMLElementEventMap[E], typeof target>>;\nexport function typedFromEvent<\n    E extends Event,\n    T extends TuiTypedEventTarget<TuiEventWith<E, T>>\n>(\n    target: T,\n    event: string,\n    options?: AddEventListenerOptions,\n): Observable<TuiEventWith<E, T>>;\nexport function typedFromEvent<E extends Event>(\n    target: TuiTypedEventTarget<E>,\n    event: string,\n    options?: AddEventListenerOptions,\n): Observable<E>;\nexport function typedFromEvent<E extends Event>(\n    target: TuiTypedEventTarget<E>,\n    event: string,\n    options: AddEventListenerOptions = {},\n): Observable<E> {\n    return fromEvent(target, event, options);\n}\n","import {TuiEventWith, TuiTypedEventTarget} from '@taiga-ui/cdk/types';\nimport {merge, Observable} from 'rxjs';\nimport {typedFromEvent} from './typed-from-event';\n\n/**\n * Letting go of the mouse after it was pressed\n * @param target\n */\nexport function mouseDragFinishFrom<\n    T extends TuiTypedEventTarget<TuiEventWith<DragEvent, T>>\n>(target: Exclude<T, null>): Observable<TuiEventWith<MouseEvent, T>> {\n    return merge(typedFromEvent(target, 'mouseup'), typedFromEvent(target, 'dragend'));\n}\n","import {isNativeFocused} from '@taiga-ui/cdk/utils/focus';\nimport {concat, merge, Observable} from 'rxjs';\nimport {\n    distinctUntilChanged,\n    filter,\n    ignoreElements,\n    mapTo,\n    repeat,\n    shareReplay,\n    startWith,\n    switchMapTo,\n    take,\n    withLatestFrom,\n} from 'rxjs/operators';\nimport {tuiIsAlive} from './is-alive';\nimport {typedFromEvent} from './typed-from-event';\n\nlet documentMouseUpIsAlive$: Observable<boolean>;\nlet documentMouseDownIsAlive$: Observable<boolean>;\n\nexport function focusVisibleObservable(element: Element): Observable<boolean> {\n    const elementBlur$ = typedFromEvent(element, 'blur');\n    const {ownerDocument} = element;\n\n    if (!ownerDocument) {\n        throw new Error('element does not have ownerDocument');\n    }\n\n    if (!documentMouseDownIsAlive$ || !documentMouseUpIsAlive$) {\n        documentMouseUpIsAlive$ = typedFromEvent(ownerDocument, 'mouseup', {\n            capture: true,\n        }).pipe(tuiIsAlive(), startWith(false), shareReplay(1));\n        documentMouseDownIsAlive$ = typedFromEvent(ownerDocument, 'mousedown', {\n            capture: true,\n        }).pipe(tuiIsAlive(), startWith(false), shareReplay(1));\n    }\n\n    return merge(\n        // focus events excluding ones that came right after mouse action\n        concat(\n            typedFromEvent(element, 'focus').pipe(take(1)),\n            // filtering out blur events when element remains focused so that we ignore browser tab focus loss\n            elementBlur$.pipe(\n                filter(() => !isNativeFocused(element)),\n                take(1),\n                ignoreElements(),\n            ),\n        ).pipe(\n            repeat(),\n            withLatestFrom(\n                documentMouseDownIsAlive$,\n                documentMouseUpIsAlive$,\n                (_event, elementActual, documentActual) =>\n                    elementActual || documentActual,\n            ),\n            filter(isUserFocus => !isUserFocus),\n        ),\n    ).pipe(\n        switchMapTo(elementBlur$.pipe(mapTo(false), take(1), startWith(true))),\n        distinctUntilChanged(),\n    );\n}\n","import {isPresent} from '@taiga-ui/cdk/utils/miscellaneous';\nimport {concat, merge, Observable} from 'rxjs';\nimport {endWith, first, map, repeat, takeWhile} from 'rxjs/operators';\nimport {mouseDragFinishFrom} from './mouse-drag-finish-from';\nimport {typedFromEvent} from './typed-from-event';\n\nexport const enum TuiDragStage {\n    Start,\n    Continues,\n    End,\n}\n\nexport class TuiDragState {\n    constructor(readonly stage: TuiDragStage, readonly event: MouseEvent) {}\n}\n\nexport function dragAndDropFrom(element: Element): Observable<TuiDragState> {\n    const {ownerDocument} = element;\n\n    if (!ownerDocument) {\n        throw new Error('element does not have ownerDocument');\n    }\n\n    return concat(\n        typedFromEvent(element, 'mousedown').pipe(\n            first(),\n            map(event => new TuiDragState(TuiDragStage.Start, event)),\n        ),\n        merge(\n            typedFromEvent(ownerDocument, 'mousemove').pipe(\n                map(event => new TuiDragState(TuiDragStage.Continues, event)),\n            ),\n            mouseDragFinishFrom(ownerDocument).pipe(\n                first(),\n                map(event => new TuiDragState(TuiDragStage.End, event)),\n                endWith<TuiDragState | null>(null),\n            ),\n        ).pipe(takeWhile(isPresent)),\n    ).pipe(repeat());\n}\n","import {OperatorFunction, pipe, timer} from 'rxjs';\nimport {distinctUntilChanged, mapTo, startWith, switchMapTo} from 'rxjs/operators';\n\n/**\n * Operator to set lifespan after which current value is considered obsolete\n */\nexport function tuiIsAlive(lifespan: number = 0): OperatorFunction<any, boolean> {\n    return pipe(\n        switchMapTo(timer(lifespan).pipe(mapTo(false), startWith(true))),\n        distinctUntilChanged(),\n    );\n}\n","import {NgZone} from '@angular/core';\nimport {\n    MonoTypeOperatorFunction,\n    Observable,\n    Observer,\n    Operator,\n    pipe,\n    TeardownLogic,\n} from 'rxjs';\n\nclass TuiZonefreeOperator<T> implements Operator<T, T> {\n    constructor(private readonly ngZone: NgZone) {}\n\n    call(observer: Observer<T>, source: Observable<T>): TeardownLogic {\n        return this.ngZone.runOutsideAngular(() => source.subscribe(observer));\n    }\n}\n\nexport function tuiZonefull<T>(ngZone: NgZone): MonoTypeOperatorFunction<T> {\n    return source =>\n        new Observable(subscriber =>\n            source.subscribe({\n                next: value => ngZone.run(() => subscriber.next(value)),\n                error: error => ngZone.run(() => subscriber.error(error)),\n                complete: () => ngZone.run(() => subscriber.complete()),\n            }),\n        );\n}\n\nexport function tuiZonefree<T>(ngZone: NgZone): MonoTypeOperatorFunction<T> {\n    return source => source.lift(new TuiZonefreeOperator<T>(ngZone));\n}\n\nexport function tuiZoneOptimized<T>(ngZone: NgZone): MonoTypeOperatorFunction<T> {\n    return pipe(tuiZonefree(ngZone), tuiZonefull(ngZone));\n}\n","import {QueryList} from '@angular/core';\nimport {getOriginalArrayFromQueryList} from '@taiga-ui/cdk/utils/miscellaneous';\nimport {Observable} from 'rxjs';\nimport {map, startWith} from 'rxjs/operators';\n\n/**\n * Converts changes observable of a QueryList to an Observable of arrays\n */\nexport function itemsQueryListObservable<T>(\n    queryList: QueryList<T>,\n): Observable<ReadonlyArray<T>> {\n    return queryList.changes.pipe(\n        map(() => getOriginalArrayFromQueryList(queryList)),\n        startWith(getOriginalArrayFromQueryList(queryList)),\n    );\n}\n","import {isPresent} from '@taiga-ui/cdk/utils/miscellaneous';\nimport {OperatorFunction} from 'rxjs';\nimport {map} from 'rxjs/operators';\n\nexport function mustBePresent<T>(): OperatorFunction<T | undefined | null, T> {\n    return map(value => {\n        if (!isPresent(value)) {\n            throw new Error('Value must present');\n        }\n\n        return value;\n    });\n}\n","import {Observable} from 'rxjs';\nimport {filter, mapTo, startWith, switchMapTo, take} from 'rxjs/operators';\nimport {mouseDragFinishFrom} from './mouse-drag-finish-from';\nimport {typedFromEvent} from './typed-from-event';\n\nexport function pressedObservable(element: Element): Observable<boolean> {\n    const {ownerDocument} = element;\n\n    if (!ownerDocument) {\n        throw new Error('element does not have ownerDocument');\n    }\n\n    return typedFromEvent(element, 'mousedown').pipe(\n        filter(({isTrusted}) => isTrusted),\n        switchMapTo(\n            mouseDragFinishFrom(ownerDocument).pipe(\n                mapTo(false),\n                take(1),\n                startWith(true),\n            ),\n        ),\n    );\n}\n","import {MonoTypeOperatorFunction} from 'rxjs';\nimport {tap} from 'rxjs/operators';\n\nexport function preventDefault<T extends Event>(): MonoTypeOperatorFunction<T> {\n    return tap(e => {\n        e.preventDefault();\n    });\n}\n","import {AbstractControl, AbstractControlDirective} from '@angular/forms';\nimport {Observable} from 'rxjs';\nimport {startWith} from 'rxjs/operators';\n\n/**\n * Turns AbstractControl/Abstract-control-directive valueChanges into ReplaySubject(1)\n */\nexport function tuiReplayedValueChangesFrom<T>(\n    control: AbstractControl | AbstractControlDirective,\n): Observable<T> {\n    return new Observable(subscriber => {\n        if (!control.valueChanges) {\n            throw new Error('Control does not have valueChanges');\n        }\n\n        control.valueChanges.pipe(startWith(control.value)).subscribe(subscriber);\n    });\n}\n","import {ChangeDetectorRef} from '@angular/core';\nimport {MonoTypeOperatorFunction} from 'rxjs';\nimport {tap} from 'rxjs/operators';\n\nexport function watch<T>(\n    changeDetectorRef: ChangeDetectorRef,\n): MonoTypeOperatorFunction<T> {\n    return tap(() => {\n        changeDetectorRef.markForCheck();\n    });\n}\n"]}