{"version":3,"sources":["ng://@taiga-ui/cdk/utils/dom/get-closest-element.ts","ng://@taiga-ui/cdk/utils/dom/get-document-or-shadow-root.ts","ng://@taiga-ui/cdk/utils/dom/can-scroll.ts","ng://@taiga-ui/cdk/utils/dom/contains-or-after.ts","ng://@taiga-ui/cdk/utils/dom/get-actual-target.ts","ng://@taiga-ui/cdk/utils/dom/get-clipboard-data-text.ts","ng://@taiga-ui/cdk/utils/dom/get-element-obscurers.ts","ng://@taiga-ui/cdk/utils/dom/get-element-offset.ts","ng://@taiga-ui/cdk/utils/dom/get-scroll-parent.ts","ng://@taiga-ui/cdk/utils/dom/is-current-target.ts","ng://@taiga-ui/cdk/utils/dom/is-node-in.ts","ng://@taiga-ui/cdk/utils/dom/custom-event.ts"],"names":["getClosestElement","element","selector","closest","Element","prototype","call","matchesSelector","matches","msMatchesSelector","parentElement","getDocumentOrShadowRoot","node","ownerDocument","body","contains","getRootNode","rootElement","vertical","scrollEnd","currentElement","Math","floor","scrollTop","ceil","clientHeight","scrollHeight","canScrollVertical","scrollLeft","clientWidth","scrollWidth","canScrollHorizontal","current","compareDocumentPosition","Node","DOCUMENT_POSITION_PRECEDING","event","composedPath","target","format","clipboardData","getData","defaultView","_a","innerWidth","innerHeight","documentRef","rect","getBoundingClientRect","left","clamp","round","top","right","bottom","horizontalMiddle","width","verticalMiddle","height","nonNull","elementFromPoint","filter","isPresent","length","filtered","el","host","tuiAssert","assert","offsetTop","offsetLeft","offsetParent","HTMLElement","getScrollParent","currentTarget","nodeType","TEXT_NODE","ELEMENT_NODE","name","_b","_c","bubbles","_d","cancelable","_e","detail","CustomEvent","customEvent","createEvent","initCustomEvent"],"mappings":"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","sourcesContent":["/**\n * Gets closest element by selector i.e. {@link Element.closest}\n */\nexport function getClosestElement(element: Element, selector: string): Element | null {\n    const closest = Element.prototype.closest;\n\n    if (closest) {\n        return closest.call(element, selector);\n    }\n\n    const matchesSelector =\n        Element.prototype.matches || (Element.prototype as any).msMatchesSelector;\n\n    do {\n        if (matchesSelector.call(element, selector)) {\n            return element;\n        }\n\n        (element as Element | null) = element.parentElement;\n    } while (element !== null);\n\n    return null;\n}\n","export function getDocumentOrShadowRoot(node: Node): DocumentOrShadowRoot {\n    return 'getRootNode' in node &&\n        node.ownerDocument &&\n        node.ownerDocument.body.contains(node)\n        ? (node.getRootNode() as Document)\n        : node.ownerDocument!;\n}\n","export function canScroll(\n    element: Element,\n    rootElement: Element,\n    vertical: boolean,\n    scrollEnd: boolean,\n): boolean {\n    return vertical\n        ? canScrollVertical(element, rootElement, scrollEnd)\n        : canScrollHorizontal(element, rootElement, scrollEnd);\n}\n\nfunction canScrollVertical(\n    element: Element,\n    rootElement: Element,\n    scrollEnd: boolean,\n): boolean {\n    let currentElement = element;\n\n    while (currentElement !== rootElement.parentElement) {\n        if (\n            (Math.floor(currentElement.scrollTop) > 0 && !scrollEnd) ||\n            (Math.ceil(currentElement.scrollTop + currentElement.clientHeight) <\n                currentElement.scrollHeight &&\n                scrollEnd)\n        ) {\n            return true;\n        }\n\n        if (currentElement.parentElement) {\n            currentElement = currentElement.parentElement;\n        } else {\n            return false;\n        }\n    }\n\n    return false;\n}\n\nfunction canScrollHorizontal(\n    element: Element,\n    rootElement: Element,\n    scrollEnd: boolean,\n): boolean {\n    let currentElement = element;\n\n    while (currentElement !== rootElement.parentElement) {\n        if (\n            (Math.floor(currentElement.scrollLeft) > 0 && !scrollEnd) ||\n            (Math.ceil(currentElement.scrollLeft + currentElement.clientWidth) <\n                currentElement.scrollWidth &&\n                scrollEnd)\n        ) {\n            return true;\n        }\n\n        if (currentElement.parentElement) {\n            currentElement = currentElement.parentElement;\n        } else {\n            return false;\n        }\n    }\n\n    return false;\n}\n","export function containsOrAfter(current: Node, node: Node): boolean {\n    return (\n        current.contains(node) ||\n        !!(\n            // tslint:disable:no-bitwise\n            (node.compareDocumentPosition(current) & Node.DOCUMENT_POSITION_PRECEDING)\n        )\n    );\n}\n","/**\n * Gets actual target from open Shadow DOM if event happened within it\n */\nexport function getActualTarget(event: Event): Node {\n    if ('composedPath' in event) {\n        return (event as any).composedPath()[0];\n    }\n\n    return (event as any).target;\n}\n","/**\n * Gets text from data of clipboardEvent, it also works in IE and Edge browsers\n */\nexport function getClipboardDataText(\n    event: ClipboardEvent,\n    format: string = 'text/plain',\n): string {\n    return 'clipboardData' in event && event.clipboardData !== null\n        ? event.clipboardData.getData(format)\n        : (event as any).target.ownerDocument.defaultView.clipboardData.getData('text');\n}\n","import {clamp} from '@taiga-ui/cdk/utils/math';\nimport {isPresent} from '@taiga-ui/cdk/utils/miscellaneous';\nimport {getDocumentOrShadowRoot} from './get-document-or-shadow-root';\n\n/**\n * Returns array of Elements covering edges of given element or null if at least one edge middle point is visible\n *\n * CAUTION: Empty array means element if offscreen i.e. covered by no elements, rather than not covered\n */\nexport function getElementObscurers(element: Element): ReadonlyArray<Element> | null {\n    const {ownerDocument} = element;\n\n    if (!ownerDocument || !ownerDocument.defaultView) {\n        return null;\n    }\n\n    const {innerWidth, innerHeight} = ownerDocument.defaultView;\n    const documentRef = getDocumentOrShadowRoot(element);\n    const rect = element.getBoundingClientRect();\n    const left = clamp(Math.round(rect.left) + 2, 0, innerWidth);\n    const top = clamp(Math.round(rect.top) + 2, 0, innerHeight);\n    const right = clamp(Math.round(rect.right) - 2, 0, innerWidth);\n    const bottom = clamp(Math.round(rect.bottom) - 2, 0, innerHeight);\n    const horizontalMiddle = clamp(Math.round(rect.left + rect.width / 2), 0, innerWidth);\n    const verticalMiddle = clamp(Math.round(rect.top + rect.height / 2), 0, innerHeight);\n    const elements = [\n        documentRef.elementFromPoint(horizontalMiddle, top),\n        documentRef.elementFromPoint(horizontalMiddle, bottom),\n        documentRef.elementFromPoint(left, verticalMiddle),\n        documentRef.elementFromPoint(right, verticalMiddle),\n    ];\n    const nonNull = elements.filter(isPresent);\n\n    if (!nonNull.length) {\n        return nonNull;\n    }\n\n    const filtered = nonNull.filter(el => !element.contains(el));\n\n    return filtered.length === 4 ? filtered : null;\n}\n","import {tuiAssert} from '@taiga-ui/cdk/classes';\n\n/**\n * Calculates offset for an element relative to it's parent several levels above\n *\n * @param host parent element\n * @param element\n * @return object with offsetTop and offsetLeft number properties\n */\nexport function getElementOffset(\n    host: Element,\n    element: HTMLElement,\n): {offsetTop: number; offsetLeft: number} {\n    tuiAssert.assert(host.contains(element), 'Host must contain element');\n\n    let {offsetTop, offsetLeft, offsetParent} = element;\n\n    while (offsetParent && offsetParent instanceof HTMLElement && offsetParent !== host) {\n        offsetTop += offsetParent.offsetTop;\n        offsetLeft += offsetParent.offsetLeft;\n        offsetParent = offsetParent.offsetParent;\n    }\n\n    return {offsetTop, offsetLeft};\n}\n","/**\n * Finds nearest parent with scroll in it\n *\n * @param element initial element\n * @param vertical flag for orientation of scroll\n */\nexport function getScrollParent(\n    element: Element | null,\n    vertical: boolean = true,\n): Element | null {\n    if (element === null) {\n        return null;\n    }\n\n    if (vertical && element.scrollHeight > element.clientHeight) {\n        return element;\n    }\n\n    if (!vertical && element.scrollWidth > element.clientWidth) {\n        return element;\n    }\n\n    return getScrollParent(element.parentElement, vertical);\n}\n","export function isCurrentTarget({target, currentTarget}: Event): boolean {\n    return target === currentTarget;\n}\n","import {getClosestElement} from './get-closest-element';\n\n/**\n * Checks if node is inside a specific selector\n *\n * @param node\n * @param selector\n * @return true if node is inside a particular selector\n */\nexport function isNodeIn(node: Node, selector: string): boolean {\n    return node.nodeType === Node.TEXT_NODE\n        ? !!node.parentElement && !!getClosestElement(node.parentElement, selector)\n        : node.nodeType === Node.ELEMENT_NODE &&\n              !!getClosestElement(node as Element, selector);\n}\n","export function tuiCustomEvent<T = null>(\n    name: string,\n    {bubbles = false, cancelable = false, detail = null}: CustomEventInit<T | null> = {},\n    documentRef: Document,\n): CustomEvent {\n    if (typeof CustomEvent === 'function') {\n        return new CustomEvent(name, {bubbles, cancelable, detail});\n    }\n\n    const customEvent = documentRef.createEvent('CustomEvent');\n\n    customEvent.initCustomEvent(name, bubbles, cancelable, detail);\n\n    return customEvent;\n}\n"]}