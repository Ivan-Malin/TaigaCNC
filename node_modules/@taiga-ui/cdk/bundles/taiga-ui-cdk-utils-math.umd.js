(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@taiga-ui/cdk/classes')) :
    typeof define === 'function' && define.amd ? define('@taiga-ui/cdk/utils/math', ['exports', '@taiga-ui/cdk/classes'], factory) :
    (global = global || self, factory((global['taiga-ui'] = global['taiga-ui'] || {}, global['taiga-ui'].cdk = global['taiga-ui'].cdk || {}, global['taiga-ui'].cdk.utils = global['taiga-ui'].cdk.utils || {}, global['taiga-ui'].cdk.utils.math = {}), global['taiga-ui'].cdk.classes));
}(this, (function (exports, classes) { 'use strict';

    /**
     * Clamps a value between two inclusive limits
     *
     * @param value
     * @param min lower limit
     * @param max upper limit
     */
    function clamp(value, min, max) {
        classes.tuiAssert.assert(!isNaN(value));
        classes.tuiAssert.assert(!isNaN(min));
        classes.tuiAssert.assert(!isNaN(max));
        classes.tuiAssert.assert(max >= min);
        return Math.min(max, Math.max(min, value));
    }

    /**
     * Checks if the value is in range
     *
     * @param value
     * @param fromInclude lower inclusive limit
     * @param toExclude upper exclusive limit
     */
    function inRange(value, fromInclude, toExclude) {
        classes.tuiAssert.assert(!isNaN(value));
        classes.tuiAssert.assert(!isNaN(fromInclude));
        classes.tuiAssert.assert(!isNaN(toExclude));
        classes.tuiAssert.assert(fromInclude < toExclude);
        return value >= fromInclude && value < toExclude;
    }

    /**
     * Normalizes any number to an integer within inclusive range
     *
     * @param value
     * @param min lower inclusive integer
     * @param max upper inclusive integer
     * @return an integer between min and max inclusive
     */
    function normalizeToIntNumber(value, min, max) {
        classes.tuiAssert.assert(Number.isInteger(min));
        classes.tuiAssert.assert(Number.isInteger(max));
        classes.tuiAssert.assert(min <= max);
        if (isNaN(value) || value <= min) {
            return min;
        }
        if (value >= max) {
            return max;
        }
        return Math.round(value);
    }

    /**
     * Rounds a number to the closest value in a fixed discrete series
     *
     * @param value
     * @param quantum series step
     */
    function quantize(value, quantum) {
        classes.tuiAssert.assert(Number.isFinite(value));
        classes.tuiAssert.assert(Number.isFinite(quantum));
        classes.tuiAssert.assert(quantum > 0);
        var remainder = value % quantum;
        return remainder < quantum / 2 ? value - remainder : value + quantum - remainder;
    }

    var MAX_PRECISION = 292;
    function round(value, precision) {
        if (precision === void 0) { precision = 0; }
        return calculate(value, precision, Math.round);
    }
    function ceil(value, precision) {
        if (precision === void 0) { precision = 0; }
        return calculate(value, precision, Math.ceil);
    }
    function floor(value, precision) {
        if (precision === void 0) { precision = 0; }
        return calculate(value, precision, Math.floor);
    }
    /**
     * Rounding number to the set precision
     *
     * @param value
     * @param precision number of digits in a float part
     * @param func rounding function (round, floor, ceil)
     */
    function calculate(value, precision, func) {
        if (value === Infinity) {
            return value;
        }
        classes.tuiAssert.assert(!isNaN(value), 'Value must be number');
        classes.tuiAssert.assert(Number.isInteger(precision), 'Precision must be integer');
        precision = Math.min(precision, MAX_PRECISION);
        var pair = (value + "e").split('e');
        var tempValue = func(Number(pair[0] + "e" + (Number(pair[1]) + precision)));
        var processedPair = (tempValue + "e").split('e');
        return Number(processedPair[0] + "e" + (Number(processedPair[1]) - precision));
    }

    /**
     * Calculates sum of any number of passed arguments
     */
    function sum() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return args.reduce(function (a, b) { return a + b; }, 0);
    }

    /**
     * Converts angle in degrees to radians
     */
    function toRadians(deg) {
        return (deg * Math.PI) / 180;
    }

    exports.ceil = ceil;
    exports.clamp = clamp;
    exports.floor = floor;
    exports.inRange = inRange;
    exports.normalizeToIntNumber = normalizeToIntNumber;
    exports.quantize = quantize;
    exports.round = round;
    exports.sum = sum;
    exports.toRadians = toRadians;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=taiga-ui-cdk-utils-math.umd.js.map
