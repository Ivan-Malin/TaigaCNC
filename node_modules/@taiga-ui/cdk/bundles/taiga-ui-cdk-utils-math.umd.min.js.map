{"version":3,"sources":["ng://@taiga-ui/cdk/utils/math/round.ts","ng://@taiga-ui/cdk/utils/math/clamp.ts","ng://@taiga-ui/cdk/utils/math/in-range.ts","ng://@taiga-ui/cdk/utils/math/normalize-to-int-number.ts","ng://@taiga-ui/cdk/utils/math/quantize.ts","ng://@taiga-ui/cdk/utils/math/sum.ts","ng://@taiga-ui/cdk/utils/math/to-radians.ts"],"names":["calculate","value","precision","func","Infinity","tuiAssert","assert","isNaN","Number","isInteger","Math","min","pair","split","processedPair","ceil","max","floor","fromInclude","toExclude","round","quantum","isFinite","remainder","args","_i","arguments","length","reduce","a","b","deg","PI"],"mappings":"scAuBA,SAASA,EACLC,EACAC,EACAC,GAEA,GAAIF,IAAUG,EAAAA,EACV,OAAOH,EAGXI,EAAAA,UAAUC,QAAQC,MAAMN,GAAQ,wBAChCI,EAAAA,UAAUC,OAAOE,OAAOC,UAAUP,GAAY,6BAE9CA,EAAYQ,KAAKC,IAAIT,EAjCH,KAmClB,IAAMU,GAAUX,EAAK,KAAIY,MAAM,KAEzBC,GADYX,EAAKK,OAAUI,EAAK,GAAE,KAAIJ,OAAOI,EAAK,IAAMV,KAC5B,KAAIW,MAAM,KAE5C,OAAOL,OAAUM,EAAc,GAAE,KAAIN,OAAOM,EAAc,IAAMZ,oBAjC/CD,EAAeC,GAChC,YADgC,IAAAA,IAAAA,EAAA,GACzBF,EAAUC,EAAOC,EAAWQ,KAAKK,wBCAtBd,EAAeU,EAAaK,GAM9C,OALAX,EAAAA,UAAUC,QAAQC,MAAMN,IACxBI,EAAAA,UAAUC,QAAQC,MAAMI,IACxBN,EAAAA,UAAUC,QAAQC,MAAMS,IACxBX,EAAAA,UAAUC,OAAOU,GAAOL,GAEjBD,KAAKC,IAAIK,EAAKN,KAAKM,IAAIL,EAAKV,sBDHjBA,EAAeC,GACjC,YADiC,IAAAA,IAAAA,EAAA,GAC1BF,EAAUC,EAAOC,EAAWQ,KAAKO,2BEJpBhB,EAAeiB,EAAqBC,GAMxD,OALAd,EAAAA,UAAUC,QAAQC,MAAMN,IACxBI,EAAAA,UAAUC,QAAQC,MAAMW,IACxBb,EAAAA,UAAUC,QAAQC,MAAMY,IACxBd,EAAAA,UAAUC,OAAOY,EAAcC,GAExBlB,GAASiB,GAAejB,EAAQkB,mCCLNlB,EAAeU,EAAaK,GAK7D,OAJAX,EAAAA,UAAUC,OAAOE,OAAOC,UAAUE,IAClCN,EAAAA,UAAUC,OAAOE,OAAOC,UAAUO,IAClCX,EAAAA,UAAUC,OAAOK,GAAOK,GAEpBT,MAAMN,IAAUA,GAASU,EAClBA,EAGPV,GAASe,EACFA,EAGJN,KAAKU,MAAMnB,wBCfGA,EAAeoB,GACpChB,EAAAA,UAAUC,OAAOE,OAAOc,SAASrB,IACjCI,EAAAA,UAAUC,OAAOE,OAAOc,SAASD,IACjChB,EAAAA,UAAUC,OAAOe,EAAU,GAE3B,IAAME,EAAYtB,EAAQoB,EAE1B,OAAOE,EAAYF,EAAU,EAAIpB,EAAQsB,EAAYtB,EAAQoB,EAAUE,oBJXrDtB,EAAeC,GACjC,YADiC,IAAAA,IAAAA,EAAA,GAC1BF,EAAUC,EAAOC,EAAWQ,KAAKU,6BKFxB,IAAAI,EAAA,GAAAC,EAAA,EAAAA,EAAAC,UAAAC,OAAAF,IAAAD,EAAAC,GAAAC,UAAAD,GAChB,OAAOD,EAAKI,QAAO,SAACC,EAAGC,GAAM,OAAAD,EAAIC,IAAG,yBCDdC,GACtB,OAAQA,EAAMrB,KAAKsB,GAAM","sourcesContent":["import {tuiAssert} from '@taiga-ui/cdk/classes';\n\nconst MAX_PRECISION = 292;\n\nexport function round(value: number, precision: number = 0): number {\n    return calculate(value, precision, Math.round);\n}\n\nexport function ceil(value: number, precision: number = 0): number {\n    return calculate(value, precision, Math.ceil);\n}\n\nexport function floor(value: number, precision: number = 0): number {\n    return calculate(value, precision, Math.floor);\n}\n\n/**\n * Rounding number to the set precision\n *\n * @param value\n * @param precision number of digits in a float part\n * @param func rounding function (round, floor, ceil)\n */\nfunction calculate(\n    value: number,\n    precision: number,\n    func: (x: number) => number,\n): number {\n    if (value === Infinity) {\n        return value;\n    }\n\n    tuiAssert.assert(!isNaN(value), 'Value must be number');\n    tuiAssert.assert(Number.isInteger(precision), 'Precision must be integer');\n\n    precision = Math.min(precision, MAX_PRECISION);\n\n    const pair = `${value}e`.split('e');\n    const tempValue = func(Number(`${pair[0]}e${Number(pair[1]) + precision}`));\n    const processedPair = `${tempValue}e`.split('e');\n\n    return Number(`${processedPair[0]}e${Number(processedPair[1]) - precision}`);\n}\n","import {tuiAssert} from '@taiga-ui/cdk/classes';\n\n/**\n * Clamps a value between two inclusive limits\n *\n * @param value\n * @param min lower limit\n * @param max upper limit\n */\nexport function clamp(value: number, min: number, max: number): number {\n    tuiAssert.assert(!isNaN(value));\n    tuiAssert.assert(!isNaN(min));\n    tuiAssert.assert(!isNaN(max));\n    tuiAssert.assert(max >= min);\n\n    return Math.min(max, Math.max(min, value));\n}\n","import {tuiAssert} from '@taiga-ui/cdk/classes';\n\n/**\n * Checks if the value is in range\n *\n * @param value\n * @param fromInclude lower inclusive limit\n * @param toExclude upper exclusive limit\n */\nexport function inRange(value: number, fromInclude: number, toExclude: number): boolean {\n    tuiAssert.assert(!isNaN(value));\n    tuiAssert.assert(!isNaN(fromInclude));\n    tuiAssert.assert(!isNaN(toExclude));\n    tuiAssert.assert(fromInclude < toExclude);\n\n    return value >= fromInclude && value < toExclude;\n}\n","import {tuiAssert} from '@taiga-ui/cdk/classes';\n\n/**\n * Normalizes any number to an integer within inclusive range\n *\n * @param value\n * @param min lower inclusive integer\n * @param max upper inclusive integer\n * @return an integer between min and max inclusive\n */\nexport function normalizeToIntNumber(value: number, min: number, max: number): number {\n    tuiAssert.assert(Number.isInteger(min));\n    tuiAssert.assert(Number.isInteger(max));\n    tuiAssert.assert(min <= max);\n\n    if (isNaN(value) || value <= min) {\n        return min;\n    }\n\n    if (value >= max) {\n        return max;\n    }\n\n    return Math.round(value);\n}\n","import {tuiAssert} from '@taiga-ui/cdk/classes';\n\n/**\n * Rounds a number to the closest value in a fixed discrete series\n *\n * @param value\n * @param quantum series step\n */\nexport function quantize(value: number, quantum: number): number {\n    tuiAssert.assert(Number.isFinite(value));\n    tuiAssert.assert(Number.isFinite(quantum));\n    tuiAssert.assert(quantum > 0);\n\n    const remainder = value % quantum;\n\n    return remainder < quantum / 2 ? value - remainder : value + quantum - remainder;\n}\n","/**\n * Calculates sum of any number of passed arguments\n */\nexport function sum(...args: number[]): number {\n    return args.reduce((a, b) => a + b, 0);\n}\n","/**\n * Converts angle in degrees to radians\n */\nexport function toRadians(deg: number): number {\n    return (deg * Math.PI) / 180;\n}\n"]}