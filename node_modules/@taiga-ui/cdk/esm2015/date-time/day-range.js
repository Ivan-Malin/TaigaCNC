import { tuiAssert } from '@taiga-ui/cdk/classes';
import { RANGE_SEPARATOR_CHAR } from './date-time';
import { TuiDay } from './day';
import { TuiMonthRange } from './month-range';
/**
 * An immutable range of two {@link TuiDay} objects
 */
export class TuiDayRange extends TuiMonthRange {
    constructor(from, to) {
        super(from, to);
        this.from = from;
        this.to = to;
        tuiAssert.assert(from.daySameOrBefore(to));
    }
    get isSingleDay() {
        return this.from.daySame(this.to);
    }
    /**
     * Human readable format.
     */
    get formattedDayRange() {
        return `${this.from.formattedDay}${RANGE_SEPARATOR_CHAR}${this.to.formattedDay}`;
    }
    /**
     * Tests ranges for identity
     *
     * @param another second range to test against current
     * @return `true` if days are identical
     */
    daySame(another) {
        return this.from.daySame(another.from) && this.to.daySame(another.to);
    }
    /**
     * Locks range between two days included, or limits from one side if the other is null
     *
     * @param min
     * @param max
     * @return range â€” clamped range
     */
    dayLimit(min, max) {
        return new TuiDayRange(this.from.dayLimit(min, max), this.to.dayLimit(min, max));
    }
    /**
     * Creates range from two days after sorting them
     *
     * @param day1
     * @param day2
     * @return new range with sorted days
     */
    static sort(day1, day2) {
        return day1.daySameOrBefore(day2)
            ? new TuiDayRange(day1, day2)
            : new TuiDayRange(day2, day1);
    }
    /**
     * Parse and correct a day range in string format
     *
     * @param rangeString a string of dates in a format dd.mm.yyyy - dd.mm.yyyy
     * @return normalized day range object
     */
    static normalizeParse(rangeString, dateFiller, dateRangeFiller) {
        const leftDay = TuiDay.normalizeParse(rangeString.slice(0, dateFiller.length));
        if (rangeString.length < dateRangeFiller.length) {
            return new TuiDayRange(leftDay, leftDay);
        }
        return TuiDayRange.sort(leftDay, TuiDay.normalizeParse(rangeString.slice(dateFiller.length + RANGE_SEPARATOR_CHAR.length)));
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF5LXJhbmdlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQHRhaWdhLXVpL2Nkay9kYXRlLXRpbWUvIiwic291cmNlcyI6WyJkYXktcmFuZ2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFDLFNBQVMsRUFBQyxNQUFNLHVCQUF1QixDQUFDO0FBQ2hELE9BQU8sRUFBQyxvQkFBb0IsRUFBQyxNQUFNLGFBQWEsQ0FBQztBQUNqRCxPQUFPLEVBQUMsTUFBTSxFQUFDLE1BQU0sT0FBTyxDQUFDO0FBQzdCLE9BQU8sRUFBQyxhQUFhLEVBQUMsTUFBTSxlQUFlLENBQUM7QUFFNUM7O0dBRUc7QUFDSCxNQUFNLE9BQU8sV0FBWSxTQUFRLGFBQWE7SUFDMUMsWUFBcUIsSUFBWSxFQUFXLEVBQVU7UUFDbEQsS0FBSyxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsQ0FBQztRQURDLFNBQUksR0FBSixJQUFJLENBQVE7UUFBVyxPQUFFLEdBQUYsRUFBRSxDQUFRO1FBR2xELFNBQVMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQy9DLENBQUM7SUFFRCxJQUFJLFdBQVc7UUFDWCxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUN0QyxDQUFDO0lBRUQ7O09BRUc7SUFDSCxJQUFJLGlCQUFpQjtRQUNqQixPQUFPLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFZLEdBQUcsb0JBQW9CLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQyxZQUFZLEVBQUUsQ0FBQztJQUNyRixDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCxPQUFPLENBQUMsT0FBb0I7UUFDeEIsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksSUFBSSxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0lBQzFFLENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSCxRQUFRLENBQUMsR0FBa0IsRUFBRSxHQUFrQjtRQUMzQyxPQUFPLElBQUksV0FBVyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsRUFBRSxJQUFJLENBQUMsRUFBRSxDQUFDLFFBQVEsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUNyRixDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0gsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFZLEVBQUUsSUFBWTtRQUNsQyxPQUFPLElBQUksQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDO1lBQzdCLENBQUMsQ0FBQyxJQUFJLFdBQVcsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDO1lBQzdCLENBQUMsQ0FBQyxJQUFJLFdBQVcsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDdEMsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsTUFBTSxDQUFDLGNBQWMsQ0FDakIsV0FBbUIsRUFDbkIsVUFBa0IsRUFDbEIsZUFBdUI7UUFFdkIsTUFBTSxPQUFPLEdBQUcsTUFBTSxDQUFDLGNBQWMsQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztRQUUvRSxJQUFJLFdBQVcsQ0FBQyxNQUFNLEdBQUcsZUFBZSxDQUFDLE1BQU0sRUFBRTtZQUM3QyxPQUFPLElBQUksV0FBVyxDQUFDLE9BQU8sRUFBRSxPQUFPLENBQUMsQ0FBQztTQUM1QztRQUVELE9BQU8sV0FBVyxDQUFDLElBQUksQ0FDbkIsT0FBTyxFQUNQLE1BQU0sQ0FBQyxjQUFjLENBQ2pCLFdBQVcsQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDLE1BQU0sR0FBRyxvQkFBb0IsQ0FBQyxNQUFNLENBQUMsQ0FDckUsQ0FDSixDQUFDO0lBQ04sQ0FBQztDQUNKIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHt0dWlBc3NlcnR9IGZyb20gJ0B0YWlnYS11aS9jZGsvY2xhc3Nlcyc7XG5pbXBvcnQge1JBTkdFX1NFUEFSQVRPUl9DSEFSfSBmcm9tICcuL2RhdGUtdGltZSc7XG5pbXBvcnQge1R1aURheX0gZnJvbSAnLi9kYXknO1xuaW1wb3J0IHtUdWlNb250aFJhbmdlfSBmcm9tICcuL21vbnRoLXJhbmdlJztcblxuLyoqXG4gKiBBbiBpbW11dGFibGUgcmFuZ2Ugb2YgdHdvIHtAbGluayBUdWlEYXl9IG9iamVjdHNcbiAqL1xuZXhwb3J0IGNsYXNzIFR1aURheVJhbmdlIGV4dGVuZHMgVHVpTW9udGhSYW5nZSB7XG4gICAgY29uc3RydWN0b3IocmVhZG9ubHkgZnJvbTogVHVpRGF5LCByZWFkb25seSB0bzogVHVpRGF5KSB7XG4gICAgICAgIHN1cGVyKGZyb20sIHRvKTtcblxuICAgICAgICB0dWlBc3NlcnQuYXNzZXJ0KGZyb20uZGF5U2FtZU9yQmVmb3JlKHRvKSk7XG4gICAgfVxuXG4gICAgZ2V0IGlzU2luZ2xlRGF5KCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5mcm9tLmRheVNhbWUodGhpcy50byk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSHVtYW4gcmVhZGFibGUgZm9ybWF0LlxuICAgICAqL1xuICAgIGdldCBmb3JtYXR0ZWREYXlSYW5nZSgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5mcm9tLmZvcm1hdHRlZERheX0ke1JBTkdFX1NFUEFSQVRPUl9DSEFSfSR7dGhpcy50by5mb3JtYXR0ZWREYXl9YDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUZXN0cyByYW5nZXMgZm9yIGlkZW50aXR5XG4gICAgICpcbiAgICAgKiBAcGFyYW0gYW5vdGhlciBzZWNvbmQgcmFuZ2UgdG8gdGVzdCBhZ2FpbnN0IGN1cnJlbnRcbiAgICAgKiBAcmV0dXJuIGB0cnVlYCBpZiBkYXlzIGFyZSBpZGVudGljYWxcbiAgICAgKi9cbiAgICBkYXlTYW1lKGFub3RoZXI6IFR1aURheVJhbmdlKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLmZyb20uZGF5U2FtZShhbm90aGVyLmZyb20pICYmIHRoaXMudG8uZGF5U2FtZShhbm90aGVyLnRvKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2NrcyByYW5nZSBiZXR3ZWVuIHR3byBkYXlzIGluY2x1ZGVkLCBvciBsaW1pdHMgZnJvbSBvbmUgc2lkZSBpZiB0aGUgb3RoZXIgaXMgbnVsbFxuICAgICAqXG4gICAgICogQHBhcmFtIG1pblxuICAgICAqIEBwYXJhbSBtYXhcbiAgICAgKiBAcmV0dXJuIHJhbmdlIOKAlCBjbGFtcGVkIHJhbmdlXG4gICAgICovXG4gICAgZGF5TGltaXQobWluOiBUdWlEYXkgfCBudWxsLCBtYXg6IFR1aURheSB8IG51bGwpOiBUdWlEYXlSYW5nZSB7XG4gICAgICAgIHJldHVybiBuZXcgVHVpRGF5UmFuZ2UodGhpcy5mcm9tLmRheUxpbWl0KG1pbiwgbWF4KSwgdGhpcy50by5kYXlMaW1pdChtaW4sIG1heCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgcmFuZ2UgZnJvbSB0d28gZGF5cyBhZnRlciBzb3J0aW5nIHRoZW1cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkYXkxXG4gICAgICogQHBhcmFtIGRheTJcbiAgICAgKiBAcmV0dXJuIG5ldyByYW5nZSB3aXRoIHNvcnRlZCBkYXlzXG4gICAgICovXG4gICAgc3RhdGljIHNvcnQoZGF5MTogVHVpRGF5LCBkYXkyOiBUdWlEYXkpOiBUdWlEYXlSYW5nZSB7XG4gICAgICAgIHJldHVybiBkYXkxLmRheVNhbWVPckJlZm9yZShkYXkyKVxuICAgICAgICAgICAgPyBuZXcgVHVpRGF5UmFuZ2UoZGF5MSwgZGF5MilcbiAgICAgICAgICAgIDogbmV3IFR1aURheVJhbmdlKGRheTIsIGRheTEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhcnNlIGFuZCBjb3JyZWN0IGEgZGF5IHJhbmdlIGluIHN0cmluZyBmb3JtYXRcbiAgICAgKlxuICAgICAqIEBwYXJhbSByYW5nZVN0cmluZyBhIHN0cmluZyBvZiBkYXRlcyBpbiBhIGZvcm1hdCBkZC5tbS55eXl5IC0gZGQubW0ueXl5eVxuICAgICAqIEByZXR1cm4gbm9ybWFsaXplZCBkYXkgcmFuZ2Ugb2JqZWN0XG4gICAgICovXG4gICAgc3RhdGljIG5vcm1hbGl6ZVBhcnNlKFxuICAgICAgICByYW5nZVN0cmluZzogc3RyaW5nLFxuICAgICAgICBkYXRlRmlsbGVyOiBzdHJpbmcsXG4gICAgICAgIGRhdGVSYW5nZUZpbGxlcjogc3RyaW5nLFxuICAgICk6IFR1aURheVJhbmdlIHtcbiAgICAgICAgY29uc3QgbGVmdERheSA9IFR1aURheS5ub3JtYWxpemVQYXJzZShyYW5nZVN0cmluZy5zbGljZSgwLCBkYXRlRmlsbGVyLmxlbmd0aCkpO1xuXG4gICAgICAgIGlmIChyYW5nZVN0cmluZy5sZW5ndGggPCBkYXRlUmFuZ2VGaWxsZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFR1aURheVJhbmdlKGxlZnREYXksIGxlZnREYXkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFR1aURheVJhbmdlLnNvcnQoXG4gICAgICAgICAgICBsZWZ0RGF5LFxuICAgICAgICAgICAgVHVpRGF5Lm5vcm1hbGl6ZVBhcnNlKFxuICAgICAgICAgICAgICAgIHJhbmdlU3RyaW5nLnNsaWNlKGRhdGVGaWxsZXIubGVuZ3RoICsgUkFOR0VfU0VQQVJBVE9SX0NIQVIubGVuZ3RoKSxcbiAgICAgICAgICAgICksXG4gICAgICAgICk7XG4gICAgfVxufVxuIl19