import { tuiAssert } from '@taiga-ui/cdk/classes';
import { padStart } from '@taiga-ui/cdk/utils/format';
import { inRange, normalizeToIntNumber } from '@taiga-ui/cdk/utils/math';
import { DAYS_IN_WEEK, MIN_DAY, MONTHS_IN_YEAR } from './date-time';
import { TuiMonth } from './month';
import { TuiYear } from './year';
// TODO: Localized formatting
/**
 * Immutable date object, consisting of day, month and year
 */
export class TuiDay extends TuiMonth {
    constructor(year, month, day) {
        super(year, month);
        this.day = day;
        tuiAssert.assert(TuiDay.isValidDay(year, month, day));
    }
    get formattedDayPart() {
        return padStart(this.day.toString(), 2, '0');
    }
    /**
     * Formatted whole date
     */
    get formattedDay() {
        return `${this.formattedDayPart}.${this.formattedMonth}`;
    }
    /**
     * Returns day of week
     *
     * @param startFromMonday whether week starts from Monday and not from Sunday
     * @return day of week (from 0 to 6)
     */
    dayOfWeek(startFromMonday = true) {
        const dayOfWeek = startFromMonday
            ? this.toLocalNativeDate().getDay() - 1
            : this.toLocalNativeDate().getDay();
        return dayOfWeek < 0 ? 6 : dayOfWeek;
    }
    /**
     * Passed date is after current
     */
    dayBefore(another) {
        return (this.monthBefore(another) ||
            (this.monthSame(another) && this.day < another.day));
    }
    /**
     * Passed date is after or equals to current
     */
    daySameOrBefore(another) {
        return (this.monthBefore(another) ||
            (this.monthSame(another) && this.day <= another.day));
    }
    /**
     * Passed date is the same as current
     */
    daySame(another) {
        return this.monthSame(another) && this.day === another.day;
    }
    /**
     * Passed date is either before or the same as current
     */
    daySameOrAfter(another) {
        return (this.monthAfter(another) ||
            (this.monthSame(another) && this.day >= another.day));
    }
    /**
     * Passed date is before current
     */
    dayAfter(another) {
        return (this.monthAfter(another) ||
            (this.monthSame(another) && this.day > another.day));
    }
    /**
     * Clamping date between two limits
     *
     * @param min
     * @param max
     * @return clamped date
     */
    dayLimit(min, max) {
        if (min !== null && this.dayBefore(min)) {
            return min;
        }
        if (max !== null && this.dayAfter(max)) {
            return max;
        }
        return this;
    }
    // TODO: Consider removing `backwards` option
    /**
     * Immutably alters current day by passed offset
     *
     * If resulting month has more days than original one, date is rounded to the maximum day
     * in the resulting month. Offset of days will be calculated based on the resulted year and month
     * to not interfere with parent classes methods
     *
     * @param offset
     * @param backwards shift date backwards
     * @return new date object as a result of offsetting current
     */
    append({ year = 0, month = 0, day = 0 }, backwards = false) {
        if (backwards) {
            year *= -1;
            month *= -1;
            day *= -1;
        }
        const totalMonths = (this.year + year) * MONTHS_IN_YEAR + this.month + month;
        let years = Math.floor(totalMonths / MONTHS_IN_YEAR);
        let months = totalMonths % MONTHS_IN_YEAR;
        let days = Math.min(this.day, TuiMonth.getMonthDaysCount(months, TuiYear.isLeapYear(years))) + day;
        while (days > TuiMonth.getMonthDaysCount(months, TuiYear.isLeapYear(years))) {
            days -= TuiMonth.getMonthDaysCount(months, TuiYear.isLeapYear(years));
            if (months === 11 /* December */) {
                years++;
                months = 0 /* January */;
            }
            else {
                months++;
            }
        }
        while (days < MIN_DAY) {
            if (months === 0 /* January */) {
                years--;
                months = 11 /* December */;
            }
            else {
                months--;
            }
            days += TuiMonth.getMonthDaysCount(months, TuiYear.isLeapYear(years));
        }
        return new TuiDay(years, months, days);
    }
    toString() {
        return this.formattedDay;
    }
    toJSON() {
        return `${super.toJSON()}-${this.formattedDayPart}`;
    }
    /**
     * Returns native {@link Date} based on local time zone
     */
    toLocalNativeDate() {
        return new Date(this.year, this.month, this.day);
    }
    /**
     * Returns native {@link Date} based on UTC
     */
    toUtcNativeDate() {
        return new Date(Date.UTC(this.year, this.month, this.day));
    }
    /**
     * Creates {@link TuiDay} from native {@link Date} based on local time zone
     */
    static fromLocalNativeDate(date) {
        return new TuiDay(date.getFullYear(), date.getMonth(), date.getDate());
    }
    /**
     * Creates {@link TuiDay} from native {@link Date} using UTC
     */
    static fromUtcNativeDate(date) {
        return new TuiDay(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());
    }
    /**
     * Check validity of year, month and day
     *
     * @param year
     * @param month
     * @param day
     * @return boolean validity
     */
    static isValidDay(year, month, day) {
        return (TuiMonth.isValidMonth(year, month) &&
            Number.isInteger(day) &&
            inRange(day, MIN_DAY, TuiMonth.getMonthDaysCount(month, TuiYear.isLeapYear(year)) + 1));
    }
    /**
     * Calculated day on a calendar grid
     *
     * @param month
     * @param row row in a calendar
     * @param col column in a calendar
     * @return resulting day on these coordinates (could exceed passed month)
     */
    static getDayFromMonthRowCol(month, row, col) {
        tuiAssert.assert(Number.isInteger(row));
        tuiAssert.assert(inRange(row, 0, 6));
        tuiAssert.assert(Number.isInteger(col));
        tuiAssert.assert(inRange(col, 0, DAYS_IN_WEEK));
        let day = row * DAYS_IN_WEEK + col - month.monthStartDaysOffset + 1;
        if (day > month.daysCount) {
            day = day - month.daysCount;
            month = month.append({ month: 1 });
        }
        if (day <= 0) {
            month = month.append({ month: -1 });
            day = month.daysCount + day;
        }
        return new TuiDay(month.year, month.month, day);
    }
    /**
     * Current day based on local time zone
     */
    static currentLocal() {
        const nativeDate = new Date();
        const year = nativeDate.getFullYear();
        const month = nativeDate.getMonth();
        const day = nativeDate.getDate();
        return new TuiDay(year, month, day);
    }
    /**
     * Calculates {@link TuiDay} normalizing year, month and day. {@link NaN} is turned into minimal value.
     *
     * @param year any year value, including invalid
     * @param month any month value, including invalid (months start with 0)
     * @param day any day value, including invalid
     * @return normalized date
     */
    static normalizeOf(year, month, day) {
        const normalizedYear = TuiYear.normalizeYearPart(year);
        const normalizedMonth = TuiMonth.normalizeMonthPart(month);
        const normalizedDay = TuiDay.normalizeDayPart(day, normalizedMonth, normalizedYear);
        return new TuiDay(normalizedYear, normalizedMonth, normalizedDay);
    }
    static lengthBetween(from, to) {
        return Math.round((to.toLocalNativeDate().getTime() - from.toLocalNativeDate().getTime()) /
            (1000 * 60 * 60 * 24));
    }
    // TODO: Move month and year related code corresponding classes
    /**
     * Parsing a string with date with normalization
     *
     * @param yearMonthDayString date string in format of DD.MM.Yyyy
     * @return normalized date
     */
    static normalizeParse(yearMonthDayString) {
        const day = parseInt(yearMonthDayString.slice(0, 2), 10);
        const month = parseInt(yearMonthDayString.slice(3, 5), 10) - 1;
        const year = parseInt(yearMonthDayString.slice(6, 10), 10);
        return TuiDay.normalizeOf(year, month, day);
    }
    /**
     * Parsing a date stringified in a toJSON format
     * @param yearMonthDayString date string in format of YYYY-MM-DD
     * @return date
     * @throws exceptions if any part of the date is invalid
     */
    static jsonParse(yearMonthDayString) {
        const day = parseInt(yearMonthDayString.slice(8, 10), 10);
        const month = parseInt(yearMonthDayString.slice(5, 7), 10) - 1;
        const year = parseInt(yearMonthDayString.slice(0, 4), 10);
        if (!TuiYear.isValidYear(year)) {
            throw new Error('Invalid year: ' + year);
        }
        if (!TuiMonth.isValidMonth(year, month)) {
            throw new Error('Invalid month: ' + month);
        }
        if (!Number.isInteger(day) ||
            !inRange(day, MIN_DAY, TuiMonth.getMonthDaysCount(month, TuiYear.isLeapYear(year)) + 1)) {
            throw new Error('Invalid day: ' + day);
        }
        return new TuiDay(year, month, day);
    }
    static normalizeDayPart(day, month, year) {
        tuiAssert.assert(TuiMonth.isValidMonth(year, month));
        const monthDaysCount = TuiMonth.getMonthDaysCount(month, TuiYear.isLeapYear(year));
        return normalizeToIntNumber(day, 1, monthDaysCount);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF5LmpzIiwic291cmNlUm9vdCI6Im5nOi8vQHRhaWdhLXVpL2Nkay9kYXRlLXRpbWUvIiwic291cmNlcyI6WyJkYXkudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFDLFNBQVMsRUFBQyxNQUFNLHVCQUF1QixDQUFDO0FBR2hELE9BQU8sRUFBQyxRQUFRLEVBQUMsTUFBTSw0QkFBNEIsQ0FBQztBQUNwRCxPQUFPLEVBQUMsT0FBTyxFQUFFLG9CQUFvQixFQUFDLE1BQU0sMEJBQTBCLENBQUM7QUFDdkUsT0FBTyxFQUFDLFlBQVksRUFBRSxPQUFPLEVBQUUsY0FBYyxFQUFDLE1BQU0sYUFBYSxDQUFDO0FBQ2xFLE9BQU8sRUFBQyxRQUFRLEVBQUMsTUFBTSxTQUFTLENBQUM7QUFDakMsT0FBTyxFQUFDLE9BQU8sRUFBQyxNQUFNLFFBQVEsQ0FBQztBQUUvQiw2QkFBNkI7QUFDN0I7O0dBRUc7QUFDSCxNQUFNLE9BQU8sTUFBTyxTQUFRLFFBQVE7SUFDaEMsWUFBWSxJQUFZLEVBQUUsS0FBYSxFQUFXLEdBQVc7UUFDekQsS0FBSyxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQztRQUQyQixRQUFHLEdBQUgsR0FBRyxDQUFRO1FBRXpELFNBQVMsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxJQUFJLEVBQUUsS0FBSyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDMUQsQ0FBQztJQUVELElBQUksZ0JBQWdCO1FBQ2hCLE9BQU8sUUFBUSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsUUFBUSxFQUFFLEVBQUUsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0lBQ2pELENBQUM7SUFFRDs7T0FFRztJQUNILElBQUksWUFBWTtRQUNaLE9BQU8sR0FBRyxJQUFJLENBQUMsZ0JBQWdCLElBQUksSUFBSSxDQUFDLGNBQWMsRUFBRSxDQUFDO0lBQzdELENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILFNBQVMsQ0FBQyxrQkFBMkIs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Q0FBQyxHQUFHLENBQUM7WUFDdEIsQ0FBQyxPQUFPLENBQ0osR0FBRyxFQUNILE9BQU8sRUFDUCxRQUFRLENBQUMsaUJBQWlCLENBQUMsS0FBSyxFQUFFLE9BQU8sQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQ2xFLEVBQ0g7WUFDRSxNQUFNLElBQUksS0FBSyxDQUFDLGVBQWUsR0FBRyxHQUFHLENBQUMsQ0FBQztTQUMxQztRQUVELE9BQU8sSUFBSSxNQUFNLENBQUMsSUFBSSxFQUFFLEtBQUssRUFBRSxHQUFHLENBQUMsQ0FBQztJQUN4QyxDQUFDO0lBRVMsTUFBTSxDQUFDLGdCQUFnQixDQUFDLEdBQVcsRUFBRSxLQUFhLEVBQUUsSUFBWTtRQUN0RSxTQUFTLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxZQUFZLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUM7UUFFckQsTUFBTSxjQUFjLEdBQUcsUUFBUSxDQUFDLGlCQUFpQixDQUM3QyxLQUFLLEVBQ0wsT0FBTyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FDM0IsQ0FBQztRQUVGLE9BQU8sb0JBQW9CLENBQUMsR0FBRyxFQUFFLENBQUMsRUFBRSxjQUFjLENBQUMsQ0FBQztJQUN4RCxDQUFDO0NBQ0oiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge3R1aUFzc2VydH0gZnJvbSAnQHRhaWdhLXVpL2Nkay9jbGFzc2VzJztcbmltcG9ydCB7VHVpTW9udGhOdW1iZXJ9IGZyb20gJ0B0YWlnYS11aS9jZGsvZW51bXMnO1xuaW1wb3J0IHtUdWlEYXlMaWtlfSBmcm9tICdAdGFpZ2EtdWkvY2RrL2ludGVyZmFjZXMnO1xuaW1wb3J0IHtwYWRTdGFydH0gZnJvbSAnQHRhaWdhLXVpL2Nkay91dGlscy9mb3JtYXQnO1xuaW1wb3J0IHtpblJhbmdlLCBub3JtYWxpemVUb0ludE51bWJlcn0gZnJvbSAnQHRhaWdhLXVpL2Nkay91dGlscy9tYXRoJztcbmltcG9ydCB7REFZU19JTl9XRUVLLCBNSU5fREFZLCBNT05USFNfSU5fWUVBUn0gZnJvbSAnLi9kYXRlLXRpbWUnO1xuaW1wb3J0IHtUdWlNb250aH0gZnJvbSAnLi9tb250aCc7XG5pbXBvcnQge1R1aVllYXJ9IGZyb20gJy4veWVhcic7XG5cbi8vIFRPRE86IExvY2FsaXplZCBmb3JtYXR0aW5nXG4vKipcbiAqIEltbXV0YWJsZSBkYXRlIG9iamVjdCwgY29uc2lzdGluZyBvZiBkYXksIG1vbnRoIGFuZCB5ZWFyXG4gKi9cbmV4cG9ydCBjbGFzcyBUdWlEYXkgZXh0ZW5kcyBUdWlNb250aCB7XG4gICAgY29uc3RydWN0b3IoeWVhcjogbnVtYmVyLCBtb250aDogbnVtYmVyLCByZWFkb25seSBkYXk6IG51bWJlcikge1xuICAgICAgICBzdXBlcih5ZWFyLCBtb250aCk7XG4gICAgICAgIHR1aUFzc2VydC5hc3NlcnQoVHVpRGF5LmlzVmFsaWREYXkoeWVhciwgbW9udGgsIGRheSkpO1xuICAgIH1cblxuICAgIGdldCBmb3JtYXR0ZWREYXlQYXJ0KCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiBwYWRTdGFydCh0aGlzLmRheS50b1N0cmluZygpLCAyLCAnMCcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZvcm1hdHRlZCB3aG9sZSBkYXRlXG4gICAgICovXG4gICAgZ2V0IGZvcm1hdHRlZERheSgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5mb3JtYXR0ZWREYXlQYXJ0fS4ke3RoaXMuZm9ybWF0dGVkTW9udGh9YDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGRheSBvZiB3ZWVrXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3RhcnRGcm9tTW9uZGF5IHdoZXRoZXIgd2VlayBzdGFydHMgZnJvbSBNb25kYXkgYW5kIG5vdCBmcm9tIFN1bmRheVxuICAgICAqIEByZXR1cm4gZGF5IG9mIHdlZWsgKGZyb20gMCB0byA2KVxuICAgICAqL1xuICAgIGRheU9mV2VlayhzdGFydEZyb21Nb25kYXk6IGJvb2xlYW4gPSB0cnVlKTogbnVtYmVyIHtcbiAgICAgICAgY29uc3QgZGF5T2ZXZWVrID0gc3RhcnRGcm9tTW9uZGF5XG4gICAgICAgICAgICA/IHRoaXMudG9Mb2NhbE5hdGl2ZURhdGUoKS5nZXREYXkoKSAtIDFcbiAgICAgICAgICAgIDogdGhpcy50b0xvY2FsTmF0aXZlRGF0ZSgpLmdldERheSgpO1xuXG4gICAgICAgIHJldHVybiBkYXlPZldlZWsgPCAwID8gNiA6IGRheU9mV2VlaztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXNzZWQgZGF0ZSBpcyBhZnRlciBjdXJyZW50XG4gICAgICovXG4gICAgZGF5QmVmb3JlKGFub3RoZXI6IFR1aURheSk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdGhpcy5tb250aEJlZm9yZShhbm90aGVyKSB8fFxuICAgICAgICAgICAgKHRoaXMubW9udGhTYW1lKGFub3RoZXIpICYmIHRoaXMuZGF5IDwgYW5vdGhlci5kYXkpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFzc2VkIGRhdGUgaXMgYWZ0ZXIgb3IgZXF1YWxzIHRvIGN1cnJlbnRcbiAgICAgKi9cbiAgICBkYXlTYW1lT3JCZWZvcmUoYW5vdGhlcjogVHVpRGF5KTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLm1vbnRoQmVmb3JlKGFub3RoZXIpIHx8XG4gICAgICAgICAgICAodGhpcy5tb250aFNhbWUoYW5vdGhlcikgJiYgdGhpcy5kYXkgPD0gYW5vdGhlci5kYXkpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFzc2VkIGRhdGUgaXMgdGhlIHNhbWUgYXMgY3VycmVudFxuICAgICAqL1xuICAgIGRheVNhbWUoYW5vdGhlcjogVHVpRGF5KTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vbnRoU2FtZShhbm90aGVyKSAmJiB0aGlzLmRheSA9PT0gYW5vdGhlci5kYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFzc2VkIGRhdGUgaXMgZWl0aGVyIGJlZm9yZSBvciB0aGUgc2FtZSBhcyBjdXJyZW50XG4gICAgICovXG4gICAgZGF5U2FtZU9yQWZ0ZXIoYW5vdGhlcjogVHVpRGF5KTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLm1vbnRoQWZ0ZXIoYW5vdGhlcikgfHxcbiAgICAgICAgICAgICh0aGlzLm1vbnRoU2FtZShhbm90aGVyKSAmJiB0aGlzLmRheSA+PSBhbm90aGVyLmRheSlcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXNzZWQgZGF0ZSBpcyBiZWZvcmUgY3VycmVudFxuICAgICAqL1xuICAgIGRheUFmdGVyKGFub3RoZXI6IFR1aURheSk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdGhpcy5tb250aEFmdGVyKGFub3RoZXIpIHx8XG4gICAgICAgICAgICAodGhpcy5tb250aFNhbWUoYW5vdGhlcikgJiYgdGhpcy5kYXkgPiBhbm90aGVyLmRheSlcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGFtcGluZyBkYXRlIGJldHdlZW4gdHdvIGxpbWl0c1xuICAgICAqXG4gICAgICogQHBhcmFtIG1pblxuICAgICAqIEBwYXJhbSBtYXhcbiAgICAgKiBAcmV0dXJuIGNsYW1wZWQgZGF0ZVxuICAgICAqL1xuICAgIGRheUxpbWl0KG1pbjogVHVpRGF5IHwgbnVsbCwgbWF4OiBUdWlEYXkgfCBudWxsKTogVHVpRGF5IHtcbiAgICAgICAgaWYgKG1pbiAhPT0gbnVsbCAmJiB0aGlzLmRheUJlZm9yZShtaW4pKSB7XG4gICAgICAgICAgICByZXR1cm4gbWluO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1heCAhPT0gbnVsbCAmJiB0aGlzLmRheUFmdGVyKG1heCkpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXg7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBDb25zaWRlciByZW1vdmluZyBgYmFja3dhcmRzYCBvcHRpb25cbiAgICAvKipcbiAgICAgKiBJbW11dGFibHkgYWx0ZXJzIGN1cnJlbnQgZGF5IGJ5IHBhc3NlZCBvZmZzZXRcbiAgICAgKlxuICAgICAqIElmIHJlc3VsdGluZyBtb250aCBoYXMgbW9yZSBkYXlzIHRoYW4gb3JpZ2luYWwgb25lLCBkYXRlIGlzIHJvdW5kZWQgdG8gdGhlIG1heGltdW0gZGF5XG4gICAgICogaW4gdGhlIHJlc3VsdGluZyBtb250aC4gT2Zmc2V0IG9mIGRheXMgd2lsbCBiZSBjYWxjdWxhdGVkIGJhc2VkIG9uIHRoZSByZXN1bHRlZCB5ZWFyIGFuZCBtb250aFxuICAgICAqIHRvIG5vdCBpbnRlcmZlcmUgd2l0aCBwYXJlbnQgY2xhc3NlcyBtZXRob2RzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb2Zmc2V0XG4gICAgICogQHBhcmFtIGJhY2t3YXJkcyBzaGlmdCBkYXRlIGJhY2t3YXJkc1xuICAgICAqIEByZXR1cm4gbmV3IGRhdGUgb2JqZWN0IGFzIGEgcmVzdWx0IG9mIG9mZnNldHRpbmcgY3VycmVudFxuICAgICAqL1xuICAgIGFwcGVuZChcbiAgICAgICAge3llYXIgPSAwLCBtb250aCA9IDAsIGRheSA9IDB9OiBUdWlEYXlMaWtlLFxuICAgICAgICBiYWNrd2FyZHM6IGJvb2xlYW4gPSBmYWxzZSxcbiAgICApOiBUdWlEYXkge1xuICAgICAgICBpZiAoYmFja3dhcmRzKSB7XG4gICAgICAgICAgICB5ZWFyICo9IC0xO1xuICAgICAgICAgICAgbW9udGggKj0gLTE7XG4gICAgICAgICAgICBkYXkgKj0gLTE7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0b3RhbE1vbnRocyA9ICh0aGlzLnllYXIgKyB5ZWFyKSAqIE1PTlRIU19JTl9ZRUFSICsgdGhpcy5tb250aCArIG1vbnRoO1xuICAgICAgICBsZXQgeWVhcnMgPSBNYXRoLmZsb29yKHRvdGFsTW9udGhzIC8gTU9OVEhTX0lOX1lFQVIpO1xuICAgICAgICBsZXQgbW9udGhzID0gdG90YWxNb250aHMgJSBNT05USFNfSU5fWUVBUjtcblxuICAgICAgICBsZXQgZGF5cyA9XG4gICAgICAgICAgICBNYXRoLm1pbihcbiAgICAgICAgICAgICAgICB0aGlzLmRheSxcbiAgICAgICAgICAgICAgICBUdWlNb250aC5nZXRNb250aERheXNDb3VudChtb250aHMsIFR1aVllYXIuaXNMZWFwWWVhcih5ZWFycykpLFxuICAgICAgICAgICAgKSArIGRheTtcblxuICAgICAgICB3aGlsZSAoZGF5cyA+IFR1aU1vbnRoLmdldE1vbnRoRGF5c0NvdW50KG1vbnRocywgVHVpWWVhci5pc0xlYXBZZWFyKHllYXJzKSkpIHtcbiAgICAgICAgICAgIGRheXMgLT0gVHVpTW9udGguZ2V0TW9udGhEYXlzQ291bnQobW9udGhzLCBUdWlZZWFyLmlzTGVhcFllYXIoeWVhcnMpKTtcblxuICAgICAgICAgICAgaWYgKG1vbnRocyA9PT0gVHVpTW9udGhOdW1iZXIuRGVjZW1iZXIpIHtcbiAgICAgICAgICAgICAgICB5ZWFycysrO1xuICAgICAgICAgICAgICAgIG1vbnRocyA9IFR1aU1vbnRoTnVtYmVyLkphbnVhcnk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1vbnRocysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKGRheXMgPCBNSU5fREFZKSB7XG4gICAgICAgICAgICBpZiAobW9udGhzID09PSBUdWlNb250aE51bWJlci5KYW51YXJ5KSB7XG4gICAgICAgICAgICAgICAgeWVhcnMtLTtcbiAgICAgICAgICAgICAgICBtb250aHMgPSBUdWlNb250aE51bWJlci5EZWNlbWJlcjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbW9udGhzLS07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRheXMgKz0gVHVpTW9udGguZ2V0TW9udGhEYXlzQ291bnQobW9udGhzLCBUdWlZZWFyLmlzTGVhcFllYXIoeWVhcnMpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgVHVpRGF5KHllYXJzLCBtb250aHMsIGRheXMpO1xuICAgIH1cblxuICAgIHRvU3RyaW5nKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLmZvcm1hdHRlZERheTtcbiAgICB9XG5cbiAgICB0b0pTT04oKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIGAke3N1cGVyLnRvSlNPTigpfS0ke3RoaXMuZm9ybWF0dGVkRGF5UGFydH1gO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgbmF0aXZlIHtAbGluayBEYXRlfSBiYXNlZCBvbiBsb2NhbCB0aW1lIHpvbmVcbiAgICAgKi9cbiAgICB0b0xvY2FsTmF0aXZlRGF0ZSgpOiBEYXRlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMueWVhciwgdGhpcy5tb250aCwgdGhpcy5kYXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgbmF0aXZlIHtAbGluayBEYXRlfSBiYXNlZCBvbiBVVENcbiAgICAgKi9cbiAgICB0b1V0Y05hdGl2ZURhdGUoKTogRGF0ZSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQyh0aGlzLnllYXIsIHRoaXMubW9udGgsIHRoaXMuZGF5KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB7QGxpbmsgVHVpRGF5fSBmcm9tIG5hdGl2ZSB7QGxpbmsgRGF0ZX0gYmFzZWQgb24gbG9jYWwgdGltZSB6b25lXG4gICAgICovXG4gICAgc3RhdGljIGZyb21Mb2NhbE5hdGl2ZURhdGUoZGF0ZTogRGF0ZSk6IFR1aURheSB7XG4gICAgICAgIHJldHVybiBuZXcgVHVpRGF5KGRhdGUuZ2V0RnVsbFllYXIoKSwgZGF0ZS5nZXRNb250aCgpLCBkYXRlLmdldERhdGUoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB7QGxpbmsgVHVpRGF5fSBmcm9tIG5hdGl2ZSB7QGxpbmsgRGF0ZX0gdXNpbmcgVVRDXG4gICAgICovXG4gICAgc3RhdGljIGZyb21VdGNOYXRpdmVEYXRlKGRhdGU6IERhdGUpOiBUdWlEYXkge1xuICAgICAgICByZXR1cm4gbmV3IFR1aURheShkYXRlLmdldFVUQ0Z1bGxZZWFyKCksIGRhdGUuZ2V0VVRDTW9udGgoKSwgZGF0ZS5nZXRVVENEYXRlKCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIHZhbGlkaXR5IG9mIHllYXIsIG1vbnRoIGFuZCBkYXlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB5ZWFyXG4gICAgICogQHBhcmFtIG1vbnRoXG4gICAgICogQHBhcmFtIGRheVxuICAgICAqIEByZXR1cm4gYm9vbGVhbiB2YWxpZGl0eVxuICAgICAqL1xuICAgIHN0YXRpYyBpc1ZhbGlkRGF5KHllYXI6IG51bWJlciwgbW9udGg6IG51bWJlciwgZGF5OiBudW1iZXIpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIFR1aU1vbnRoLmlzVmFsaWRNb250aCh5ZWFyLCBtb250aCkgJiZcbiAgICAgICAgICAgIE51bWJlci5pc0ludGVnZXIoZGF5KSAmJlxuICAgICAgICAgICAgaW5SYW5nZShcbiAgICAgICAgICAgICAgICBkYXksXG4gICAgICAgICAgICAgICAgTUlOX0RBWSxcbiAgICAgICAgICAgICAgICBUdWlNb250aC5nZXRNb250aERheXNDb3VudChtb250aCwgVHVpWWVhci5pc0xlYXBZZWFyKHllYXIpKSArIDEsXG4gICAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlZCBkYXkgb24gYSBjYWxlbmRhciBncmlkXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbW9udGhcbiAgICAgKiBAcGFyYW0gcm93IHJvdyBpbiBhIGNhbGVuZGFyXG4gICAgICogQHBhcmFtIGNvbCBjb2x1bW4gaW4gYSBjYWxlbmRhclxuICAgICAqIEByZXR1cm4gcmVzdWx0aW5nIGRheSBvbiB0aGVzZSBjb29yZGluYXRlcyAoY291bGQgZXhjZWVkIHBhc3NlZCBtb250aClcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0RGF5RnJvbU1vbnRoUm93Q29sKG1vbnRoOiBUdWlNb250aCwgcm93OiBudW1iZXIsIGNvbDogbnVtYmVyKTogVHVpRGF5IHtcbiAgICAgICAgdHVpQXNzZXJ0LmFzc2VydChOdW1iZXIuaXNJbnRlZ2VyKHJvdykpO1xuICAgICAgICB0dWlBc3NlcnQuYXNzZXJ0KGluUmFuZ2Uocm93LCAwLCA2KSk7XG4gICAgICAgIHR1aUFzc2VydC5hc3NlcnQoTnVtYmVyLmlzSW50ZWdlcihjb2wpKTtcbiAgICAgICAgdHVpQXNzZXJ0LmFzc2VydChpblJhbmdlKGNvbCwgMCwgREFZU19JTl9XRUVLKSk7XG5cbiAgICAgICAgbGV0IGRheSA9IHJvdyAqIERBWVNfSU5fV0VFSyArIGNvbCAtIG1vbnRoLm1vbnRoU3RhcnREYXlzT2Zmc2V0ICsgMTtcblxuICAgICAgICBpZiAoZGF5ID4gbW9udGguZGF5c0NvdW50KSB7XG4gICAgICAgICAgICBkYXkgPSBkYXkgLSBtb250aC5kYXlzQ291bnQ7XG4gICAgICAgICAgICBtb250aCA9IG1vbnRoLmFwcGVuZCh7bW9udGg6IDF9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkYXkgPD0gMCkge1xuICAgICAgICAgICAgbW9udGggPSBtb250aC5hcHBlbmQoe21vbnRoOiAtMX0pO1xuICAgICAgICAgICAgZGF5ID0gbW9udGguZGF5c0NvdW50ICsgZGF5O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBUdWlEYXkobW9udGgueWVhciwgbW9udGgubW9udGgsIGRheSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBkYXkgYmFzZWQgb24gbG9jYWwgdGltZSB6b25lXG4gICAgICovXG4gICAgc3RhdGljIGN1cnJlbnRMb2NhbCgpOiBUdWlEYXkge1xuICAgICAgICBjb25zdCBuYXRpdmVEYXRlID0gbmV3IERhdGUoKTtcbiAgICAgICAgY29uc3QgeWVhciA9IG5hdGl2ZURhdGUuZ2V0RnVsbFllYXIoKTtcbiAgICAgICAgY29uc3QgbW9udGggPSBuYXRpdmVEYXRlLmdldE1vbnRoKCk7XG4gICAgICAgIGNvbnN0IGRheSA9IG5hdGl2ZURhdGUuZ2V0RGF0ZSgpO1xuXG4gICAgICAgIHJldHVybiBuZXcgVHVpRGF5KHllYXIsIG1vbnRoLCBkYXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMge0BsaW5rIFR1aURheX0gbm9ybWFsaXppbmcgeWVhciwgbW9udGggYW5kIGRheS4ge0BsaW5rIE5hTn0gaXMgdHVybmVkIGludG8gbWluaW1hbCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB5ZWFyIGFueSB5ZWFyIHZhbHVlLCBpbmNsdWRpbmcgaW52YWxpZFxuICAgICAqIEBwYXJhbSBtb250aCBhbnkgbW9udGggdmFsdWUsIGluY2x1ZGluZyBpbnZhbGlkIChtb250aHMgc3RhcnQgd2l0aCAwKVxuICAgICAqIEBwYXJhbSBkYXkgYW55IGRheSB2YWx1ZSwgaW5jbHVkaW5nIGludmFsaWRcbiAgICAgKiBAcmV0dXJuIG5vcm1hbGl6ZWQgZGF0ZVxuICAgICAqL1xuICAgIHN0YXRpYyBub3JtYWxpemVPZih5ZWFyOiBudW1iZXIsIG1vbnRoOiBudW1iZXIsIGRheTogbnVtYmVyKTogVHVpRGF5IHtcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZFllYXIgPSBUdWlZZWFyLm5vcm1hbGl6ZVllYXJQYXJ0KHllYXIpO1xuICAgICAgICBjb25zdCBub3JtYWxpemVkTW9udGggPSBUdWlNb250aC5ub3JtYWxpemVNb250aFBhcnQobW9udGgpO1xuICAgICAgICBjb25zdCBub3JtYWxpemVkRGF5ID0gVHVpRGF5Lm5vcm1hbGl6ZURheVBhcnQoXG4gICAgICAgICAgICBkYXksXG4gICAgICAgICAgICBub3JtYWxpemVkTW9udGgsXG4gICAgICAgICAgICBub3JtYWxpemVkWWVhcixcbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4gbmV3IFR1aURheShub3JtYWxpemVkWWVhciwgbm9ybWFsaXplZE1vbnRoLCBub3JtYWxpemVkRGF5KTtcbiAgICB9XG5cbiAgICBzdGF0aWMgbGVuZ3RoQmV0d2Vlbihmcm9tOiBUdWlEYXksIHRvOiBUdWlEYXkpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChcbiAgICAgICAgICAgICh0by50b0xvY2FsTmF0aXZlRGF0ZSgpLmdldFRpbWUoKSAtIGZyb20udG9Mb2NhbE5hdGl2ZURhdGUoKS5nZXRUaW1lKCkpIC9cbiAgICAgICAgICAgICAgICAoMTAwMCAqIDYwICogNjAgKiAyNCksXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogTW92ZSBtb250aCBhbmQgeWVhciByZWxhdGVkIGNvZGUgY29ycmVzcG9uZGluZyBjbGFzc2VzXG4gICAgLyoqXG4gICAgICogUGFyc2luZyBhIHN0cmluZyB3aXRoIGRhdGUgd2l0aCBub3JtYWxpemF0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0geWVhck1vbnRoRGF5U3RyaW5nIGRhdGUgc3RyaW5nIGluIGZvcm1hdCBvZiBERC5NTS5ZeXl5XG4gICAgICogQHJldHVybiBub3JtYWxpemVkIGRhdGVcbiAgICAgKi9cbiAgICBzdGF0aWMgbm9ybWFsaXplUGFyc2UoeWVhck1vbnRoRGF5U3RyaW5nOiBzdHJpbmcpOiBUdWlEYXkge1xuICAgICAgICBjb25zdCBkYXkgPSBwYXJzZUludCh5ZWFyTW9udGhEYXlTdHJpbmcuc2xpY2UoMCwgMiksIDEwKTtcbiAgICAgICAgY29uc3QgbW9udGggPSBwYXJzZUludCh5ZWFyTW9udGhEYXlTdHJpbmcuc2xpY2UoMywgNSksIDEwKSAtIDE7XG4gICAgICAgIGNvbnN0IHllYXIgPSBwYXJzZUludCh5ZWFyTW9udGhEYXlTdHJpbmcuc2xpY2UoNiwgMTApLCAxMCk7XG5cbiAgICAgICAgcmV0dXJuIFR1aURheS5ub3JtYWxpemVPZih5ZWFyLCBtb250aCwgZGF5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXJzaW5nIGEgZGF0ZSBzdHJpbmdpZmllZCBpbiBhIHRvSlNPTiBmb3JtYXRcbiAgICAgKiBAcGFyYW0geWVhck1vbnRoRGF5U3RyaW5nIGRhdGUgc3RyaW5nIGluIGZvcm1hdCBvZiBZWVlZLU1NLUREXG4gICAgICogQHJldHVybiBkYXRlXG4gICAgICogQHRocm93cyBleGNlcHRpb25zIGlmIGFueSBwYXJ0IG9mIHRoZSBkYXRlIGlzIGludmFsaWRcbiAgICAgKi9cbiAgICBzdGF0aWMganNvblBhcnNlKHllYXJNb250aERheVN0cmluZzogc3RyaW5nKTogVHVpRGF5IHtcbiAgICAgICAgY29uc3QgZGF5ID0gcGFyc2VJbnQoeWVhck1vbnRoRGF5U3RyaW5nLnNsaWNlKDgsIDEwKSwgMTApO1xuICAgICAgICBjb25zdCBtb250aCA9IHBhcnNlSW50KHllYXJNb250aERheVN0cmluZy5zbGljZSg1LCA3KSwgMTApIC0gMTtcbiAgICAgICAgY29uc3QgeWVhciA9IHBhcnNlSW50KHllYXJNb250aERheVN0cmluZy5zbGljZSgwLCA0KSwgMTApO1xuXG4gICAgICAgIGlmICghVHVpWWVhci5pc1ZhbGlkWWVhcih5ZWFyKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHllYXI6ICcgKyB5ZWFyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghVHVpTW9udGguaXNWYWxpZE1vbnRoKHllYXIsIG1vbnRoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1vbnRoOiAnICsgbW9udGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgIU51bWJlci5pc0ludGVnZXIoZGF5KSB8fFxuICAgICAgICAgICAgIWluUmFuZ2UoXG4gICAgICAgICAgICAgICAgZGF5LFxuICAgICAgICAgICAgICAgIE1JTl9EQVksXG4gICAgICAgICAgICAgICAgVHVpTW9udGguZ2V0TW9udGhEYXlzQ291bnQobW9udGgsIFR1aVllYXIuaXNMZWFwWWVhcih5ZWFyKSkgKyAxLFxuICAgICAgICAgICAgKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBkYXk6ICcgKyBkYXkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBUdWlEYXkoeWVhciwgbW9udGgsIGRheSk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHN0YXRpYyBub3JtYWxpemVEYXlQYXJ0KGRheTogbnVtYmVyLCBtb250aDogbnVtYmVyLCB5ZWFyOiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICB0dWlBc3NlcnQuYXNzZXJ0KFR1aU1vbnRoLmlzVmFsaWRNb250aCh5ZWFyLCBtb250aCkpO1xuXG4gICAgICAgIGNvbnN0IG1vbnRoRGF5c0NvdW50ID0gVHVpTW9udGguZ2V0TW9udGhEYXlzQ291bnQoXG4gICAgICAgICAgICBtb250aCxcbiAgICAgICAgICAgIFR1aVllYXIuaXNMZWFwWWVhcih5ZWFyKSxcbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4gbm9ybWFsaXplVG9JbnROdW1iZXIoZGF5LCAxLCBtb250aERheXNDb3VudCk7XG4gICAgfVxufVxuIl19