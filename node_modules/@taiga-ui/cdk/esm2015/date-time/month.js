import { tuiAssert } from '@taiga-ui/cdk/classes';
import { padStart } from '@taiga-ui/cdk/utils/format';
import { inRange, normalizeToIntNumber } from '@taiga-ui/cdk/utils/math';
import { DAYS_IN_WEEK, MAX_MONTH, MIN_MONTH, MONTHS_IN_YEAR } from './date-time';
import { TuiYear } from './year';
/**
 * Immutable object consisting of year and month
 */
export class TuiMonth extends TuiYear {
    /**
     * @param year
     * @param month (starting with 0)
     */
    constructor(year, month) {
        super(year);
        this.month = month;
        tuiAssert.assert(TuiMonth.isValidMonth(year, month));
    }
    get formattedMonthPart() {
        return padStart((this.month + 1).toString(), 2, '0');
    }
    /**
     * Formatter month and year
     */
    get formattedMonth() {
        return `${this.formattedMonthPart}.${this.formattedYear}`;
    }
    /**
     * Calculates number of weeks in a month (counting non-full weeks)
     */
    get weeksRowsCount() {
        return Math.ceil((this.monthStartDaysOffset + this.daysCount) / DAYS_IN_WEEK);
    }
    /**
     * Returns days in a month
     */
    get daysCount() {
        return TuiMonth.getMonthDaysCount(this.month, this.isLeapYear);
    }
    /**
     * Computes day of week offset of the beginning of the month
     */
    get monthStartDaysOffset() {
        let result = this.yearStartDaysOffset;
        for (let currentMonth = 0; currentMonth <= this.month - 1; currentMonth++) {
            result += TuiMonth.getMonthDaysCount(currentMonth, this.isLeapYear);
        }
        return result % DAYS_IN_WEEK;
    }
    /**
     * Passed month and year are after current
     */
    monthBefore(another) {
        return (this.yearBefore(another) ||
            (this.yearSame(another) && this.month < another.month));
    }
    /**
     * Passed month and year are after or the same as current
     */
    monthSameOrBefore(another) {
        return (this.yearBefore(another) ||
            (this.yearSame(another) && this.month <= another.month));
    }
    /**
     * Passed month and year are the same as current
     */
    monthSame(another) {
        return this.yearSame(another) && this.month === another.month;
    }
    /**
     * Passed month and year are either before or equal to current
     */
    monthSameOrAfter(another) {
        return (this.yearAfter(another) ||
            (this.yearSame(another) && this.month >= another.month));
    }
    /**
     * Passed month and year are before current
     */
    monthAfter(another) {
        return (this.yearAfter(another) ||
            (this.yearSame(another) && this.month > another.month));
    }
    // TODO: Consider removing `backwards` option
    /**
     * Immutably alters current month and year by passed offset
     *
     * @param offset
     * @param backwards shift date backwards
     * @return new month and year object as a result of offsetting current
     */
    append({ year = 0, month = 0 }, backwards = false) {
        if (backwards) {
            year *= -1;
            month *= -1;
        }
        const totalMonths = (this.year + year) * MONTHS_IN_YEAR + this.month + month;
        return new TuiMonth(Math.floor(totalMonths / MONTHS_IN_YEAR), totalMonths % MONTHS_IN_YEAR);
    }
    toString() {
        return this.formattedMonth;
    }
    toJSON() {
        return `${super.toJSON()}-${this.formattedMonthPart}`;
    }
    /**
     * Returns native {@link Date} based on local time zone
     */
    toLocalNativeDate() {
        return new Date(this.year, this.month);
    }
    /**
     * Returns native {@link Date} based on UTC
     */
    toUtcNativeDate() {
        return new Date(Date.UTC(this.year, this.month));
    }
    /**
     * Tests month and year for validity
     */
    static isValidMonth(year, month) {
        return TuiYear.isValidYear(year) && TuiMonth.isValidMonthPart(month);
    }
    /**
     * Returns number of days in a month
     */
    static getMonthDaysCount(month, isLeapYear) {
        tuiAssert.assert(TuiMonth.isValidMonthPart(month));
        switch (month) {
            case 1 /* February */:
                return isLeapYear ? 29 : 28;
            case 3 /* April */:
            case 5 /* June */:
            case 8 /* September */:
            case 10 /* November */:
                return 30;
            default:
                return 31;
        }
    }
    /**
     * Returns current month and year based on local time zone
     * @nosideeffects
     */
    static currentLocal() {
        const nativeDate = new Date();
        return new TuiMonth(nativeDate.getFullYear(), nativeDate.getMonth());
    }
    /**
     * Returns current month and year based on UTC
     */
    static currentUtc() {
        const nativeDate = new Date();
        return new TuiMonth(nativeDate.getUTCFullYear(), nativeDate.getUTCMonth());
    }
    static lengthBetween(from, to) {
        const absoluteFrom = from.month + from.year * 12;
        const absoluteTo = to.month + to.year * 12;
        return absoluteTo - absoluteFrom;
    }
    /**
     * Normalizes number by clamping it between min and max month
     */
    static normalizeMonthPart(month) {
        return normalizeToIntNumber(month, MIN_MONTH, MAX_MONTH);
    }
    /**
     * Tests month for validity
     */
    static isValidMonthPart(month) {
        return Number.isInteger(month) && inRange(month, MIN_MONTH, MAX_MONTH + 1);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibW9udGguanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AdGFpZ2EtdWkvY2RrL2RhdGUtdGltZS8iLCJzb3VyY2VzIjpbIm1vbnRoLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBQyxTQUFTLEVBQUMsTUFBTSx1QkFBdUIsQ0FBQztBQUdoRCxPQUFPLEVBQUMsUUFBUSxFQUFDLE1BQU0sNEJBQTRCLENBQUM7QUFDcEQsT0FBTyxFQUFDLE9BQU8sRUFBRSxvQkFBb0IsRUFBQyxNQUFNLDBCQUEwQixDQUFDO0FBQ3ZFLE9BQU8sRUFBQyxZQUFZLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxjQUFjLEVBQUMsTUFBTSxhQUFhLENBQUM7QUFDL0UsT0FBTyxFQUFDLE9BQU8sRUFBQyxNQUFNLFFBQVEsQ0FBQztBQUUvQjs7R0FFRztBQUNILE1BQU0sT0FBTyxRQUFTLFNBQVEsT0FBTztJQUNqQzs7O09BR0c7SUFDSCxZQUFZLElBQVksRUFBVyxLQUFhO1FBQzVDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQztRQURtQixVQUFLLEdBQUwsS0FBSyxDQUFRO1FBRTVDLFNBQVMsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLFlBQVksQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQztJQUN6RCxDQUFDO0lBRUQsSUFBSSxrQkFBa0I7UUFDbEIsT0FBTyxRQUFRLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxDQUFDLFFBQVEsRUFBRSxFQUFFLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQztJQUN6RCxDQUFDO0lBRUQ7O09BRUc7SUFDSCxJQUFJLGNBQWM7UUFDZCxPQUFPLEdBQUcsSUFBSSxDQUFDLGtCQUFrQixJQUFJLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQztJQUM5RCxDQUFDO0lBRUQ7O09BRUc7SUFDSCxJQUFJLGNBQWM7UUFDZCxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsb0JB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RSxDQUFDLENBQUM7SUFDekUsQ0FBQztJQUVEOztPQUVHO0lBQ0gsTUFBTSxDQUFDLFVBQVU7UUFDYixNQUFNLFVBQVUsR0FBRyxJQUFJLElBQUksRUFBRSxDQUFDO1FBRTlCLE9BQU8sSUFBSSxRQUFRLENBQUMsVUFBVSxDQUFDLGNBQWMsRUFBRSxFQUFFLFVBQVUsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxDQUFDO0lBQy9FLENBQUM7SUFFRCxNQUFNLENBQUMsYUFBYSxDQUFDLElBQWMsRUFBRSxFQUFZO1FBQzdDLE1BQU0sWUFBWSxHQUFHLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLElBQUksR0FBRyxFQUFFLENBQUM7UUFDakQsTUFBTSxVQUFVLEdBQUcsRUFBRSxDQUFDLEtBQUssR0FBRyxFQUFFLENBQUMsSUFBSSxHQUFHLEVBQUUsQ0FBQztRQUUzQyxPQUFPLFVBQVUsR0FBRyxZQUFZLENBQUM7SUFDckMsQ0FBQztJQUVEOztPQUVHO0lBQ08sTUFBTSxDQUFDLGtCQUFrQixDQUFDLEtBQWE7UUFDN0MsT0FBTyxvQkFBb0IsQ0FBQyxLQUFLLEVBQUUsU0FBUyxFQUFFLFNBQVMsQ0FBQyxDQUFDO0lBQzdELENBQUM7SUFFRDs7T0FFRztJQUNLLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxLQUFhO1FBQ3pDLE9BQU8sTUFBTSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsSUFBSSxPQUFPLENBQUMsS0FBSyxFQUFFLFNBQVMsRUFBRSxTQUFTLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDL0UsQ0FBQztDQUNKIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHt0dWlBc3NlcnR9IGZyb20gJ0B0YWlnYS11aS9jZGsvY2xhc3Nlcyc7XG5pbXBvcnQge1R1aU1vbnRoTnVtYmVyfSBmcm9tICdAdGFpZ2EtdWkvY2RrL2VudW1zJztcbmltcG9ydCB7VHVpTW9udGhMaWtlfSBmcm9tICdAdGFpZ2EtdWkvY2RrL2ludGVyZmFjZXMnO1xuaW1wb3J0IHtwYWRTdGFydH0gZnJvbSAnQHRhaWdhLXVpL2Nkay91dGlscy9mb3JtYXQnO1xuaW1wb3J0IHtpblJhbmdlLCBub3JtYWxpemVUb0ludE51bWJlcn0gZnJvbSAnQHRhaWdhLXVpL2Nkay91dGlscy9tYXRoJztcbmltcG9ydCB7REFZU19JTl9XRUVLLCBNQVhfTU9OVEgsIE1JTl9NT05USCwgTU9OVEhTX0lOX1lFQVJ9IGZyb20gJy4vZGF0ZS10aW1lJztcbmltcG9ydCB7VHVpWWVhcn0gZnJvbSAnLi95ZWFyJztcblxuLyoqXG4gKiBJbW11dGFibGUgb2JqZWN0IGNvbnNpc3Rpbmcgb2YgeWVhciBhbmQgbW9udGhcbiAqL1xuZXhwb3J0IGNsYXNzIFR1aU1vbnRoIGV4dGVuZHMgVHVpWWVhciBpbXBsZW1lbnRzIFR1aU1vbnRoTGlrZSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHllYXJcbiAgICAgKiBAcGFyYW0gbW9udGggKHN0YXJ0aW5nIHdpdGggMClcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih5ZWFyOiBudW1iZXIsIHJlYWRvbmx5IG1vbnRoOiBudW1iZXIpIHtcbiAgICAgICAgc3VwZXIoeWVhcik7XG4gICAgICAgIHR1aUFzc2VydC5hc3NlcnQoVHVpTW9udGguaXNWYWxpZE1vbnRoKHllYXIsIG1vbnRoKSk7XG4gICAgfVxuXG4gICAgZ2V0IGZvcm1hdHRlZE1vbnRoUGFydCgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gcGFkU3RhcnQoKHRoaXMubW9udGggKyAxKS50b1N0cmluZygpLCAyLCAnMCcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZvcm1hdHRlciBtb250aCBhbmQgeWVhclxuICAgICAqL1xuICAgIGdldCBmb3JtYXR0ZWRNb250aCgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5mb3JtYXR0ZWRNb250aFBhcnR9LiR7dGhpcy5mb3JtYXR0ZWRZZWFyfWA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyBudW1iZXIgb2Ygd2Vla3MgaW4gYSBtb250aCAoY291bnRpbmcgbm9uLWZ1bGwgd2Vla3MpXG4gICAgICovXG4gICAgZ2V0IHdlZWtzUm93c0NvdW50KCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiBNYXRoLmNlaWwoKHRoaXMubW9udGhTdGFydERheXNPZmZzZXQgKyB0aGlzLmRheXNDb3VudCkgLyBEQVlTX0lOX1dFRUspO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgZGF5cyBpbiBhIG1vbnRoXG4gICAgICovXG4gICAgZ2V0IGRheXNDb3VudCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gVHVpTW9udGguZ2V0TW9udGhEYXlzQ291bnQodGhpcy5tb250aCwgdGhpcy5pc0xlYXBZZWFyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBkYXkgb2Ygd2VlayBvZmZzZXQgb2YgdGhlIGJlZ2lubmluZyBvZiB0aGUgbW9udGhcbiAgICAgKi9cbiAgICBnZXQgbW9udGhTdGFydERheXNPZmZzZXQoKTogbnVtYmVyIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMueWVhclN0YXJ0RGF5c09mZnNldDtcblxuICAgICAgICBmb3IgKGxldCBjdXJyZW50TW9udGggPSAwOyBjdXJyZW50TW9udGggPD0gdGhpcy5tb250aCAtIDE7IGN1cnJlbnRNb250aCsrKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gVHVpTW9udGguZ2V0TW9udGhEYXlzQ291bnQoY3VycmVudE1vbnRoLCB0aGlzLmlzTGVhcFllYXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdCAlIERBWVNfSU5fV0VFSztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXNzZWQgbW9udGggYW5kIHllYXIgYXJlIGFmdGVyIGN1cnJlbnRcbiAgICAgKi9cbiAgICBtb250aEJlZm9yZShhbm90aGVyOiBUdWlNb250aCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdGhpcy55ZWFyQmVmb3JlKGFub3RoZXIpIHx8XG4gICAgICAgICAgICAodGhpcy55ZWFyU2FtZShhbm90aGVyKSAmJiB0aGlzLm1vbnRoIDwgYW5vdGhlci5tb250aClcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXNzZWQgbW9udGggYW5kIHllYXIgYXJlIGFmdGVyIG9yIHRoZSBzYW1lIGFzIGN1cnJlbnRcbiAgICAgKi9cbiAgICBtb250aFNhbWVPckJlZm9yZShhbm90aGVyOiBUdWlNb250aCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdGhpcy55ZWFyQmVmb3JlKGFub3RoZXIpIHx8XG4gICAgICAgICAgICAodGhpcy55ZWFyU2FtZShhbm90aGVyKSAmJiB0aGlzLm1vbnRoIDw9IGFub3RoZXIubW9udGgpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFzc2VkIG1vbnRoIGFuZCB5ZWFyIGFyZSB0aGUgc2FtZSBhcyBjdXJyZW50XG4gICAgICovXG4gICAgbW9udGhTYW1lKGFub3RoZXI6IFR1aU1vbnRoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLnllYXJTYW1lKGFub3RoZXIpICYmIHRoaXMubW9udGggPT09IGFub3RoZXIubW9udGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFzc2VkIG1vbnRoIGFuZCB5ZWFyIGFyZSBlaXRoZXIgYmVmb3JlIG9yIGVxdWFsIHRvIGN1cnJlbnRcbiAgICAgKi9cbiAgICBtb250aFNhbWVPckFmdGVyKGFub3RoZXI6IFR1aU1vbnRoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLnllYXJBZnRlcihhbm90aGVyKSB8fFxuICAgICAgICAgICAgKHRoaXMueWVhclNhbWUoYW5vdGhlcikgJiYgdGhpcy5tb250aCA+PSBhbm90aGVyLm1vbnRoKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhc3NlZCBtb250aCBhbmQgeWVhciBhcmUgYmVmb3JlIGN1cnJlbnRcbiAgICAgKi9cbiAgICBtb250aEFmdGVyKGFub3RoZXI6IFR1aU1vbnRoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLnllYXJBZnRlcihhbm90aGVyKSB8fFxuICAgICAgICAgICAgKHRoaXMueWVhclNhbWUoYW5vdGhlcikgJiYgdGhpcy5tb250aCA+IGFub3RoZXIubW9udGgpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogQ29uc2lkZXIgcmVtb3ZpbmcgYGJhY2t3YXJkc2Agb3B0aW9uXG4gICAgLyoqXG4gICAgICogSW1tdXRhYmx5IGFsdGVycyBjdXJyZW50IG1vbnRoIGFuZCB5ZWFyIGJ5IHBhc3NlZCBvZmZzZXRcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvZmZzZXRcbiAgICAgKiBAcGFyYW0gYmFja3dhcmRzIHNoaWZ0IGRhdGUgYmFja3dhcmRzXG4gICAgICogQHJldHVybiBuZXcgbW9udGggYW5kIHllYXIgb2JqZWN0IGFzIGEgcmVzdWx0IG9mIG9mZnNldHRpbmcgY3VycmVudFxuICAgICAqL1xuICAgIGFwcGVuZCh7eWVhciA9IDAsIG1vbnRoID0gMH06IFR1aU1vbnRoTGlrZSwgYmFja3dhcmRzOiBib29sZWFuID0gZmFsc2UpOiBUdWlNb250aCB7XG4gICAgICAgIGlmIChiYWNrd2FyZHMpIHtcbiAgICAgICAgICAgIHllYXIgKj0gLTE7XG4gICAgICAgICAgICBtb250aCAqPSAtMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRvdGFsTW9udGhzID0gKHRoaXMueWVhciArIHllYXIpICogTU9OVEhTX0lOX1lFQVIgKyB0aGlzLm1vbnRoICsgbW9udGg7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBUdWlNb250aChcbiAgICAgICAgICAgIE1hdGguZmxvb3IodG90YWxNb250aHMgLyBNT05USFNfSU5fWUVBUiksXG4gICAgICAgICAgICB0b3RhbE1vbnRocyAlIE1PTlRIU19JTl9ZRUFSLFxuICAgICAgICApO1xuICAgIH1cblxuICAgIHRvU3RyaW5nKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLmZvcm1hdHRlZE1vbnRoO1xuICAgIH1cblxuICAgIHRvSlNPTigpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gYCR7c3VwZXIudG9KU09OKCl9LSR7dGhpcy5mb3JtYXR0ZWRNb250aFBhcnR9YDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG5hdGl2ZSB7QGxpbmsgRGF0ZX0gYmFzZWQgb24gbG9jYWwgdGltZSB6b25lXG4gICAgICovXG4gICAgdG9Mb2NhbE5hdGl2ZURhdGUoKTogRGF0ZSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLnllYXIsIHRoaXMubW9udGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgbmF0aXZlIHtAbGluayBEYXRlfSBiYXNlZCBvbiBVVENcbiAgICAgKi9cbiAgICB0b1V0Y05hdGl2ZURhdGUoKTogRGF0ZSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQyh0aGlzLnllYXIsIHRoaXMubW9udGgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUZXN0cyBtb250aCBhbmQgeWVhciBmb3IgdmFsaWRpdHlcbiAgICAgKi9cbiAgICBzdGF0aWMgaXNWYWxpZE1vbnRoKHllYXI6IG51bWJlciwgbW9udGg6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gVHVpWWVhci5pc1ZhbGlkWWVhcih5ZWFyKSAmJiBUdWlNb250aC5pc1ZhbGlkTW9udGhQYXJ0KG1vbnRoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIG51bWJlciBvZiBkYXlzIGluIGEgbW9udGhcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0TW9udGhEYXlzQ291bnQobW9udGg6IG51bWJlciwgaXNMZWFwWWVhcjogYm9vbGVhbik6IG51bWJlciB7XG4gICAgICAgIHR1aUFzc2VydC5hc3NlcnQoVHVpTW9udGguaXNWYWxpZE1vbnRoUGFydChtb250aCkpO1xuXG4gICAgICAgIHN3aXRjaCAobW9udGgpIHtcbiAgICAgICAgICAgIGNhc2UgVHVpTW9udGhOdW1iZXIuRmVicnVhcnk6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzTGVhcFllYXIgPyAyOSA6IDI4O1xuICAgICAgICAgICAgY2FzZSBUdWlNb250aE51bWJlci5BcHJpbDpcbiAgICAgICAgICAgIGNhc2UgVHVpTW9udGhOdW1iZXIuSnVuZTpcbiAgICAgICAgICAgIGNhc2UgVHVpTW9udGhOdW1iZXIuU2VwdGVtYmVyOlxuICAgICAgICAgICAgY2FzZSBUdWlNb250aE51bWJlci5Ob3ZlbWJlcjpcbiAgICAgICAgICAgICAgICByZXR1cm4gMzA7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiAzMTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY3VycmVudCBtb250aCBhbmQgeWVhciBiYXNlZCBvbiBsb2NhbCB0aW1lIHpvbmVcbiAgICAgKiBAbm9zaWRlZWZmZWN0c1xuICAgICAqL1xuICAgIHN0YXRpYyBjdXJyZW50TG9jYWwoKTogVHVpTW9udGgge1xuICAgICAgICBjb25zdCBuYXRpdmVEYXRlID0gbmV3IERhdGUoKTtcblxuICAgICAgICByZXR1cm4gbmV3IFR1aU1vbnRoKG5hdGl2ZURhdGUuZ2V0RnVsbFllYXIoKSwgbmF0aXZlRGF0ZS5nZXRNb250aCgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGN1cnJlbnQgbW9udGggYW5kIHllYXIgYmFzZWQgb24gVVRDXG4gICAgICovXG4gICAgc3RhdGljIGN1cnJlbnRVdGMoKTogVHVpTW9udGgge1xuICAgICAgICBjb25zdCBuYXRpdmVEYXRlID0gbmV3IERhdGUoKTtcblxuICAgICAgICByZXR1cm4gbmV3IFR1aU1vbnRoKG5hdGl2ZURhdGUuZ2V0VVRDRnVsbFllYXIoKSwgbmF0aXZlRGF0ZS5nZXRVVENNb250aCgpKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgbGVuZ3RoQmV0d2Vlbihmcm9tOiBUdWlNb250aCwgdG86IFR1aU1vbnRoKTogbnVtYmVyIHtcbiAgICAgICAgY29uc3QgYWJzb2x1dGVGcm9tID0gZnJvbS5tb250aCArIGZyb20ueWVhciAqIDEyO1xuICAgICAgICBjb25zdCBhYnNvbHV0ZVRvID0gdG8ubW9udGggKyB0by55ZWFyICogMTI7XG5cbiAgICAgICAgcmV0dXJuIGFic29sdXRlVG8gLSBhYnNvbHV0ZUZyb207XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTm9ybWFsaXplcyBudW1iZXIgYnkgY2xhbXBpbmcgaXQgYmV0d2VlbiBtaW4gYW5kIG1heCBtb250aFxuICAgICAqL1xuICAgIHByb3RlY3RlZCBzdGF0aWMgbm9ybWFsaXplTW9udGhQYXJ0KG1vbnRoOiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gbm9ybWFsaXplVG9JbnROdW1iZXIobW9udGgsIE1JTl9NT05USCwgTUFYX01PTlRIKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUZXN0cyBtb250aCBmb3IgdmFsaWRpdHlcbiAgICAgKi9cbiAgICBwcml2YXRlIHN0YXRpYyBpc1ZhbGlkTW9udGhQYXJ0KG1vbnRoOiBudW1iZXIpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIE51bWJlci5pc0ludGVnZXIobW9udGgpICYmIGluUmFuZ2UobW9udGgsIE1JTl9NT05USCwgTUFYX01PTlRIICsgMSk7XG4gICAgfVxufVxuIl19