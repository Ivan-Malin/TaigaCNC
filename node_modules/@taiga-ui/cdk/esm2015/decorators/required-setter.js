import { tuiAssert } from '@taiga-ui/cdk/classes';
/**
 * Decorator for checking input setter values against a custom assertion which
 * takes value passed to input setter and component instance as arguments.
 * It specifically checks for undefined values and prevents calls to the
 * original setter in this case.
 */
export function tuiRequiredSetter(assertion, ...args) {
    return (target, key, { configurable, enumerable, get, set }) => {
        const { name } = target.constructor;
        return {
            configurable,
            enumerable,
            get,
            set(value) {
                if (value !== undefined && assertion) {
                    tuiAssert.assert(assertion.call(this, value), `${String(key)} in ${name} received:`, value, ...args);
                }
                if (!set || value === undefined) {
                    tuiAssert.assert(value !== undefined, errorSet(key, name));
                    return;
                }
                set.call(this, value);
            },
        };
    };
}
function errorSet(key, component) {
    return `Undefined was passed as ${String(key)} to ${component}, setter will not be called`;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVxdWlyZWQtc2V0dGVyLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQHRhaWdhLXVpL2Nkay9kZWNvcmF0b3JzLyIsInNvdXJjZXMiOlsicmVxdWlyZWQtc2V0dGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBQyxTQUFTLEVBQUMsTUFBTSx1QkFBdUIsQ0FBQztBQUdoRDs7Ozs7R0FLRztBQUNILE1BQU0sVUFBVSxpQkFBaUIsQ0FDN0IsU0FBbUMsRUFDbkMsR0FBRyxJQUFXO0lBRWQsT0FBTyxDQUNILE1BQWMsRUFDZCxHQUFHLEVBQ0gsRUFBQyxZQUFZLEVBQUUsVUFBVSxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQXFCLEVBQ3RDLEVBQUU7UUFDcEIsTUFBTSxFQUFDLElBQUksRUFBQyxHQUFHLE1BQU0sQ0FBQyxXQUFXLENBQUM7UUFFbEMsT0FBTztZQUNILFlBQVk7WUFDWixVQUFVO1lBQ1YsR0FBRztZQUNILEdBQUcsQ0FBVSxLQUFXO2dCQUNwQixJQUFJLEtBQUssS0FBSyxTQUFTLElBQUksU0FBUyxFQUFFO29CQUNsQyxTQUFTLENBQUMsTUFBTSxDQUNaLFNBQVMsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQyxFQUMzQixHQUFHLE1BQU0sQ0FBQyxHQUFHLENBQUMsT0FBTyxJQUFJLFlBQVksRUFDckMsS0FBSyxFQUNMLEdBQUcsSUFBSSxDQUNWLENBQUM7aUJBQ0w7Z0JBRUQsSUFBSSxDQUFDLEdBQUcsSUFBSSxLQUFLLEtBQUssU0FBUyxFQUFFO29CQUM3QixTQUFTLENBQUMsTUFBTSxDQUFDLEtBQUssS0FBSyxTQUFTLEVBQUUsUUFBUSxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDO29CQUUzRCxPQUFPO2lCQUNWO2dCQUVELEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQyxDQUFDO1lBQzFCLENBQUM7U0FDSixDQUFDO0lBQ04sQ0FBQyxDQUFDO0FBQ04sQ0FBQztBQUVELFNBQVMsUUFBUSxDQUFDLEdBQW9CLEVBQUUsU0FBaUI7SUFDckQsT0FBTywyQkFBMkIsTUFBTSxDQUNwQyxHQUFHLENBQ04sT0FBTyxTQUFTLDZCQUE2QixDQUFDO0FBQ25ELENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge3R1aUFzc2VydH0gZnJvbSAnQHRhaWdhLXVpL2Nkay9jbGFzc2VzJztcbmltcG9ydCB7VHVpQm9vbGVhbkhhbmRsZXJ9IGZyb20gJ0B0YWlnYS11aS9jZGsvdHlwZXMnO1xuXG4vKipcbiAqIERlY29yYXRvciBmb3IgY2hlY2tpbmcgaW5wdXQgc2V0dGVyIHZhbHVlcyBhZ2FpbnN0IGEgY3VzdG9tIGFzc2VydGlvbiB3aGljaFxuICogdGFrZXMgdmFsdWUgcGFzc2VkIHRvIGlucHV0IHNldHRlciBhbmQgY29tcG9uZW50IGluc3RhbmNlIGFzIGFyZ3VtZW50cy5cbiAqIEl0IHNwZWNpZmljYWxseSBjaGVja3MgZm9yIHVuZGVmaW5lZCB2YWx1ZXMgYW5kIHByZXZlbnRzIGNhbGxzIHRvIHRoZVxuICogb3JpZ2luYWwgc2V0dGVyIGluIHRoaXMgY2FzZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHR1aVJlcXVpcmVkU2V0dGVyPFQgZXh0ZW5kcyBvYmplY3QsIEsgZXh0ZW5kcyBrZXlvZiBUPihcbiAgICBhc3NlcnRpb24/OiBUdWlCb29sZWFuSGFuZGxlcjxUW0tdPixcbiAgICAuLi5hcmdzOiBhbnlbXVxuKTogTWV0aG9kRGVjb3JhdG9yIHtcbiAgICByZXR1cm4gKFxuICAgICAgICB0YXJnZXQ6IE9iamVjdCxcbiAgICAgICAga2V5LFxuICAgICAgICB7Y29uZmlndXJhYmxlLCBlbnVtZXJhYmxlLCBnZXQsIHNldH06IFByb3BlcnR5RGVzY3JpcHRvcixcbiAgICApOiBQcm9wZXJ0eURlc2NyaXB0b3IgPT4ge1xuICAgICAgICBjb25zdCB7bmFtZX0gPSB0YXJnZXQuY29uc3RydWN0b3I7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZSxcbiAgICAgICAgICAgIGVudW1lcmFibGUsXG4gICAgICAgICAgICBnZXQsXG4gICAgICAgICAgICBzZXQodGhpczogVCwgdmFsdWU6IFRbS10pIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiBhc3NlcnRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdHVpQXNzZXJ0LmFzc2VydChcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydGlvbi5jYWxsKHRoaXMsIHZhbHVlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGAke1N0cmluZyhrZXkpfSBpbiAke25hbWV9IHJlY2VpdmVkOmAsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmFyZ3MsXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFzZXQgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0dWlBc3NlcnQuYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQsIGVycm9yU2V0KGtleSwgbmFtZSkpO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzZXQuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIGVycm9yU2V0KGtleTogc3RyaW5nIHwgc3ltYm9sLCBjb21wb25lbnQ6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGBVbmRlZmluZWQgd2FzIHBhc3NlZCBhcyAke1N0cmluZyhcbiAgICAgICAga2V5LFxuICAgICl9IHRvICR7Y29tcG9uZW50fSwgc2V0dGVyIHdpbGwgbm90IGJlIGNhbGxlZGA7XG59XG4iXX0=