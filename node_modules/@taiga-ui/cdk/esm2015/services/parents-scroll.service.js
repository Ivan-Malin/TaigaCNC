import { __decorate, __param } from "tslib";
import { ElementRef, Inject, Injectable } from '@angular/core';
import { WINDOW } from '@ng-web-apis/common';
import { typedFromEvent } from '@taiga-ui/cdk/observables';
import { defer, merge, Observable } from 'rxjs';
/**
 * Service that subscribes to scroll events of all parent elements
 */
// Ambient type cannot be used without dynamic https://github.com/angular/angular/issues/23395
// @dynamic
let TuiParentsScrollService = class TuiParentsScrollService extends Observable {
    constructor({ nativeElement }, windowRef) {
        super(subscriber => this.callback$.subscribe(subscriber));
        this.callback$ = defer(() => {
            const eventTargets = [windowRef, nativeElement];
            while (nativeElement.parentElement) {
                nativeElement = nativeElement.parentElement;
                eventTargets.push(nativeElement);
            }
            return merge(...eventTargets.map(element => typedFromEvent(element, 'scroll')));
        });
    }
};
TuiParentsScrollService.ctorParameters = () => [
    { type: ElementRef, decorators: [{ type: Inject, args: [ElementRef,] }] },
    { type: Window, decorators: [{ type: Inject, args: [WINDOW,] }] }
];
TuiParentsScrollService = __decorate([
    Injectable(),
    __param(0, Inject(ElementRef)),
    __param(1, Inject(WINDOW))
], TuiParentsScrollService);
export { TuiParentsScrollService };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFyZW50cy1zY3JvbGwuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0B0YWlnYS11aS9jZGsvc2VydmljZXMvIiwic291cmNlcyI6WyJwYXJlbnRzLXNjcm9sbC5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQUMsVUFBVSxFQUFFLE1BQU0sRUFBRSxVQUFVLEVBQUMsTUFBTSxlQUFlLENBQUM7QUFDN0QsT0FBTyxFQUFDLE1BQU0sRUFBQyxNQUFNLHFCQUFxQixDQUFDO0FBQzNDLE9BQU8sRUFBQyxjQUFjLEVBQUMsTUFBTSwyQkFBMkIsQ0FBQztBQUN6RCxPQUFPLEVBQUMsS0FBSyxFQUFFLEtBQUssRUFBRSxVQUFVLEVBQUMsTUFBTSxNQUFNLENBQUM7QUFFOUM7O0dBRUc7QUFDSCw4RkFBOEY7QUFDOUYsV0FBVztBQUVYLElBQWEsdUJBQXVCLEdBQXBDLE1BQWEsdUJBQXdCLFNBQVEsVUFBaUI7SUFHMUQsWUFDd0IsRUFBQyxhQUFhLEVBQXNCLEVBQ3hDLFNBQWlCO1FBRWpDLEtBQUssQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsU0FBUyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUM7UUFFMUQsSUFBSSxDQUFDLFNBQVMsR0FBRyxLQUFLLENBQUMsR0FBRyxFQUFFO1lBQ3hCLE1BQU0sWUFBWSxHQUE0QixDQUFDLFNBQVMsRUFBRSxhQUFhLENBQUMsQ0FBQztZQUV6RSxPQUFPLGFBQWEsQ0FBQyxhQUFhLEVBQUU7Z0JBQ2hDLGFBQWEsR0FBRyxhQUFhLENBQUMsYUFBYSxDQUFDO2dCQUM1QyxZQUFZLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDO2FBQ3BDO1lBRUQsT0FBTyxLQUFLLENBQ1IsR0FBRyxZQUFZLENBQUMsR0FBRyxDQUFvQixPQUFPLENBQUMsRUFBRSxDQUM3QyxjQUFjLENBQUMsT0FBTyxFQUFFLFFBQVEsQ0FBQyxDQUNwQyxDQUNKLENBQUM7UUFDTixDQUFDLENBQUMsQ0FBQztJQUNQLENBQUM7Q0FDSixDQUFBOztZQXBCNEMsVUFBVSx1QkFBOUMsTUFBTSxTQUFDLFVBQVU7WUFDUyxNQUFNLHVCQUFoQyxNQUFNLFNBQUMsTUFBTTs7QUFMVCx1QkFBdUI7SUFEbkMsVUFBVSxFQUFFO0lBS0osV0FBQSxNQUFNLENBQUMsVUFBVSxDQUFDLENBQUE7SUFDbEIsV0FBQSxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUE7R0FMVix1QkFBdUIsQ0F3Qm5DO1NBeEJZLHVCQUF1QiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7RWxlbWVudFJlZiwgSW5qZWN0LCBJbmplY3RhYmxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7V0lORE9XfSBmcm9tICdAbmctd2ViLWFwaXMvY29tbW9uJztcbmltcG9ydCB7dHlwZWRGcm9tRXZlbnR9IGZyb20gJ0B0YWlnYS11aS9jZGsvb2JzZXJ2YWJsZXMnO1xuaW1wb3J0IHtkZWZlciwgbWVyZ2UsIE9ic2VydmFibGV9IGZyb20gJ3J4anMnO1xuXG4vKipcbiAqIFNlcnZpY2UgdGhhdCBzdWJzY3JpYmVzIHRvIHNjcm9sbCBldmVudHMgb2YgYWxsIHBhcmVudCBlbGVtZW50c1xuICovXG4vLyBBbWJpZW50IHR5cGUgY2Fubm90IGJlIHVzZWQgd2l0aG91dCBkeW5hbWljIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvaXNzdWVzLzIzMzk1XG4vLyBAZHluYW1pY1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFR1aVBhcmVudHNTY3JvbGxTZXJ2aWNlIGV4dGVuZHMgT2JzZXJ2YWJsZTxFdmVudD4ge1xuICAgIHByaXZhdGUgcmVhZG9ubHkgY2FsbGJhY2skOiBPYnNlcnZhYmxlPEV2ZW50PjtcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBASW5qZWN0KEVsZW1lbnRSZWYpIHtuYXRpdmVFbGVtZW50fTogRWxlbWVudFJlZjxFbGVtZW50PixcbiAgICAgICAgQEluamVjdChXSU5ET1cpIHdpbmRvd1JlZjogV2luZG93LFxuICAgICkge1xuICAgICAgICBzdXBlcihzdWJzY3JpYmVyID0+IHRoaXMuY2FsbGJhY2skLnN1YnNjcmliZShzdWJzY3JpYmVyKSk7XG5cbiAgICAgICAgdGhpcy5jYWxsYmFjayQgPSBkZWZlcigoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBldmVudFRhcmdldHM6IEFycmF5PEVsZW1lbnQgfCBXaW5kb3c+ID0gW3dpbmRvd1JlZiwgbmF0aXZlRWxlbWVudF07XG5cbiAgICAgICAgICAgIHdoaWxlIChuYXRpdmVFbGVtZW50LnBhcmVudEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBuYXRpdmVFbGVtZW50ID0gbmF0aXZlRWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICAgICAgICAgICAgICAgIGV2ZW50VGFyZ2V0cy5wdXNoKG5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbWVyZ2U8RXZlbnQ+KFxuICAgICAgICAgICAgICAgIC4uLmV2ZW50VGFyZ2V0cy5tYXA8T2JzZXJ2YWJsZTxFdmVudD4+KGVsZW1lbnQgPT5cbiAgICAgICAgICAgICAgICAgICAgdHlwZWRGcm9tRXZlbnQoZWxlbWVudCwgJ3Njcm9sbCcpLFxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICB9XG59XG4iXX0=