import { __extends } from "tslib";
import { tuiAssert } from '@taiga-ui/cdk/classes';
import { padStart } from '@taiga-ui/cdk/utils/format';
import { inRange, normalizeToIntNumber } from '@taiga-ui/cdk/utils/math';
import { DAYS_IN_WEEK, MAX_MONTH, MIN_MONTH, MONTHS_IN_YEAR } from './date-time';
import { TuiYear } from './year';
/**
 * Immutable object consisting of year and month
 */
var TuiMonth = /** @class */ (function (_super) {
    __extends(TuiMonth, _super);
    /**
     * @param year
     * @param month (starting with 0)
     */
    function TuiMonth(year, month) {
        var _this = _super.call(this, year) || this;
        _this.month = month;
        tuiAssert.assert(TuiMonth.isValidMonth(year, month));
        return _this;
    }
    Object.defineProperty(TuiMonth.prototype, "formattedMonthPart", {
        get: function () {
            return padStart((this.month + 1).toString(), 2, '0');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TuiMonth.prototype, "formattedMonth", {
        /**
         * Formatter month and year
         */
        get: function () {
            return this.formattedMonthPart + "." + this.formattedYear;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TuiMonth.prototype, "weeksRowsCount", {
        /**
         * Calculates number of weeks in a month (counting non-full weeks)
         */
        get: function () {
            return Math.ceil((this.monthStartDaysOffset + this.daysCount) / DAYS_IN_WEEK);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TuiMonth.prototype, "daysCount", {
        /**
         * Returns days in a month
         */
        get: function () {
            return TuiMonth.getMonthDaysCount(this.month, this.isLeapYear);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TuiMonth.prototype, "monthStartDaysOffset", {
        /**
         * Computes day of week offset of the beginning of the month
         */
        get: function () {
            var result = this.yearStartDaysOffset;
            for (var currentMonth = 0; currentMonth <= this.month - 1; currentMonth++) {
                result += TuiMonth.getMonthDaysCount(currentMonth, this.isLeapYear);
            }
            return result % DAYS_IN_WEEK;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Passed month and year are after current
     */
    TuiMonth.prototype.monthBefore = function (another) {
        return (this.yearBefore(another) ||
            (this.yearSame(another) && this.month < another.month));
    };
    /**
     * Passed month and year are after or the same as current
     */
    TuiMonth.prototype.monthSameOrBefore = function (another) {
        return (this.yearBefore(another) ||
            (this.yearSame(another) && this.month <= another.month));
    };
    /**
     * Passed month and year are the same as current
     */
    TuiMonth.prototype.monthSame = function (another) {
        return this.yearSame(another) && this.month === another.month;
    };
    /**
     * Passed month and year are either before or equal to current
     */
    TuiMonth.prototype.monthSameOrAfter = function (another) {
        return (this.yearAfter(another) ||
            (this.yearSame(another) && this.month >= another.month));
    };
    /**
     * Passed month and year are before current
     */
    TuiMonth.prototype.monthAfter = function (another) {
        return (this.yearAfter(another) ||
            (this.yearSame(another) && this.month > another.month));
    };
    // TODO: Consider removing `backwards` option
    /**
     * Immutably alters current month and year by passed offset
     *
     * @param offset
     * @param backwards shift date backwards
     * @return new month and year object as a result of offsetting current
     */
    TuiMonth.prototype.append = function (_a, backwards) {
        var _b = _a.year, year = _b === void 0 ? 0 : _b, _c = _a.month, month = _c === void 0 ? 0 : _c;
        if (backwards === void 0) { backwards = false; }
        if (backwards) {
            year *= -1;
            month *= -1;
        }
        var totalMonths = (this.year + year) * MONTHS_IN_YEAR + this.month + month;
        return new TuiMonth(Math.floor(totalMonths / MONTHS_IN_YEAR), totalMonths % MONTHS_IN_YEAR);
    };
    TuiMonth.prototype.toString = function () {
        return this.formattedMonth;
    };
    TuiMonth.prototype.toJSON = function () {
        return _super.prototype.toJSON.call(this) + "-" + this.formattedMonthPart;
    };
    /**
     * Returns native {@link Date} based on local time zone
     */
    TuiMonth.prototype.toLocalNativeDate = function () {
        return new Date(this.year, this.month);
    };
    /**
     * Returns native {@link Date} based on UTC
     */
    TuiMonth.prototype.toUtcNativeDate = function () {
        return new Date(Date.UTC(this.year, this.month));
    };
    /**
     * Tests month and year for validity
     */
    TuiMonth.isValidMonth = function (year, month) {
        return TuiYear.isValidYear(year) && TuiMonth.isValidMonthPart(month);
    };
    /**
     * Returns number of days in a month
     */
    TuiMonth.getMonthDaysCount = function (month, isLeapYear) {
        tuiAssert.assert(TuiMonth.isValidMonthPart(month));
        switch (month) {
            case 1 /* February */:
                return isLeapYear ? 29 : 28;
            case 3 /* April */:
            case 5 /* June */:
            case 8 /* September */:
            case 10 /* November */:
                return 30;
            default:
                return 31;
        }
    };
    /**
     * Returns current month and year based on local time zone
     * @nosideeffects
     */
    TuiMonth.currentLocal = function () {
        var nativeDate = new Date();
        return new TuiMonth(nativeDate.getFullYear(), nativeDate.getMonth());
    };
    /**
     * Returns current month and year based on UTC
     */
    TuiMonth.currentUtc = function () {
        var nativeDate = new Date();
        return new TuiMonth(nativeDate.getUTCFullYear(), nativeDate.getUTCMonth());
    };
    TuiMonth.lengthBetween = function (from, to) {
        var absoluteFrom = from.month + from.year * 12;
        var absoluteTo = to.month + to.year * 12;
        return absoluteTo - absoluteFrom;
    };
    /**
     * Normalizes number by clamping it between min and max month
     */
    TuiMonth.normalizeMonthPart = function (month) {
        return normalizeToIntNumber(month, MIN_MONTH, MAX_MONTH);
    };
    /**
     * Tests month for validity
     */
    TuiMonth.isValidMonthPart = function (month) {
        return Number.isInteger(month) && inRange(month, MIN_MONTH, MAX_MONTH + 1);
    };
    return TuiMonth;
}(TuiYear));
export { TuiMonth };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibW9udGguanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AdGFpZ2EtdWkvY2RrL2RhdGUtdGltZS8iLCJzb3VyY2VzIjpbIm1vbnRoLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQUMsU0FBUyxFQUFDLE1BQU0sdUJBQXVCLENBQUM7QUFHaEQsT0FBTyxFQUFDLFFBQVEsRUFBQyxNQUFNLDRCQUE0QixDQUFDO0FBQ3BELE9BQU8sRUFBQyxPQUFPLEVBQUUsb0JBQW9CLEVBQUMsTUFBTSwwQkFBMEIsQ0FBQztBQUN2RSxPQUFPLEVBQUMsWUFBWSxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsY0FBYyxFQUFDLE1BQU0sYUFBYSxDQUFDO0FBQy9FLE9BQU8sRUFBQyxPQUFPLEVBQUMsTUFBTSxRQUFRLENBQUM7QUFFL0I7O0dBRUc7QUFDSDtJQUE4Qiw0QkFBTztJQUNqQzs7O09BR0c7SUFDSCxrQkFBWSxJQUFZLEVBQVcsS0FBYTtRQUFoRCxZQUNJLGtCQUFNLElBQUksQ0FBQyxTQUVkO1FBSGtDLFdBQUssR0FBTCxLQUFLLENBQVE7UUFFNUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsWUFBWSxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDOztJQUN6RCxDQUFDO0lBRUQsc0JBQUksd0NBQWtCO2FBQXRCO1lBQ0ksT0FBTyxRQUFRLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxDQUFDLFFBQVEsRUFBRSxFQUFFLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQztRQUN6RCxDQUFDOzs7T0FBQTtJQUtELHNCQUFJLG9DQUFjO1FBSGxCOztXQUVHO2FBQ0g7WUFDSSxPQUFVLElBQUksQ0FBQyxrQkFBa0IsU0FBSSxJQUFJLENBQUMsYUFBZSxDQUFDO1FBQzlELENBQUM7OztPQUFBO0lBS0Qsc0JBQUksb0NBQWM7UUFIbEI7O1dBRUc7YUFDSDtZQUNJLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxD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R0FBbkI7UUFDSSxJQUFNLFVBQVUsR0FBRyxJQUFJLElBQUksRUFBRSxDQUFDO1FBRTlCLE9BQU8sSUFBSSxRQUFRLENBQUMsVUFBVSxDQUFDLFdBQVcsRUFBRSxFQUFFLFVBQVUsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDO0lBQ3pFLENBQUM7SUFFRDs7T0FFRztJQUNJLG1CQUFVLEdBQWpCO1FBQ0ksSUFBTSxVQUFVLEdBQUcsSUFBSSxJQUFJLEVBQUUsQ0FBQztRQUU5QixPQUFPLElBQUksUUFBUSxDQUFDLFVBQVUsQ0FBQyxjQUFjLEVBQUUsRUFBRSxVQUFVLENBQUMsV0FBVyxFQUFFLENBQUMsQ0FBQztJQUMvRSxDQUFDO0lBRU0sc0JBQWEsR0FBcEIsVUFBcUIsSUFBYyxFQUFFLEVBQVk7UUFDN0MsSUFBTSxZQUFZLEdBQUcsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsSUFBSSxHQUFHLEVBQUUsQ0FBQztRQUNqRCxJQUFNLFVBQVUsR0FBRyxFQUFFLENBQUMsS0FBSyxHQUFHLEVBQUUsQ0FBQyxJQUFJLEdBQUcsRUFBRSxDQUFDO1FBRTNDLE9BQU8sVUFBVSxHQUFHLFlBQVksQ0FBQztJQUNyQyxDQUFDO0lBRUQ7O09BRUc7SUFDYywyQkFBa0IsR0FBbkMsVUFBb0MsS0FBYTtRQUM3QyxPQUFPLG9CQUFvQixDQUFDLEtBQUssRUFBRSxTQUFTLEVBQUUsU0FBUyxDQUFDLENBQUM7SUFDN0QsQ0FBQztJQUVEOztPQUVHO0lBQ1kseUJBQWdCLEdBQS9CLFVBQWdDLEtBQWE7UUFDekMsT0FBTyxNQUFNLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxJQUFJLE9BQU8sQ0FBQyxLQUFLLEVBQUUsU0FBUyxFQUFFLFNBQVMsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUMvRSxDQUFDO0lBQ0wsZUFBQztBQUFELENBQUMsQUE1TUQsQ0FBOEIsT0FBTyxHQTRNcEMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge3R1aUFzc2VydH0gZnJvbSAnQHRhaWdhLXVpL2Nkay9jbGFzc2VzJztcbmltcG9ydCB7VHVpTW9udGhOdW1iZXJ9IGZyb20gJ0B0YWlnYS11aS9jZGsvZW51bXMnO1xuaW1wb3J0IHtUdWlNb250aExpa2V9IGZyb20gJ0B0YWlnYS11aS9jZGsvaW50ZXJmYWNlcyc7XG5pbXBvcnQge3BhZFN0YXJ0fSBmcm9tICdAdGFpZ2EtdWkvY2RrL3V0aWxzL2Zvcm1hdCc7XG5pbXBvcnQge2luUmFuZ2UsIG5vcm1hbGl6ZVRvSW50TnVtYmVyfSBmcm9tICdAdGFpZ2EtdWkvY2RrL3V0aWxzL21hdGgnO1xuaW1wb3J0IHtEQVlTX0lOX1dFRUssIE1BWF9NT05USCwgTUlOX01PTlRILCBNT05USFNfSU5fWUVBUn0gZnJvbSAnLi9kYXRlLXRpbWUnO1xuaW1wb3J0IHtUdWlZZWFyfSBmcm9tICcuL3llYXInO1xuXG4vKipcbiAqIEltbXV0YWJsZSBvYmplY3QgY29uc2lzdGluZyBvZiB5ZWFyIGFuZCBtb250aFxuICovXG5leHBvcnQgY2xhc3MgVHVpTW9udGggZXh0ZW5kcyBUdWlZZWFyIGltcGxlbWVudHMgVHVpTW9udGhMaWtlIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geWVhclxuICAgICAqIEBwYXJhbSBtb250aCAoc3RhcnRpbmcgd2l0aCAwKVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHllYXI6IG51bWJlciwgcmVhZG9ubHkgbW9udGg6IG51bWJlcikge1xuICAgICAgICBzdXBlcih5ZWFyKTtcbiAgICAgICAgdHVpQXNzZXJ0LmFzc2VydChUdWlNb250aC5pc1ZhbGlkTW9udGgoeWVhciwgbW9udGgpKTtcbiAgICB9XG5cbiAgICBnZXQgZm9ybWF0dGVkTW9udGhQYXJ0KCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiBwYWRTdGFydCgodGhpcy5tb250aCArIDEpLnRvU3RyaW5nKCksIDIsICcwJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRm9ybWF0dGVyIG1vbnRoIGFuZCB5ZWFyXG4gICAgICovXG4gICAgZ2V0IGZvcm1hdHRlZE1vbnRoKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmZvcm1hdHRlZE1vbnRoUGFydH0uJHt0aGlzLmZvcm1hdHRlZFllYXJ9YDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIG51bWJlciBvZiB3ZWVrcyBpbiBhIG1vbnRoIChjb3VudGluZyBub24tZnVsbCB3ZWVrcylcbiAgICAgKi9cbiAgICBnZXQgd2Vla3NSb3dzQ291bnQoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIE1hdGguY2VpbCgodGhpcy5tb250aFN0YXJ0RGF5c09mZnNldCArIHRoaXMuZGF5c0NvdW50KSAvIERBWVNfSU5fV0VFSyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBkYXlzIGluIGEgbW9udGhcbiAgICAgKi9cbiAgICBnZXQgZGF5c0NvdW50KCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiBUdWlNb250aC5nZXRNb250aERheXNDb3VudCh0aGlzLm1vbnRoLCB0aGlzLmlzTGVhcFllYXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIGRheSBvZiB3ZWVrIG9mZnNldCBvZiB0aGUgYmVnaW5uaW5nIG9mIHRoZSBtb250aFxuICAgICAqL1xuICAgIGdldCBtb250aFN0YXJ0RGF5c09mZnNldCgpOiBudW1iZXIge1xuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy55ZWFyU3RhcnREYXlzT2Zmc2V0O1xuXG4gICAgICAgIGZvciAobGV0IGN1cnJlbnRNb250aCA9IDA7IGN1cnJlbnRNb250aCA8PSB0aGlzLm1vbnRoIC0gMTsgY3VycmVudE1vbnRoKyspIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBUdWlNb250aC5nZXRNb250aERheXNDb3VudChjdXJyZW50TW9udGgsIHRoaXMuaXNMZWFwWWVhcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0ICUgREFZU19JTl9XRUVLO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhc3NlZCBtb250aCBhbmQgeWVhciBhcmUgYWZ0ZXIgY3VycmVudFxuICAgICAqL1xuICAgIG1vbnRoQmVmb3JlKGFub3RoZXI6IFR1aU1vbnRoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLnllYXJCZWZvcmUoYW5vdGhlcikgfHxcbiAgICAgICAgICAgICh0aGlzLnllYXJTYW1lKGFub3RoZXIpICYmIHRoaXMubW9udGggPCBhbm90aGVyLm1vbnRoKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhc3NlZCBtb250aCBhbmQgeWVhciBhcmUgYWZ0ZXIgb3IgdGhlIHNhbWUgYXMgY3VycmVudFxuICAgICAqL1xuICAgIG1vbnRoU2FtZU9yQmVmb3JlKGFub3RoZXI6IFR1aU1vbnRoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLnllYXJCZWZvcmUoYW5vdGhlcikgfHxcbiAgICAgICAgICAgICh0aGlzLnllYXJTYW1lKGFub3RoZXIpICYmIHRoaXMubW9udGggPD0gYW5vdGhlci5tb250aClcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXNzZWQgbW9udGggYW5kIHllYXIgYXJlIHRoZSBzYW1lIGFzIGN1cnJlbnRcbiAgICAgKi9cbiAgICBtb250aFNhbWUoYW5vdGhlcjogVHVpTW9udGgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueWVhclNhbWUoYW5vdGhlcikgJiYgdGhpcy5tb250aCA9PT0gYW5vdGhlci5tb250aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXNzZWQgbW9udGggYW5kIHllYXIgYXJlIGVpdGhlciBiZWZvcmUgb3IgZXF1YWwgdG8gY3VycmVudFxuICAgICAqL1xuICAgIG1vbnRoU2FtZU9yQWZ0ZXIoYW5vdGhlcjogVHVpTW9udGgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMueWVhckFmdGVyKGFub3RoZXIpIHx8XG4gICAgICAgICAgICAodGhpcy55ZWFyU2FtZShhbm90aGVyKSAmJiB0aGlzLm1vbnRoID49IGFub3RoZXIubW9udGgpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFzc2VkIG1vbnRoIGFuZCB5ZWFyIGFyZSBiZWZvcmUgY3VycmVudFxuICAgICAqL1xuICAgIG1vbnRoQWZ0ZXIoYW5vdGhlcjogVHVpTW9udGgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMueWVhckFmdGVyKGFub3RoZXIpIHx8XG4gICAgICAgICAgICAodGhpcy55ZWFyU2FtZShhbm90aGVyKSAmJiB0aGlzLm1vbnRoID4gYW5vdGhlci5tb250aClcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBDb25zaWRlciByZW1vdmluZyBgYmFja3dhcmRzYCBvcHRpb25cbiAgICAvKipcbiAgICAgKiBJbW11dGFibHkgYWx0ZXJzIGN1cnJlbnQgbW9udGggYW5kIHllYXIgYnkgcGFzc2VkIG9mZnNldFxuICAgICAqXG4gICAgICogQHBhcmFtIG9mZnNldFxuICAgICAqIEBwYXJhbSBiYWNrd2FyZHMgc2hpZnQgZGF0ZSBiYWNrd2FyZHNcbiAgICAgKiBAcmV0dXJuIG5ldyBtb250aCBhbmQgeWVhciBvYmplY3QgYXMgYSByZXN1bHQgb2Ygb2Zmc2V0dGluZyBjdXJyZW50XG4gICAgICovXG4gICAgYXBwZW5kKHt5ZWFyID0gMCwgbW9udGggPSAwfTogVHVpTW9udGhMaWtlLCBiYWNrd2FyZHM6IGJvb2xlYW4gPSBmYWxzZSk6IFR1aU1vbnRoIHtcbiAgICAgICAgaWYgKGJhY2t3YXJkcykge1xuICAgICAgICAgICAgeWVhciAqPSAtMTtcbiAgICAgICAgICAgIG1vbnRoICo9IC0xO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdG90YWxNb250aHMgPSAodGhpcy55ZWFyICsgeWVhcikgKiBNT05USFNfSU5fWUVBUiArIHRoaXMubW9udGggKyBtb250aDtcblxuICAgICAgICByZXR1cm4gbmV3IFR1aU1vbnRoKFxuICAgICAgICAgICAgTWF0aC5mbG9vcih0b3RhbE1vbnRocyAvIE1PTlRIU19JTl9ZRUFSKSxcbiAgICAgICAgICAgIHRvdGFsTW9udGhzICUgTU9OVEhTX0lOX1lFQVIsXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgdG9TdHJpbmcoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0dGVkTW9udGg7XG4gICAgfVxuXG4gICAgdG9KU09OKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiBgJHtzdXBlci50b0pTT04oKX0tJHt0aGlzLmZvcm1hdHRlZE1vbnRoUGFydH1gO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgbmF0aXZlIHtAbGluayBEYXRlfSBiYXNlZCBvbiBsb2NhbCB0aW1lIHpvbmVcbiAgICAgKi9cbiAgICB0b0xvY2FsTmF0aXZlRGF0ZSgpOiBEYXRlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMueWVhciwgdGhpcy5tb250aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBuYXRpdmUge0BsaW5rIERhdGV9IGJhc2VkIG9uIFVUQ1xuICAgICAqL1xuICAgIHRvVXRjTmF0aXZlRGF0ZSgpOiBEYXRlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKHRoaXMueWVhciwgdGhpcy5tb250aCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRlc3RzIG1vbnRoIGFuZCB5ZWFyIGZvciB2YWxpZGl0eVxuICAgICAqL1xuICAgIHN0YXRpYyBpc1ZhbGlkTW9udGgoeWVhcjogbnVtYmVyLCBtb250aDogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBUdWlZZWFyLmlzVmFsaWRZZWFyKHllYXIpICYmIFR1aU1vbnRoLmlzVmFsaWRNb250aFBhcnQobW9udGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgbnVtYmVyIG9mIGRheXMgaW4gYSBtb250aFxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRNb250aERheXNDb3VudChtb250aDogbnVtYmVyLCBpc0xlYXBZZWFyOiBib29sZWFuKTogbnVtYmVyIHtcbiAgICAgICAgdHVpQXNzZXJ0LmFzc2VydChUdWlNb250aC5pc1ZhbGlkTW9udGhQYXJ0KG1vbnRoKSk7XG5cbiAgICAgICAgc3dpdGNoIChtb250aCkge1xuICAgICAgICAgICAgY2FzZSBUdWlNb250aE51bWJlci5GZWJydWFyeTpcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNMZWFwWWVhciA/IDI5IDogMjg7XG4gICAgICAgICAgICBjYXNlIFR1aU1vbnRoTnVtYmVyLkFwcmlsOlxuICAgICAgICAgICAgY2FzZSBUdWlNb250aE51bWJlci5KdW5lOlxuICAgICAgICAgICAgY2FzZSBUdWlNb250aE51bWJlci5TZXB0ZW1iZXI6XG4gICAgICAgICAgICBjYXNlIFR1aU1vbnRoTnVtYmVyLk5vdmVtYmVyOlxuICAgICAgICAgICAgICAgIHJldHVybiAzMDtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDMxO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjdXJyZW50IG1vbnRoIGFuZCB5ZWFyIGJhc2VkIG9uIGxvY2FsIHRpbWUgem9uZVxuICAgICAqIEBub3NpZGVlZmZlY3RzXG4gICAgICovXG4gICAgc3RhdGljIGN1cnJlbnRMb2NhbCgpOiBUdWlNb250aCB7XG4gICAgICAgIGNvbnN0IG5hdGl2ZURhdGUgPSBuZXcgRGF0ZSgpO1xuXG4gICAgICAgIHJldHVybiBuZXcgVHVpTW9udGgobmF0aXZlRGF0ZS5nZXRGdWxsWWVhcigpLCBuYXRpdmVEYXRlLmdldE1vbnRoKCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY3VycmVudCBtb250aCBhbmQgeWVhciBiYXNlZCBvbiBVVENcbiAgICAgKi9cbiAgICBzdGF0aWMgY3VycmVudFV0YygpOiBUdWlNb250aCB7XG4gICAgICAgIGNvbnN0IG5hdGl2ZURhdGUgPSBuZXcgRGF0ZSgpO1xuXG4gICAgICAgIHJldHVybiBuZXcgVHVpTW9udGgobmF0aXZlRGF0ZS5nZXRVVENGdWxsWWVhcigpLCBuYXRpdmVEYXRlLmdldFVUQ01vbnRoKCkpO1xuICAgIH1cblxuICAgIHN0YXRpYyBsZW5ndGhCZXR3ZWVuKGZyb206IFR1aU1vbnRoLCB0bzogVHVpTW9udGgpOiBudW1iZXIge1xuICAgICAgICBjb25zdCBhYnNvbHV0ZUZyb20gPSBmcm9tLm1vbnRoICsgZnJvbS55ZWFyICogMTI7XG4gICAgICAgIGNvbnN0IGFic29sdXRlVG8gPSB0by5tb250aCArIHRvLnllYXIgKiAxMjtcblxuICAgICAgICByZXR1cm4gYWJzb2x1dGVUbyAtIGFic29sdXRlRnJvbTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBOb3JtYWxpemVzIG51bWJlciBieSBjbGFtcGluZyBpdCBiZXR3ZWVuIG1pbiBhbmQgbWF4IG1vbnRoXG4gICAgICovXG4gICAgcHJvdGVjdGVkIHN0YXRpYyBub3JtYWxpemVNb250aFBhcnQobW9udGg6IG51bWJlcik6IG51bWJlciB7XG4gICAgICAgIHJldHVybiBub3JtYWxpemVUb0ludE51bWJlcihtb250aCwgTUlOX01PTlRILCBNQVhfTU9OVEgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRlc3RzIG1vbnRoIGZvciB2YWxpZGl0eVxuICAgICAqL1xuICAgIHByaXZhdGUgc3RhdGljIGlzVmFsaWRNb250aFBhcnQobW9udGg6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gTnVtYmVyLmlzSW50ZWdlcihtb250aCkgJiYgaW5SYW5nZShtb250aCwgTUlOX01PTlRILCBNQVhfTU9OVEggKyAxKTtcbiAgICB9XG59XG4iXX0=