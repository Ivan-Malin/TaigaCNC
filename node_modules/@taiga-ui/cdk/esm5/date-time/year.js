import { tuiAssert } from '@taiga-ui/cdk/classes';
import { padStart } from '@taiga-ui/cdk/utils/format';
import { inRange, normalizeToIntNumber } from '@taiga-ui/cdk/utils/math';
import { DAYS_IN_LEAP_YEAR, DAYS_IN_NORMAL_YEAR, DAYS_IN_WEEK, MAX_YEAR, MIN_YEAR, } from './date-time';
/**
 * Immutable year object
 * @nosideeffects
 */
var TuiYear = /** @class */ (function () {
    function TuiYear(year) {
        this.year = year;
        tuiAssert.assert(TuiYear.isValidYear(year));
    }
    Object.defineProperty(TuiYear.prototype, "formattedYear", {
        get: function () {
            return padStart(this.year.toString(), 4, '0');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TuiYear.prototype, "isLeapYear", {
        get: function () {
            return TuiYear.isLeapYear(this.year);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TuiYear.prototype, "absoluteLeapYears", {
        /**
         * Returns amount of leap years from year 0 to current
         */
        get: function () {
            return TuiYear.getAbsoluteLeapYears(this.year);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TuiYear.prototype, "yearStartDaysOffset", {
        /**
         * Returns day of week offset of the beginning of the current year
         */
        get: function () {
            return TuiYear.getYearStartDaysOffset(this.year, this.absoluteLeapYears);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Passed year is after current
     */
    TuiYear.prototype.yearBefore = function (_a) {
        var year = _a.year;
        return this.year < year;
    };
    /**
     * Passed year is the same or after current
     */
    TuiYear.prototype.yearSameOrBefore = function (_a) {
        var year = _a.year;
        return this.year <= year;
    };
    /**
     * Passed year is the same as current
     */
    TuiYear.prototype.yearSame = function (_a) {
        var year = _a.year;
        return this.year === year;
    };
    /**
     * Passed year is either the same of before the current
     */
    TuiYear.prototype.yearSameOrAfter = function (_a) {
        var year = _a.year;
        return this.year >= year;
    };
    /**
     * Passed year is before current
     */
    TuiYear.prototype.yearAfter = function (_a) {
        var year = _a.year;
        return this.year > year;
    };
    // TODO: Consider removing `backwards` option
    /**
     * Immutably offsets year
     */
    TuiYear.prototype.append = function (_a, backwards) {
        var _b = _a.year, year = _b === void 0 ? 0 : _b;
        if (backwards === void 0) { backwards = false; }
        tuiAssert.assert(Number.isInteger(year));
        if (backwards) {
            year *= -1;
        }
        var resultYear = this.year + year;
        tuiAssert.assert(TuiYear.isValidYear(resultYear));
        return new TuiYear(resultYear);
    };
    TuiYear.prototype.toString = function () {
        return this.formattedYear;
    };
    TuiYear.prototype.toJSON = function () {
        return this.formattedYear;
    };
    /**
     * Checks year for validity
     */
    TuiYear.isValidYear = function (year) {
        return Number.isInteger(year) && inRange(year, MIN_YEAR, MAX_YEAR + 1);
    };
    /**
     * Check if passed year is a leap year
     */
    TuiYear.isLeapYear = function (year) {
        tuiAssert.assert(TuiYear.isValidYear(year));
        return year % 400 === 0 || (year % 4 === 0 && year % 100 !== 0);
    };
    /**
     * Returns amount of leap years from year 0 to the passed one
     */
    TuiYear.getAbsoluteLeapYears = function (year) {
        tuiAssert.assert(TuiYear.isValidYear(year));
        return Math.ceil(year / 400) + (Math.ceil(year / 4) - Math.ceil(year / 100));
    };
    /**
     * Returns day of week offset of the beginning of the passed year
     *
     * @param year
     * @param absoluteLeapYears amount of leap years prior to the passed one
     * @return offset in days
     */
    TuiYear.getYearStartDaysOffset = function (year, absoluteLeapYears) {
        tuiAssert.assert(TuiYear.isValidYear(year));
        tuiAssert.assert(Number.isInteger(absoluteLeapYears));
        tuiAssert.assert(year >= absoluteLeapYears);
        tuiAssert.assert(absoluteLeapYears >= 0);
        return ((absoluteLeapYears * DAYS_IN_LEAP_YEAR +
            (year - absoluteLeapYears) * DAYS_IN_NORMAL_YEAR +
            5) %
            DAYS_IN_WEEK);
    };
    TuiYear.lengthBetween = function (from, to) {
        return to.year - from.year;
    };
    /**
     * Normalizes year by clamping it between min and max years
     */
    TuiYear.normalizeYearPart = function (year) {
        return normalizeToIntNumber(year, MIN_YEAR, MAX_YEAR);
    };
    return TuiYear;
}());
export { TuiYear };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoieWVhci5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0B0YWlnYS11aS9jZGsvZGF0ZS10aW1lLyIsInNvdXJjZXMiOlsieWVhci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUMsU0FBUyxFQUFDLE1BQU0sdUJBQXVCLENBQUM7QUFFaEQsT0FBTyxFQUFDLFFBQVEsRUFBQyxNQUFNLDRCQUE0QixDQUFDO0FBQ3BELE9BQU8sRUFBQyxPQUFPLEVBQUUsb0JBQW9CLEVBQUMsTUFBTSwwQkFBMEIsQ0FBQztBQUN2RSxPQUFPLEVBQ0gsaUJBQWlCLEVBQ2pCLG1CQUFtQixFQUNuQixZQUFZLEVBQ1osUUFBUSxFQUNSLFFBQVEsR0FDWCxNQUFNLGFBQWEsQ0FBQztBQUVyQjs7O0dBR0c7QUFDSDtJQUNJLGlCQUFxQixJQUFZO1FBQVosU0FBSSxHQUFKLElBQUksQ0FBUTtRQUM3QixTQUFTLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztJQUNoRCxDQUFDO0lBRUQsc0JBQUksa0NBQWE7YUFBakI7WUFDSSxPQUFPLFFBQVEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxFQUFFLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQztRQUNsRCxDQUFDOzs7T0FBQTtJQUVELHNCQUFJLCtCQUFVO2FBQWQ7WUFDSSxPQUFPLE9BQU8sQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3pDLENBQUM7OztPQUFBO0lBS0Qsc0JBQUksc0NBQWlCO1FBSHJCOztXQUVHO2FBQ0g7WUFDSSxPQUFPLE9BQU8sQ0FBQyxvQkFBb0IsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDbkQsQ0FBQzs7O09BQUE7SUFLRCxzQkFBSSx3Q0FBbUI7UUFIdkI7O1dBRUc7YUFDSDtZQUNJLE9BQU8sT0FBTyxDQUFDLHNCQUFzQixDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsSUFB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QUMsSUFBSSxDQUFDLENBQUMsQ0FBQztRQUM1QyxTQUFTLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxDQUFDO1FBQ3RELFNBQVMsQ0FBQyxNQUFNLENBQUMsSUFBSSxJQUFJLGlCQUFpQixDQUFDLENBQUM7UUFDNUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxpQkFBaUIsSUFBSSxDQUFDLENBQUMsQ0FBQztRQUV6QyxPQUFPLENBQ0gsQ0FBQyxpQkFBaUIsR0FBRyxpQkFBaUI7WUFDbEMsQ0FBQyxJQUFJLEdBQUcsaUJBQWlCLENBQUMsR0FBRyxtQkFBbUI7WUFDaEQsQ0FBQyxDQUFDO1lBQ04sWUFBWSxDQUNmLENBQUM7SUFDTixDQUFDO0lBRU0scUJBQWEsR0FBcEIsVUFBcUIsSUFBYSxFQUFFLEVBQVc7UUFDM0MsT0FBTyxFQUFFLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUM7SUFDL0IsQ0FBQztJQUVEOztPQUVHO0lBQ2MseUJBQWlCLEdBQWxDLFVBQW1DLElBQVk7UUFDM0MsT0FBTyxvQkFBb0IsQ0FBQyxJQUFJLEVBQUUsUUFBUSxFQUFFLFFBQVEsQ0FBQyxDQUFDO0lBQzFELENBQUM7SUFDTCxjQUFDO0FBQUQsQ0FBQyxBQWhKRCxJQWdKQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7dHVpQXNzZXJ0fSBmcm9tICdAdGFpZ2EtdWkvY2RrL2NsYXNzZXMnO1xuaW1wb3J0IHtUdWlZZWFyTGlrZX0gZnJvbSAnQHRhaWdhLXVpL2Nkay9pbnRlcmZhY2VzJztcbmltcG9ydCB7cGFkU3RhcnR9IGZyb20gJ0B0YWlnYS11aS9jZGsvdXRpbHMvZm9ybWF0JztcbmltcG9ydCB7aW5SYW5nZSwgbm9ybWFsaXplVG9JbnROdW1iZXJ9IGZyb20gJ0B0YWlnYS11aS9jZGsvdXRpbHMvbWF0aCc7XG5pbXBvcnQge1xuICAgIERBWVNfSU5fTEVBUF9ZRUFSLFxuICAgIERBWVNfSU5fTk9STUFMX1lFQVIsXG4gICAgREFZU19JTl9XRUVLLFxuICAgIE1BWF9ZRUFSLFxuICAgIE1JTl9ZRUFSLFxufSBmcm9tICcuL2RhdGUtdGltZSc7XG5cbi8qKlxuICogSW1tdXRhYmxlIHllYXIgb2JqZWN0XG4gKiBAbm9zaWRlZWZmZWN0c1xuICovXG5leHBvcnQgY2xhc3MgVHVpWWVhciBpbXBsZW1lbnRzIFR1aVllYXJMaWtlIHtcbiAgICBjb25zdHJ1Y3RvcihyZWFkb25seSB5ZWFyOiBudW1iZXIpIHtcbiAgICAgICAgdHVpQXNzZXJ0LmFzc2VydChUdWlZZWFyLmlzVmFsaWRZZWFyKHllYXIpKTtcbiAgICB9XG5cbiAgICBnZXQgZm9ybWF0dGVkWWVhcigpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gcGFkU3RhcnQodGhpcy55ZWFyLnRvU3RyaW5nKCksIDQsICcwJyk7XG4gICAgfVxuXG4gICAgZ2V0IGlzTGVhcFllYXIoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBUdWlZZWFyLmlzTGVhcFllYXIodGhpcy55ZWFyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFtb3VudCBvZiBsZWFwIHllYXJzIGZyb20geWVhciAwIHRvIGN1cnJlbnRcbiAgICAgKi9cbiAgICBnZXQgYWJzb2x1dGVMZWFwWWVhcnMoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIFR1aVllYXIuZ2V0QWJzb2x1dGVMZWFwWWVhcnModGhpcy55ZWFyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGRheSBvZiB3ZWVrIG9mZnNldCBvZiB0aGUgYmVnaW5uaW5nIG9mIHRoZSBjdXJyZW50IHllYXJcbiAgICAgKi9cbiAgICBnZXQgeWVhclN0YXJ0RGF5c09mZnNldCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gVHVpWWVhci5nZXRZZWFyU3RhcnREYXlzT2Zmc2V0KHRoaXMueWVhciwgdGhpcy5hYnNvbHV0ZUxlYXBZZWFycyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFzc2VkIHllYXIgaXMgYWZ0ZXIgY3VycmVudFxuICAgICAqL1xuICAgIHllYXJCZWZvcmUoe3llYXJ9OiBUdWlZZWFyKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLnllYXIgPCB5ZWFyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhc3NlZCB5ZWFyIGlzIHRoZSBzYW1lIG9yIGFmdGVyIGN1cnJlbnRcbiAgICAgKi9cbiAgICB5ZWFyU2FtZU9yQmVmb3JlKHt5ZWFyfTogVHVpWWVhcik6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy55ZWFyIDw9IHllYXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFzc2VkIHllYXIgaXMgdGhlIHNhbWUgYXMgY3VycmVudFxuICAgICAqL1xuICAgIHllYXJTYW1lKHt5ZWFyfTogVHVpWWVhcik6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy55ZWFyID09PSB5ZWFyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhc3NlZCB5ZWFyIGlzIGVpdGhlciB0aGUgc2FtZSBvZiBiZWZvcmUgdGhlIGN1cnJlbnRcbiAgICAgKi9cbiAgICB5ZWFyU2FtZU9yQWZ0ZXIoe3llYXJ9OiBUdWlZZWFyKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLnllYXIgPj0geWVhcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXNzZWQgeWVhciBpcyBiZWZvcmUgY3VycmVudFxuICAgICAqL1xuICAgIHllYXJBZnRlcih7eWVhcn06IFR1aVllYXIpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueWVhciA+IHllYXI7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogQ29uc2lkZXIgcmVtb3ZpbmcgYGJhY2t3YXJkc2Agb3B0aW9uXG4gICAgLyoqXG4gICAgICogSW1tdXRhYmx5IG9mZnNldHMgeWVhclxuICAgICAqL1xuICAgIGFwcGVuZCh7eWVhciA9IDB9OiBUdWlZZWFyTGlrZSwgYmFja3dhcmRzOiBib29sZWFuID0gZmFsc2UpOiBUdWlZZWFyIHtcbiAgICAgICAgdHVpQXNzZXJ0LmFzc2VydChOdW1iZXIuaXNJbnRlZ2VyKHllYXIpKTtcblxuICAgICAgICBpZiAoYmFja3dhcmRzKSB7XG4gICAgICAgICAgICB5ZWFyICo9IC0xO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVzdWx0WWVhciA9IHRoaXMueWVhciArIHllYXI7XG5cbiAgICAgICAgdHVpQXNzZXJ0LmFzc2VydChUdWlZZWFyLmlzVmFsaWRZZWFyKHJlc3VsdFllYXIpKTtcblxuICAgICAgICByZXR1cm4gbmV3IFR1aVllYXIocmVzdWx0WWVhcik7XG4gICAgfVxuXG4gICAgdG9TdHJpbmcoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0dGVkWWVhcjtcbiAgICB9XG5cbiAgICB0b0pTT04oKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0dGVkWWVhcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgeWVhciBmb3IgdmFsaWRpdHlcbiAgICAgKi9cbiAgICBzdGF0aWMgaXNWYWxpZFllYXIoeWVhcjogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBOdW1iZXIuaXNJbnRlZ2VyKHllYXIpICYmIGluUmFuZ2UoeWVhciwgTUlOX1lFQVIsIE1BWF9ZRUFSICsgMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgcGFzc2VkIHllYXIgaXMgYSBsZWFwIHllYXJcbiAgICAgKi9cbiAgICBzdGF0aWMgaXNMZWFwWWVhcih5ZWFyOiBudW1iZXIpOiBib29sZWFuIHtcbiAgICAgICAgdHVpQXNzZXJ0LmFzc2VydChUdWlZZWFyLmlzVmFsaWRZZWFyKHllYXIpKTtcblxuICAgICAgICByZXR1cm4geWVhciAlIDQwMCA9PT0gMCB8fCAoeWVhciAlIDQgPT09IDAgJiYgeWVhciAlIDEwMCAhPT0gMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbW91bnQgb2YgbGVhcCB5ZWFycyBmcm9tIHllYXIgMCB0byB0aGUgcGFzc2VkIG9uZVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRBYnNvbHV0ZUxlYXBZZWFycyh5ZWFyOiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICB0dWlBc3NlcnQuYXNzZXJ0KFR1aVllYXIuaXNWYWxpZFllYXIoeWVhcikpO1xuXG4gICAgICAgIHJldHVybiBNYXRoLmNlaWwoeWVhciAvIDQwMCkgKyAoTWF0aC5jZWlsKHllYXIgLyA0KSAtIE1hdGguY2VpbCh5ZWFyIC8gMTAwKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBkYXkgb2Ygd2VlayBvZmZzZXQgb2YgdGhlIGJlZ2lubmluZyBvZiB0aGUgcGFzc2VkIHllYXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB5ZWFyXG4gICAgICogQHBhcmFtIGFic29sdXRlTGVhcFllYXJzIGFtb3VudCBvZiBsZWFwIHllYXJzIHByaW9yIHRvIHRoZSBwYXNzZWQgb25lXG4gICAgICogQHJldHVybiBvZmZzZXQgaW4gZGF5c1xuICAgICAqL1xuICAgIHN0YXRpYyBnZXRZZWFyU3RhcnREYXlzT2Zmc2V0KHllYXI6IG51bWJlciwgYWJzb2x1dGVMZWFwWWVhcnM6IG51bWJlcik6IG51bWJlciB7XG4gICAgICAgIHR1aUFzc2VydC5hc3NlcnQoVHVpWWVhci5pc1ZhbGlkWWVhcih5ZWFyKSk7XG4gICAgICAgIHR1aUFzc2VydC5hc3NlcnQoTnVtYmVyLmlzSW50ZWdlcihhYnNvbHV0ZUxlYXBZZWFycykpO1xuICAgICAgICB0dWlBc3NlcnQuYXNzZXJ0KHllYXIgPj0gYWJzb2x1dGVMZWFwWWVhcnMpO1xuICAgICAgICB0dWlBc3NlcnQuYXNzZXJ0KGFic29sdXRlTGVhcFllYXJzID49IDApO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAoYWJzb2x1dGVMZWFwWWVhcnMgKiBEQVlTX0lOX0xFQVBfWUVBUiArXG4gICAgICAgICAgICAgICAgKHllYXIgLSBhYnNvbHV0ZUxlYXBZZWFycykgKiBEQVlTX0lOX05PUk1BTF9ZRUFSICtcbiAgICAgICAgICAgICAgICA1KSAlXG4gICAgICAgICAgICBEQVlTX0lOX1dFRUtcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgbGVuZ3RoQmV0d2Vlbihmcm9tOiBUdWlZZWFyLCB0bzogVHVpWWVhcik6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0by55ZWFyIC0gZnJvbS55ZWFyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE5vcm1hbGl6ZXMgeWVhciBieSBjbGFtcGluZyBpdCBiZXR3ZWVuIG1pbiBhbmQgbWF4IHllYXJzXG4gICAgICovXG4gICAgcHJvdGVjdGVkIHN0YXRpYyBub3JtYWxpemVZZWFyUGFydCh5ZWFyOiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gbm9ybWFsaXplVG9JbnROdW1iZXIoeWVhciwgTUlOX1lFQVIsIE1BWF9ZRUFSKTtcbiAgICB9XG59XG4iXX0=