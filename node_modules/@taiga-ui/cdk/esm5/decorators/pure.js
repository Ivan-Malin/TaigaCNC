/**
 * Implements lazy initialization for getter or memoization of a function call similar to pure {@link: Pipe}.
 * Replaces getter with its calculated value upon first call or keeps track of last call arguments and returned
 * value for function, skipping calculation when arguments are strictly the same.
 *
 * @throws error if used not on getter or function
 *
 * CAUTION: `this` is not available inside such functions/getters, they must be pure.
 */
export function tuiPure(_target, propertyKey, _a) {
    var get = _a.get, enumerable = _a.enumerable, value = _a.value;
    if (get) {
        return {
            enumerable: enumerable,
            get: function () {
                var value = get.call(this);
                Object.defineProperty(this, propertyKey, { enumerable: enumerable, value: value });
                return value;
            },
        };
    }
    if (typeof value !== 'function') {
        throw new Error('tuiPure can only be used with functions or getters');
    }
    var original = value;
    return {
        enumerable: enumerable,
        get: function () {
            var _this = this;
            var previousArgs = [];
            var previousResult;
            var patched = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                if (previousArgs.length === args.length &&
                    args.every(function (arg, index) { return arg === previousArgs[index]; })) {
                    return previousResult;
                }
                previousArgs = args;
                previousResult = original.apply(_this, args);
                return previousResult;
            };
            Object.defineProperty(this, propertyKey, {
                value: patched,
            });
            return patched;
        },
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHVyZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0B0YWlnYS11aS9jZGsvZGVjb3JhdG9ycy8iLCJzb3VyY2VzIjpbInB1cmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7O0dBUUc7QUFDSCxNQUFNLFVBQVUsT0FBTyxDQUNuQixPQUFlLEVBQ2YsV0FBbUIsRUFDbkIsRUFBb0Q7UUFBbkQsWUFBRyxFQUFFLDBCQUFVLEVBQUUsZ0JBQUs7SUFFdkIsSUFBSSxHQUFHLEVBQUU7UUFDTCxPQUFPO1lBQ0gsVUFBVSxZQUFBO1lBQ1YsR0FBRyxFQUFIO2dCQUNJLElBQU0sS0FBSyxHQUFHLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7Z0JBRTdCLE1BQU0sQ0FBQyxjQUFjLENBQUMsSUFBSSxFQUFFLFdBQVcsRUFBRSxFQUFDLFVBQVUsWUFBQSxFQUFFLEtBQUssT0FBQSxFQUFDLENBQUMsQ0FBQztnQkFFOUQsT0FBTyxLQUFLLENBQUM7WUFDakIsQ0FBQztTQUNKLENBQUM7S0FDTDtJQUVELElBQUksT0FBTyxLQUFLLEtBQUssVUFBVSxFQUFFO1FBQzdCLE1BQU0sSUFBSSxLQUFLLENBQUMsb0RBQW9ELENBQUMsQ0FBQztLQUN6RTtJQUVELElBQU0sUUFBUSxHQUFHLEtBQUssQ0FBQztJQUV2QixPQUFPO1FBQ0gsVUFBVSxZQUFBO1FBQ1YsR0FBRyxFQUFIO1lBQUEsaUJBdUJDO1lBdEJHLElBQUksWUFBWSxHQUEyQixFQUFFLENBQUM7WUFDOUMsSUFBSSxjQUFtQixDQUFDO1lBRXhCLElBQU0sT0FBTyxHQUFHO2dCQUFDLGNBQXVCO3FCQUF2QixVQUF1QixFQUF2QixxQkFBdUIsRUFBdkIsSUFBdUI7b0JBQXZCLHlCQUF1Qjs7Z0JBQ3BDLElBQ0ksWUFBWSxDQUFDLE1BQU0sS0FBSyxJQUFJLENBQUMsTUFBTTtvQkFDbkMsSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFDLEdBQUcsRUFBRSxLQUFLLElBQUssT0FBQSxHQUFHLEtBQUssWUFBWSxDQUFDLEtBQUssQ0FBQyxFQUEzQixDQUEyQixDQUFDLEVBQ3pEO29CQUNFLE9BQU8sY0FBYyxDQUFDO2lCQUN6QjtnQkFFRCxZQUFZLEdBQUcsSUFBSSxDQUFDO2dCQUNwQixjQUFjLEdBQUcsUUFBUSxDQUFDLEtBQUssQ0FBQyxLQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7Z0JBRTVDLE9BQU8sY0FBYyxDQUFDO1lBQzFCLENBQUMsQ0FBQztZQUVGLE1BQU0sQ0FBQyxjQUFjLENBQUMsSUFBSSxFQUFFLFdBQVcsRUFBRTtnQkFDckMsS0FBSyxFQUFFLE9BQU87YUFDakIsQ0FBQyxDQUFDO1lBRUgsT0FBTyxPQUFjLENBQUM7UUFDMUIsQ0FBQztLQUNKLENBQUM7QUFDTixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBJbXBsZW1lbnRzIGxhenkgaW5pdGlhbGl6YXRpb24gZm9yIGdldHRlciBvciBtZW1vaXphdGlvbiBvZiBhIGZ1bmN0aW9uIGNhbGwgc2ltaWxhciB0byBwdXJlIHtAbGluazogUGlwZX0uXG4gKiBSZXBsYWNlcyBnZXR0ZXIgd2l0aCBpdHMgY2FsY3VsYXRlZCB2YWx1ZSB1cG9uIGZpcnN0IGNhbGwgb3Iga2VlcHMgdHJhY2sgb2YgbGFzdCBjYWxsIGFyZ3VtZW50cyBhbmQgcmV0dXJuZWRcbiAqIHZhbHVlIGZvciBmdW5jdGlvbiwgc2tpcHBpbmcgY2FsY3VsYXRpb24gd2hlbiBhcmd1bWVudHMgYXJlIHN0cmljdGx5IHRoZSBzYW1lLlxuICpcbiAqIEB0aHJvd3MgZXJyb3IgaWYgdXNlZCBub3Qgb24gZ2V0dGVyIG9yIGZ1bmN0aW9uXG4gKlxuICogQ0FVVElPTjogYHRoaXNgIGlzIG5vdCBhdmFpbGFibGUgaW5zaWRlIHN1Y2ggZnVuY3Rpb25zL2dldHRlcnMsIHRoZXkgbXVzdCBiZSBwdXJlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdHVpUHVyZTxUPihcbiAgICBfdGFyZ2V0OiBPYmplY3QsXG4gICAgcHJvcGVydHlLZXk6IHN0cmluZyxcbiAgICB7Z2V0LCBlbnVtZXJhYmxlLCB2YWx1ZX06IFR5cGVkUHJvcGVydHlEZXNjcmlwdG9yPFQ+LFxuKTogVHlwZWRQcm9wZXJ0eURlc2NyaXB0b3I8VD4ge1xuICAgIGlmIChnZXQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVudW1lcmFibGUsXG4gICAgICAgICAgICBnZXQoKTogVCB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBnZXQuY2FsbCh0aGlzKTtcblxuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBwcm9wZXJ0eUtleSwge2VudW1lcmFibGUsIHZhbHVlfSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0dWlQdXJlIGNhbiBvbmx5IGJlIHVzZWQgd2l0aCBmdW5jdGlvbnMgb3IgZ2V0dGVycycpO1xuICAgIH1cblxuICAgIGNvbnN0IG9yaWdpbmFsID0gdmFsdWU7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBlbnVtZXJhYmxlLFxuICAgICAgICBnZXQoKTogVCB7XG4gICAgICAgICAgICBsZXQgcHJldmlvdXNBcmdzOiBSZWFkb25seUFycmF5PHVua25vd24+ID0gW107XG4gICAgICAgICAgICBsZXQgcHJldmlvdXNSZXN1bHQ6IGFueTtcblxuICAgICAgICAgICAgY29uc3QgcGF0Y2hlZCA9ICguLi5hcmdzOiBBcnJheTx1bmtub3duPikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNBcmdzLmxlbmd0aCA9PT0gYXJncy5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgICAgYXJncy5ldmVyeSgoYXJnLCBpbmRleCkgPT4gYXJnID09PSBwcmV2aW91c0FyZ3NbaW5kZXhdKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJldmlvdXNSZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcHJldmlvdXNBcmdzID0gYXJncztcbiAgICAgICAgICAgICAgICBwcmV2aW91c1Jlc3VsdCA9IG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZXZpb3VzUmVzdWx0O1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIHByb3BlcnR5S2V5LCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHBhdGNoZWQsXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIHBhdGNoZWQgYXMgYW55O1xuICAgICAgICB9LFxuICAgIH07XG59XG4iXX0=