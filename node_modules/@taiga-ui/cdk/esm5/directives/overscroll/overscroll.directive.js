import { __decorate, __param } from "tslib";
import { Directive, ElementRef, HostBinding, Inject, Input, NgZone } from '@angular/core';
import { tuiZoneOptimized, typedFromEvent } from '@taiga-ui/cdk/observables';
import { TuiDestroyService } from '@taiga-ui/cdk/services';
import { canScroll, getScrollParent } from '@taiga-ui/cdk/utils/dom';
import { Observable } from 'rxjs';
import { filter, switchMap, takeUntil, tap } from 'rxjs/operators';
/**
 * Directive to isolate scrolling, i.e. prevent body scroll behind modal dialog
 * @dynamic
 */
var TuiOverscrollDirective = /** @class */ (function () {
    function TuiOverscrollDirective(_a, ngZone, destroy$) {
        var _this = this;
        var nativeElement = _a.nativeElement;
        this.mode = "scroll" /* Scroll */;
        typedFromEvent(nativeElement, 'wheel', { passive: false })
            .pipe(filter(function () { return _this.enabled; }), takeUntil(destroy$), tuiZoneOptimized(ngZone))
            .subscribe(function (event) {
            _this.processEvent(event, !!event.deltaY, event.deltaY ? event.deltaY < 0 : event.deltaX < 0);
        });
        typedFromEvent(nativeElement, 'touchstart')
            .pipe(switchMap(function (_a) {
            var touches = _a.touches;
            var _b = touches[0], clientX = _b.clientX, clientY = _b.clientY;
            var deltaX = 0;
            var deltaY = 0;
            var vertical;
            return typedFromEvent(nativeElement, 'touchmove', {
                passive: false,
            }).pipe(filter(function () { return _this.enabled; }), tuiZoneOptimized(ngZone), tap(function (event) {
                // We have to have it in tap instead of subscribe due to variables in closure
                var changedTouch = event.changedTouches[0];
                deltaX = clientX - changedTouch.clientX;
                deltaY = clientY - changedTouch.clientY;
                clientX = changedTouch.clientX;
                clientY = changedTouch.clientY;
                if (vertical === undefined) {
                    vertical = Math.abs(deltaY) > Math.abs(deltaX);
                }
                _this.processEvent(event, vertical, vertical ? deltaY < 0 : deltaX < 0);
            }));
        }), takeUntil(destroy$))
            .subscribe();
    }
    Object.defineProperty(TuiOverscrollDirective.prototype, "enabled", {
        get: function () {
            return this.mode !== "none" /* None */;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TuiOverscrollDirective.prototype, "overscrollBehavior", {
        get: function () {
            return this.enabled ? 'contain' : null;
        },
        enumerable: true,
        configurable: true
    });
    TuiOverscrollDirective.prototype.processEvent = function (event, vertical, negative) {
        var target = event.target, currentTarget = event.currentTarget, cancelable = event.cancelable;
        if (!cancelable || !(target instanceof Element)) {
            return;
        }
        // This is all what's needed in Chrome/Firefox thanks to CSS overscroll-behavior
        if (this.mode === "all" /* All */ &&
            ((vertical && !currentTarget.contains(getScrollParent(target))) ||
                (!vertical && !currentTarget.contains(getScrollParent(target, false))))) {
            event.preventDefault();
            return;
        }
        // This is Safari/IE/Edge fallback
        if (vertical &&
            ((negative && !canScroll(target, currentTarget, true, false)) ||
                (!negative && !canScroll(target, currentTarget, true, true)))) {
            event.preventDefault();
            return;
        }
        if (!vertical &&
            ((negative && !canScroll(target, currentTarget, false, false)) ||
                (!negative && !canScroll(target, currentTarget, false, true)))) {
            event.preventDefault();
        }
    };
    TuiOverscrollDirective.ctorParameters = function () { return [
        { type: ElementRef, decorators: [{ type: Inject, args: [ElementRef,] }] },
        { type: NgZone, decorators: [{ type: Inject, args: [NgZone,] }] },
        { type: Observable, decorators: [{ type: Inject, args: [TuiDestroyService,] }] }
    ]; };
    __decorate([
        Input('tuiOverscroll')
    ], TuiOverscrollDirective.prototype, "mode", void 0);
    __decorate([
        HostBinding('style.overscrollBehavior')
    ], TuiOverscrollDirective.prototype, "overscrollBehavior", null);
    TuiOverscrollDirective = __decorate([
        Directive({
            selector: '[tuiOverscroll]',
            providers: [TuiDestroyService],
        }),
        __param(0, Inject(ElementRef)),
        __param(1, Inject(NgZone)),
        __param(2, Inject(TuiDestroyService))
    ], TuiOverscrollDirective);
    return TuiOverscrollDirective;
}());
export { TuiOverscrollDirective };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib3ZlcnNjcm9sbC5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AdGFpZ2EtdWkvY2RrL2RpcmVjdGl2ZXMvb3ZlcnNjcm9sbC8iLCJzb3VyY2VzIjpbIm92ZXJzY3JvbGwuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQUMsU0FBUyxFQUFFLFVBQVUsRUFBRSxXQUFXLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUMsTUFBTSxlQUFlLENBQUM7QUFFeEYsT0FBTyxFQUFDLGdCQUFnQixFQUFFLGNBQWMsRUFBQyxNQUFNLDJCQUEyQixDQUFDO0FBQzNFLE9BQU8sRUFBQyxpQkFBaUIsRUFBQyxNQUFNLHdCQUF3QixDQUFDO0FBRXpELE9BQU8sRUFBQyxTQUFTLEVBQUUsZUFBZSxFQUFDLE1BQU0seUJBQXlCLENBQUM7QUFDbkUsT0FBTyxFQUFDLFVBQVUsRUFBQyxNQUFNLE1BQU0sQ0FBQztBQUNoQyxPQUFPLEVBQUMsTUFBTSxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsR0FBRyxFQUFDLE1BQU0sZ0JBQWdCLENBQUM7QUFFakU7OztHQUdHO0FBS0g7SUFJSSxnQ0FDd0IsRUFBd0MsRUFDNUMsTUFBYyxFQUNILFFBQTBCO1FBSHpELGlCQXdEQztZQXZEd0IsZ0NBQWE7UUFIdEMsU0FBSSx5QkFBNEI7UUFPNUIsY0FBYyxDQUFDLGFBQWEsRUFBRSxPQUFPLEVBQUUsRUFBQyxPQUFPLEVBQUUsS0FBSyxFQUFDLENBQUM7YUFDbkQsSUFBSSxDQUNELE1BQU0sQ0FBQyxjQUFNLE9BQUEsS0FBSSxDQUFDLE9BQU8sRUFBWixDQUFZLENBQUMsRUFDMUIsU0FBUyxDQUFDLFFBQVEsQ0FBQyxFQUNuQixnQkFBZ0IsQ0FBQyxNQUFNLENBQUMsQ0FDM0I7YUFDQSxTQUFTLENBQUMsVUFBQSxLQUFLO1lBQ1osS0FBSSxDQUFDLFlBQVksQ0FDYixLQUFLLEVBQ0wsQ0FBQyxDQUFDLEtBQUssQ0FBQyxNQUFN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U0FoSFksc0JBQXNCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEhvc3RCaW5kaW5nLCBJbmplY3QsIElucHV0LCBOZ1pvbmV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtUdWlPdmVyc2Nyb2xsTW9kZX0gZnJvbSAnQHRhaWdhLXVpL2Nkay9lbnVtcyc7XG5pbXBvcnQge3R1aVpvbmVPcHRpbWl6ZWQsIHR5cGVkRnJvbUV2ZW50fSBmcm9tICdAdGFpZ2EtdWkvY2RrL29ic2VydmFibGVzJztcbmltcG9ydCB7VHVpRGVzdHJveVNlcnZpY2V9IGZyb20gJ0B0YWlnYS11aS9jZGsvc2VydmljZXMnO1xuaW1wb3J0IHtUdWlFdmVudFdpdGh9IGZyb20gJ0B0YWlnYS11aS9jZGsvdHlwZXMnO1xuaW1wb3J0IHtjYW5TY3JvbGwsIGdldFNjcm9sbFBhcmVudH0gZnJvbSAnQHRhaWdhLXVpL2Nkay91dGlscy9kb20nO1xuaW1wb3J0IHtPYnNlcnZhYmxlfSBmcm9tICdyeGpzJztcbmltcG9ydCB7ZmlsdGVyLCBzd2l0Y2hNYXAsIHRha2VVbnRpbCwgdGFwfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbi8qKlxuICogRGlyZWN0aXZlIHRvIGlzb2xhdGUgc2Nyb2xsaW5nLCBpLmUuIHByZXZlbnQgYm9keSBzY3JvbGwgYmVoaW5kIG1vZGFsIGRpYWxvZ1xuICogQGR5bmFtaWNcbiAqL1xuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbdHVpT3ZlcnNjcm9sbF0nLFxuICAgIHByb3ZpZGVyczogW1R1aURlc3Ryb3lTZXJ2aWNlXSxcbn0pXG5leHBvcnQgY2xhc3MgVHVpT3ZlcnNjcm9sbERpcmVjdGl2ZSB7XG4gICAgQElucHV0KCd0dWlPdmVyc2Nyb2xsJylcbiAgICBtb2RlID0gVHVpT3ZlcnNjcm9sbE1vZGUuU2Nyb2xsO1xuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIEBJbmplY3QoRWxlbWVudFJlZikge25hdGl2ZUVsZW1lbnR9OiBFbGVtZW50UmVmPEhUTUxFbGVtZW50PixcbiAgICAgICAgQEluamVjdChOZ1pvbmUpIG5nWm9uZTogTmdab25lLFxuICAgICAgICBASW5qZWN0KFR1aURlc3Ryb3lTZXJ2aWNlKSBkZXN0cm95JDogT2JzZXJ2YWJsZTx2b2lkPixcbiAgICApIHtcbiAgICAgICAgdHlwZWRGcm9tRXZlbnQobmF0aXZlRWxlbWVudCwgJ3doZWVsJywge3Bhc3NpdmU6IGZhbHNlfSlcbiAgICAgICAgICAgIC5waXBlKFxuICAgICAgICAgICAgICAgIGZpbHRlcigoKSA9PiB0aGlzLmVuYWJsZWQpLFxuICAgICAgICAgICAgICAgIHRha2VVbnRpbChkZXN0cm95JCksXG4gICAgICAgICAgICAgICAgdHVpWm9uZU9wdGltaXplZChuZ1pvbmUpLFxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgLnN1YnNjcmliZShldmVudCA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzRXZlbnQoXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgICAgICAgICAhIWV2ZW50LmRlbHRhWSxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuZGVsdGFZID8gZXZlbnQuZGVsdGFZIDwgMCA6IGV2ZW50LmRlbHRhWCA8IDAsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIHR5cGVkRnJvbUV2ZW50KG5hdGl2ZUVsZW1lbnQsICd0b3VjaHN0YXJ0JylcbiAgICAgICAgICAgIC5waXBlKFxuICAgICAgICAgICAgICAgIHN3aXRjaE1hcCgoe3RvdWNoZXN9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB7Y2xpZW50WCwgY2xpZW50WX0gPSB0b3VjaGVzWzBdO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZGVsdGFYID0gMDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRlbHRhWSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGxldCB2ZXJ0aWNhbDogYm9vbGVhbjtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRGcm9tRXZlbnQobmF0aXZlRWxlbWVudCwgJ3RvdWNobW92ZScsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhc3NpdmU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICB9KS5waXBlKFxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyKCgpID0+IHRoaXMuZW5hYmxlZCksXG4gICAgICAgICAgICAgICAgICAgICAgICB0dWlab25lT3B0aW1pemVkKG5nWm9uZSksXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXAoZXZlbnQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgdG8gaGF2ZSBpdCBpbiB0YXAgaW5zdGVhZCBvZiBzdWJzY3JpYmUgZHVlIHRvIHZhcmlhYmxlcyBpbiBjbG9zdXJlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hhbmdlZFRvdWNoID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWx0YVggPSBjbGllbnRYIC0gY2hhbmdlZFRvdWNoLmNsaWVudFg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGFZID0gY2xpZW50WSAtIGNoYW5nZWRUb3VjaC5jbGllbnRZO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudFggPSBjaGFuZ2VkVG91Y2guY2xpZW50WDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGllbnRZID0gY2hhbmdlZFRvdWNoLmNsaWVudFk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmVydGljYWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZXJ0aWNhbCA9IE1hdGguYWJzKGRlbHRhWSkgPiBNYXRoLmFicyhkZWx0YVgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc0V2ZW50KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVydGljYWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlcnRpY2FsID8gZGVsdGFZIDwgMCA6IGRlbHRhWCA8IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIHRha2VVbnRpbChkZXN0cm95JCksXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAuc3Vic2NyaWJlKCk7XG4gICAgfVxuXG4gICAgZ2V0IGVuYWJsZWQoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGUgIT09IFR1aU92ZXJzY3JvbGxNb2RlLk5vbmU7XG4gICAgfVxuXG4gICAgQEhvc3RCaW5kaW5nKCdzdHlsZS5vdmVyc2Nyb2xsQmVoYXZpb3InKVxuICAgIGdldCBvdmVyc2Nyb2xsQmVoYXZpb3IoKTogJ2NvbnRhaW4nIHwgbnVsbCB7XG4gICAgICAgIHJldHVybiB0aGlzLmVuYWJsZWQgPyAnY29udGFpbicgOiBudWxsO1xuICAgIH1cblxuICAgIHByaXZhdGUgcHJvY2Vzc0V2ZW50KFxuICAgICAgICBldmVudDogVHVpRXZlbnRXaXRoPEV2ZW50LCBIVE1MRWxlbWVudD4sXG4gICAgICAgIHZlcnRpY2FsOiBib29sZWFuLFxuICAgICAgICBuZWdhdGl2ZTogYm9vbGVhbixcbiAgICApIHtcbiAgICAgICAgY29uc3Qge3RhcmdldCwgY3VycmVudFRhcmdldCwgY2FuY2VsYWJsZX0gPSBldmVudDtcblxuICAgICAgICBpZiAoIWNhbmNlbGFibGUgfHwgISh0YXJnZXQgaW5zdGFuY2VvZiBFbGVtZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhpcyBpcyBhbGwgd2hhdCdzIG5lZWRlZCBpbiBDaHJvbWUvRmlyZWZveCB0aGFua3MgdG8gQ1NTIG92ZXJzY3JvbGwtYmVoYXZpb3JcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgdGhpcy5tb2RlID09PSBUdWlPdmVyc2Nyb2xsTW9kZS5BbGwgJiZcbiAgICAgICAgICAgICgodmVydGljYWwgJiYgIWN1cnJlbnRUYXJnZXQuY29udGFpbnMoZ2V0U2Nyb2xsUGFyZW50KHRhcmdldCkpKSB8fFxuICAgICAgICAgICAgICAgICghdmVydGljYWwgJiYgIWN1cnJlbnRUYXJnZXQuY29udGFpbnMoZ2V0U2Nyb2xsUGFyZW50KHRhcmdldCwgZmFsc2UpKSkpXG4gICAgICAgICkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhpcyBpcyBTYWZhcmkvSUUvRWRnZSBmYWxsYmFja1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICB2ZXJ0aWNhbCAmJlxuICAgICAgICAgICAgKChuZWdhdGl2ZSAmJiAhY2FuU2Nyb2xsKHRhcmdldCwgY3VycmVudFRhcmdldCwgdHJ1ZSwgZmFsc2UpKSB8fFxuICAgICAgICAgICAgICAgICghbmVnYXRpdmUgJiYgIWNhblNjcm9sbCh0YXJnZXQsIGN1cnJlbnRUYXJnZXQsIHRydWUsIHRydWUpKSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXG4gICAgICAgICAgICAhdmVydGljYWwgJiZcbiAgICAgICAgICAgICgobmVnYXRpdmUgJiYgIWNhblNjcm9sbCh0YXJnZXQsIGN1cnJlbnRUYXJnZXQsIGZhbHNlLCBmYWxzZSkpIHx8XG4gICAgICAgICAgICAgICAgKCFuZWdhdGl2ZSAmJiAhY2FuU2Nyb2xsKHRhcmdldCwgY3VycmVudFRhcmdldCwgZmFsc2UsIHRydWUpKSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgfVxufVxuIl19