import { __decorate, __extends, __param, __read, __spread } from "tslib";
import { ElementRef, Inject, Injectable } from '@angular/core';
import { WINDOW } from '@ng-web-apis/common';
import { typedFromEvent } from '@taiga-ui/cdk/observables';
import { defer, merge, Observable } from 'rxjs';
/**
 * Service that subscribes to scroll events of all parent elements
 */
// Ambient type cannot be used without dynamic https://github.com/angular/angular/issues/23395
// @dynamic
var TuiParentsScrollService = /** @class */ (function (_super) {
    __extends(TuiParentsScrollService, _super);
    function TuiParentsScrollService(_a, windowRef) {
        var nativeElement = _a.nativeElement;
        var _this = _super.call(this, function (subscriber) { return _this.callback$.subscribe(subscriber); }) || this;
        _this.callback$ = defer(function () {
            var eventTargets = [windowRef, nativeElement];
            while (nativeElement.parentElement) {
                nativeElement = nativeElement.parentElement;
                eventTargets.push(nativeElement);
            }
            return merge.apply(void 0, __spread(eventTargets.map(function (element) {
                return typedFromEvent(element, 'scroll');
            })));
        });
        return _this;
    }
    TuiParentsScrollService.ctorParameters = function () { return [
        { type: ElementRef, decorators: [{ type: Inject, args: [ElementRef,] }] },
        { type: Window, decorators: [{ type: Inject, args: [WINDOW,] }] }
    ]; };
    TuiParentsScrollService = __decorate([
        Injectable(),
        __param(0, Inject(ElementRef)),
        __param(1, Inject(WINDOW))
    ], TuiParentsScrollService);
    return TuiParentsScrollService;
}(Observable));
export { TuiParentsScrollService };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFyZW50cy1zY3JvbGwuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0B0YWlnYS11aS9jZGsvc2VydmljZXMvIiwic291cmNlcyI6WyJwYXJlbnRzLXNjcm9sbC5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQUMsVUFBVSxFQUFFLE1BQU0sRUFBRSxVQUFVLEVBQUMsTUFBTSxlQUFlLENBQUM7QUFDN0QsT0FBTyxFQUFDLE1BQU0sRUFBQyxNQUFNLHFCQUFxQixDQUFDO0FBQzNDLE9BQU8sRUFBQyxjQUFjLEVBQUMsTUFBTSwyQkFBMkIsQ0FBQztBQUN6RCxPQUFPLEVBQUMsS0FBSyxFQUFFLEtBQUssRUFBRSxVQUFVLEVBQUMsTUFBTSxNQUFNLENBQUM7QUFFOUM7O0dBRUc7QUFDSCw4RkFBOEY7QUFDOUYsV0FBVztBQUVYO0lBQTZDLDJDQUFpQjtJQUcxRCxpQ0FDd0IsRUFBb0MsRUFDeEMsU0FBaUI7WUFEWixnQ0FBYTtRQUR0QyxZQUlJLGtCQUFNLFVBQUEsVUFBVSxJQUFJLE9BQUEsS0FBSSxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUMsVUFBVSxDQUFDLEVBQXBDLENBQW9DLENBQUMsU0FnQjVEO1FBZEcsS0FBSSxDQUFDLFNBQVMsR0FBRyxLQUFLLENBQUM7WUFDbkIsSUFBTSxZQUFZLEdBQTRCLENBQUMsU0FBUyxFQUFFLGFBQWEsQ0FBQyxDQUFDO1lBRXpFLE9BQU8sYUFBYSxDQUFDLGFBQWEsRUFBRTtnQkFDaEMsYUFBYSxHQUFHLGFBQWEsQ0FBQyxhQUFhLENBQUM7Z0JBQzVDLFlBQVksQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUM7YUFDcEM7WUFFRCxPQUFPLEtBQUssd0JBQ0wsWUFBWSxDQUFDLEdBQUcsQ0FBb0IsVUFBQSxPQUFPO2dCQUMxQyxPQUFBLGNBQWMsQ0FBQyxPQUFPLEVBQUUsUUFBUSxDQUFDO1lBQWpDLENBQWlDLENBQ3BDLEdBQ0g7UUFDTixDQUFDLENBQUMsQ0FBQzs7SUFDUCxDQUFDOztnQkFuQndDLFVBQVUsdUJBQTlDLE1BQU0sU0FBQyxVQUFVO2dCQUNTLE1BQU0sdUJBQWhDLE1BQU0sU0FBQyxNQUFNOztJQUxULHVCQUF1QjtRQURuQyxVQUFVLEVBQUU7UUFLSixXQUFBLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQTtRQUNsQixXQUFBLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQTtPQUxWLHVCQUF1QixDQXdCbkM7SUFBRCw4QkFBQztDQUFBLEFBeEJELENBQTZDLFVBQVUsR0F3QnREO1NBeEJZLHVCQUF1QiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7RWxlbWVudFJlZiwgSW5qZWN0LCBJbmplY3RhYmxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7V0lORE9XfSBmcm9tICdAbmctd2ViLWFwaXMvY29tbW9uJztcbmltcG9ydCB7dHlwZWRGcm9tRXZlbnR9IGZyb20gJ0B0YWlnYS11aS9jZGsvb2JzZXJ2YWJsZXMnO1xuaW1wb3J0IHtkZWZlciwgbWVyZ2UsIE9ic2VydmFibGV9IGZyb20gJ3J4anMnO1xuXG4vKipcbiAqIFNlcnZpY2UgdGhhdCBzdWJzY3JpYmVzIHRvIHNjcm9sbCBldmVudHMgb2YgYWxsIHBhcmVudCBlbGVtZW50c1xuICovXG4vLyBBbWJpZW50IHR5cGUgY2Fubm90IGJlIHVzZWQgd2l0aG91dCBkeW5hbWljIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvaXNzdWVzLzIzMzk1XG4vLyBAZHluYW1pY1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFR1aVBhcmVudHNTY3JvbGxTZXJ2aWNlIGV4dGVuZHMgT2JzZXJ2YWJsZTxFdmVudD4ge1xuICAgIHByaXZhdGUgcmVhZG9ubHkgY2FsbGJhY2skOiBPYnNlcnZhYmxlPEV2ZW50PjtcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBASW5qZWN0KEVsZW1lbnRSZWYpIHtuYXRpdmVFbGVtZW50fTogRWxlbWVudFJlZjxFbGVtZW50PixcbiAgICAgICAgQEluamVjdChXSU5ET1cpIHdpbmRvd1JlZjogV2luZG93LFxuICAgICkge1xuICAgICAgICBzdXBlcihzdWJzY3JpYmVyID0+IHRoaXMuY2FsbGJhY2skLnN1YnNjcmliZShzdWJzY3JpYmVyKSk7XG5cbiAgICAgICAgdGhpcy5jYWxsYmFjayQgPSBkZWZlcigoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBldmVudFRhcmdldHM6IEFycmF5PEVsZW1lbnQgfCBXaW5kb3c+ID0gW3dpbmRvd1JlZiwgbmF0aXZlRWxlbWVudF07XG5cbiAgICAgICAgICAgIHdoaWxlIChuYXRpdmVFbGVtZW50LnBhcmVudEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBuYXRpdmVFbGVtZW50ID0gbmF0aXZlRWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICAgICAgICAgICAgICAgIGV2ZW50VGFyZ2V0cy5wdXNoKG5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbWVyZ2U8RXZlbnQ+KFxuICAgICAgICAgICAgICAgIC4uLmV2ZW50VGFyZ2V0cy5tYXA8T2JzZXJ2YWJsZTxFdmVudD4+KGVsZW1lbnQgPT5cbiAgICAgICAgICAgICAgICAgICAgdHlwZWRGcm9tRXZlbnQoZWxlbWVudCwgJ3Njcm9sbCcpLFxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICB9XG59XG4iXX0=