import { __decorate, __param } from 'tslib';
import { EventEmitter, Input, Output, HostBinding, Directive, ChangeDetectorRef, Inject, Injectable } from '@angular/core';
import { NgModel, NgControl } from '@angular/forms';
import { tuiAssert } from '@taiga-ui/cdk/classes';
import { EMPTY_FUNCTION } from '@taiga-ui/cdk/constants';
import { tuiDefaultProp } from '@taiga-ui/cdk/decorators';
import { fallbackValue } from '@taiga-ui/cdk/utils/miscellaneous';
import { Subject, merge, Observable, BehaviorSubject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import { TuiIdService } from '@taiga-ui/cdk/services';

var AbstractTuiInteractive_1;
const TUI = 'tui_interactive_';
/**
 * The most basic class for interactive components
 */
let AbstractTuiInteractive = AbstractTuiInteractive_1 = class AbstractTuiInteractive {
    constructor() {
        this.hovered = false;
        this.pressed = false;
        this.focusVisible = false;
        this.pseudoHovered = null;
        this.pseudoPressed = null;
        this.pseudoFocused = null;
        /**
         * Determines if component is focusable with keyboard.
         */
        this.focusable = true;
        this.nativeId = '';
        /**
         * Emits 'true' on focus and 'false' on blur.
         */
        this.focusedChange = new EventEmitter();
        this.pressedChange = new EventEmitter();
        this.hoveredChange = new EventEmitter();
        this.focusVisibleChange = new EventEmitter();
        this.autoIdString = `${TUI}${AbstractTuiInteractive_1.autoId++}${Date.now()}`;
    }
    get computedDisabled() {
        return this.disabled;
    }
    get computedHovered() {
        return !this.computedDisabled && fallbackValue(this.pseudoHovered, this.hovered);
    }
    get computedPressed() {
        return !this.computedDisabled && fallbackValue(this.pseudoPressed, this.pressed);
    }
    get computedFocusable() {
        return !this.computedDisabled && (this.focusable || this.focused);
    }
    get computedFocused() {
        return !this.computedDisabled && fallbackValue(this.pseudoFocused, this.focused);
    }
    get computedFocusVisible() {
        return (!this.computedDisabled && fallbackValue(this.pseudoFocused, this.focusVisible));
    }
    get id() {
        return !!this.nativeId ? this.nativeId : this.autoIdString;
    }
    updateHovered(hovered) {
        if (this.hovered === hovered) {
            return;
        }
        this.hovered = hovered;
        this.hoveredChange.emit(hovered);
    }
    updatePressed(pressed) {
        if (this.pressed === pressed) {
            return;
        }
        this.pressed = pressed;
        this.pressedChange.emit(pressed);
    }
    updateFocused(focused) {
        this.focusedChange.emit(focused);
    }
    updateFocusVisible(focusVisible) {
        if (this.focusVisible === focusVisible) {
            return;
        }
        this.focusVisible = focusVisible;
        this.focusVisibleChange.emit(focusVisible);
    }
};
AbstractTuiInteractive.autoId = 0;
__decorate([
    Input(),
    tuiDefaultProp()
], AbstractTuiInteractive.prototype, "pseudoHovered", void 0);
__decorate([
    Input(),
    tuiDefaultProp()
], AbstractTuiInteractive.prototype, "pseudoPressed", void 0);
__decorate([
    Input(),
    tuiDefaultProp()
], AbstractTuiInteractive.prototype, "pseudoFocused", void 0);
__decorate([
    Input(),
    tuiDefaultProp()
], AbstractTuiInteractive.prototype, "focusable", void 0);
__decorate([
    Input(),
    tuiDefaultProp()
], AbstractTuiInteractive.prototype, "nativeId", void 0);
__decorate([
    Output()
], AbstractTuiInteractive.prototype, "focusedChange", void 0);
__decorate([
    Output()
], AbstractTuiInteractive.prototype, "pressedChange", void 0);
__decorate([
    Output()
], AbstractTuiInteractive.prototype, "hoveredChange", void 0);
__decorate([
    Output()
], AbstractTuiInteractive.prototype, "focusVisibleChange", void 0);
__decorate([
    HostBinding('class._disabled')
], AbstractTuiInteractive.prototype, "computedDisabled", null);
__decorate([
    HostBinding('class._hovered')
], AbstractTuiInteractive.prototype, "computedHovered", null);
__decorate([
    HostBinding('class._pressed')
], AbstractTuiInteractive.prototype, "computedPressed", null);
__decorate([
    HostBinding('class._focused')
], AbstractTuiInteractive.prototype, "computedFocused", null);
__decorate([
    HostBinding('class._focus-visible')
], AbstractTuiInteractive.prototype, "computedFocusVisible", null);
AbstractTuiInteractive = AbstractTuiInteractive_1 = __decorate([
    Directive()
], AbstractTuiInteractive);

/**
 * Basic ControlValueAccessor class to build form components upon
 */
let AbstractTuiControl = class AbstractTuiControl extends AbstractTuiInteractive {
    constructor(ngControl, changeDetectorRef) {
        super();
        this.ngControl = ngControl;
        this.changeDetectorRef = changeDetectorRef;
        this.onTouched = EMPTY_FUNCTION;
        this.onChange = EMPTY_FUNCTION;
        this.fallbackValue = this.getFallbackValue();
        this.destroy$ = new Subject();
        this.readOnly = false;
        this.pseudoInvalid = null;
        if (this.ngControl === null) {
            tuiAssert.assert(false, `NgControl not injected in ${this.constructor.name}!\n`, 'Use [(ngModel)] or [formControl] or formControlName for correct work.');
        }
        else {
            this.ngControl.valueAccessor = this;
        }
    }
    get computedInvalid() {
        return (!this.readOnly &&
            !this.disabled &&
            (this.pseudoInvalid !== null
                ? this.pseudoInvalid
                : this.touched && this.invalid));
    }
    get value() {
        return fallbackValue(this.previousInternalValue, this.fallbackValue);
    }
    get safeCurrentValue() {
        return fallbackValue(this.rawValue, this.fallbackValue);
    }
    get invalid() {
        return this.safeNgControlData(({ invalid }) => invalid, false);
    }
    get valid() {
        return this.safeNgControlData(({ valid }) => valid, false);
    }
    get touched() {
        return this.safeNgControlData(({ touched }) => touched, false);
    }
    get disabled() {
        return this.safeNgControlData(({ disabled }) => disabled, false);
    }
    get control() {
        return this.safeNgControlData(({ control }) => control, null);
    }
    get computedName() {
        return this.controlName;
    }
    get controlName() {
        return this.ngControl && this.ngControl.name;
    }
    get rawValue() {
        const { ngControl } = this;
        if (ngControl === null) {
            return undefined;
        }
        return ngControl instanceof NgModel && this.previousInternalValue === undefined
            ? ngControl.viewModel
            : ngControl.value;
    }
    ngOnInit() {
        if (!this.ngControl ||
            !this.ngControl.valueChanges ||
            !this.ngControl.statusChanges) {
            return;
        }
        merge(this.ngControl.valueChanges, this.ngControl.statusChanges)
            .pipe(takeUntil(this.destroy$))
            .subscribe(() => {
            this.refreshLocalValue(this.safeCurrentValue);
        });
    }
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
    }
    checkControlUpdate() {
        this.changeDetectorRef.markForCheck();
    }
    registerOnChange(onChange) {
        this.onChange = onChange;
    }
    registerOnTouched(onTouched) {
        this.onTouched = onTouched;
    }
    setDisabledState() {
        this.checkControlUpdate();
    }
    writeValue(value) {
        this.refreshLocalValue(this.ngControl instanceof NgModel && this.previousInternalValue === undefined
            ? this.ngControl.model
            : value);
    }
    updateFocused(focused) {
        if (!focused) {
            this.controlMarkAsTouched();
        }
        super.updateFocused(focused);
    }
    updateValue(value) {
        if (this.disabled || this.valueIdenticalComparator(this.value, value)) {
            return;
        }
        this.previousInternalValue = value;
        this.controlSetValue(value);
    }
    valueIdenticalComparator(oldValue, newValue) {
        return oldValue === newValue;
    }
    safeNgControlData(extractor, defaultFieldValue) {
        return fallbackValue(this.ngControl && extractor(this.ngControl), defaultFieldValue);
    }
    controlMarkAsTouched() {
        this.onTouched();
        this.checkControlUpdate();
    }
    controlSetValue(value) {
        this.onChange(value);
        this.checkControlUpdate();
    }
    refreshLocalValue(value) {
        this.previousInternalValue = value;
        this.checkControlUpdate();
    }
};
AbstractTuiControl.ctorParameters = () => [
    { type: NgControl },
    { type: ChangeDetectorRef }
];
__decorate([
    Input(),
    HostBinding('class._readonly'),
    tuiDefaultProp()
], AbstractTuiControl.prototype, "readOnly", void 0);
__decorate([
    Input(),
    tuiDefaultProp()
], AbstractTuiControl.prototype, "pseudoInvalid", void 0);
__decorate([
    HostBinding('class._invalid')
], AbstractTuiControl.prototype, "computedInvalid", null);
AbstractTuiControl = __decorate([
    Directive()
], AbstractTuiControl);

class TuiController {
    constructor() {
        this.change$ = new Subject();
    }
    ngOnChanges() {
        this.change$.next();
    }
}

let AbstractTuiDialogService = class AbstractTuiDialogService extends Observable {
    constructor(idService) {
        super(observer => this.dialogs$.subscribe(observer));
        this.idService = idService;
        this.dialogs$ = new BehaviorSubject([]);
    }
    open(content, options = {}) {
        return new Observable(observer => {
            const completeWith = (result) => {
                observer.next(result);
                observer.complete();
            };
            const dialog = Object.assign(Object.assign(Object.assign({}, this.defaultOptions), options), { content,
                completeWith, $implicit: observer, component: this.component, id: this.idService.generate() });
            this.dialogs$.next([...this.dialogs$.value, dialog]);
            return () => {
                this.dialogs$.next(this.dialogs$.value.filter(item => item !== dialog));
            };
        });
    }
};
AbstractTuiDialogService.ctorParameters = () => [
    { type: TuiIdService, decorators: [{ type: Inject, args: [TuiIdService,] }] }
];
AbstractTuiDialogService = __decorate([
    Injectable(),
    __param(0, Inject(TuiIdService))
], AbstractTuiDialogService);

let AbstractTuiMultipleControl = class AbstractTuiMultipleControl extends AbstractTuiControl {
    clear() {
        this.updateValue([]);
    }
    getFallbackValue() {
        return [];
    }
};
AbstractTuiMultipleControl = __decorate([
    Directive()
], AbstractTuiMultipleControl);

let AbstractTuiNullableControl = class AbstractTuiNullableControl extends AbstractTuiControl {
    getFallbackValue() {
        return null;
    }
};
AbstractTuiNullableControl = __decorate([
    Directive()
], AbstractTuiNullableControl);

/**
 * Use this abstract class to create your own toggleable themes.
 * A component extending this class must have CSS variables definitions
 * and have ViewEncapsulation set to NONE. A boolean input allows to
 * switch theme on or off.
 */
class AbstractTuiThemeSwitcher {
    constructor(documentRef) {
        this.documentRef = documentRef;
        if (this.style !== null) {
            this.addTheme();
            return;
        }
        const styles = this.documentRef.head.querySelectorAll('style');
        this.constructor.style =
            styles[styles.length - 1];
    }
    get style() {
        return this.constructor.style;
    }
    ngOnDestroy() {
        this.removeTheme();
    }
    addTheme() {
        if (this.style && !this.documentRef.head.contains(this.style)) {
            for (let i = this.style.attributes.length - 1; i >= 0; i--) {
                this.style.removeAttribute(this.style.attributes[i].name);
            }
            this.documentRef.head.appendChild(this.style);
        }
    }
    removeTheme() {
        if (this.style && this.documentRef.head.contains(this.style)) {
            this.documentRef.head.removeChild(this.style);
        }
    }
}
AbstractTuiThemeSwitcher.style = null;

/**
 * Generated bundle index. Do not edit.
 */

export { AbstractTuiControl, AbstractTuiDialogService, AbstractTuiInteractive, AbstractTuiMultipleControl, AbstractTuiNullableControl, AbstractTuiThemeSwitcher, TuiController };
//# sourceMappingURL=taiga-ui-cdk-abstract.js.map
