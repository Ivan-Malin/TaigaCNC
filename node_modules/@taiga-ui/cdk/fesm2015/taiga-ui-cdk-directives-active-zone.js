import { __decorate, __param } from 'tslib';
import { DOCUMENT } from '@angular/common';
import { ElementRef, Inject, Optional, SkipSelf, NgZone, Input, Output, Directive, NgModule } from '@angular/core';
import { WINDOW } from '@ng-web-apis/common';
import { tuiDefaultProp } from '@taiga-ui/cdk/decorators';
import { typedFromEvent, tuiZoneOptimized } from '@taiga-ui/cdk/observables';
import { getActualTarget } from '@taiga-ui/cdk/utils/dom';
import { isNativeFocused, getNativeFocused, isNativeMouseFocusable } from '@taiga-ui/cdk/utils/focus';
import { merge, of } from 'rxjs';
import { filter, mapTo, map, switchMap, take, tap, startWith, distinctUntilChanged, skip } from 'rxjs/operators';

var TuiActiveZoneDirective_1;
// @dynamic
let TuiActiveZoneDirective = TuiActiveZoneDirective_1 = class TuiActiveZoneDirective {
    constructor(element, directParentActiveZone, ngZone, windowRef, documentRef) {
        this.element = element;
        this.directParentActiveZone = directParentActiveZone;
        this.subActiveZones = [];
        this.tuiActiveZoneParent = null;
        let skipNextFocusOut = false;
        if (this.directParentActiveZone) {
            this.directParentActiveZone.addSubActiveZone(this);
        }
        this.tuiActiveZoneChange = merge(typedFromEvent(windowRef, 'focusout').pipe(filter(event => {
            const actualTarget = getActualTarget(event);
            return (!skipNextFocusOut &&
                this.contains(actualTarget) &&
                !isNativeFocused(actualTarget) &&
                isValidFocusoutEvent(event) &&
                !this.contains(event.relatedTarget));
        }), mapTo(false)), typedFromEvent(windowRef, 'focusin').pipe(map(event => this.contains(getActualTarget(event)))), typedFromEvent(windowRef, 'mousedown').pipe(filter(event => documentRef.body === event.target ||
            !isNativeFocused(getActualTarget(event))), switchMap(event => {
            const actualTarget = getActualTarget(event);
            const targetInZone = this.contains(actualTarget);
            const activeElement = getNativeFocused(documentRef);
            const focusInZone = activeElement !== null && this.contains(activeElement);
            const focusNowhere = activeElement === null || activeElement === documentRef.body;
            // If default behavior is prevented â€” focus either remained
            // where it was or it was moved manually so we just check
            // if the focused element is within the zone or target is
            // within the zone and focus is nowhere
            if (event.defaultPrevented) {
                return of(focusInZone || (focusNowhere && targetInZone));
            }
            // If mouseDown happened inside the zone and focus is outside we
            // return true if target is not focusable or wait for focusIn
            if (targetInZone && !focusInZone && actualTarget instanceof Element) {
                return !isNativeMouseFocusable(actualTarget)
                    ? of(true)
                    : typedFromEvent(windowRef, 'focusin').pipe(take(1), mapTo(targetInZone));
            }
            // If focus is in the zone we wait for the next focusOut event and
            // map it to either true or false, depending on if the mouseDown
            // target is within the zone or not
            if (focusInZone) {
                // @bad TODO: Think of a way to handle this without side-effects
                skipNextFocusOut = true;
                return typedFromEvent(windowRef, 'focusout').pipe(take(1), mapTo(targetInZone));
            }
            return of(false);
        }))).pipe(tap(() => {
            skipNextFocusOut = false;
        }), startWith(false), distinctUntilChanged(), skip(1), tuiZoneOptimized(ngZone));
    }
    set tuiActiveZoneParentSetter(zone) {
        if (this.tuiActiveZoneParent) {
            this.tuiActiveZoneParent.removeSubActiveZone(this);
        }
        if (zone) {
            zone.addSubActiveZone(this);
        }
        this.tuiActiveZoneParent = zone;
    }
    ngOnDestroy() {
        if (!!this.directParentActiveZone) {
            this.directParentActiveZone.removeSubActiveZone(this);
        }
        if (!!this.tuiActiveZoneParent) {
            this.tuiActiveZoneParent.removeSubActiveZone(this);
        }
    }
    contains(node) {
        return (!!node &&
            (this.element.nativeElement.contains(node) ||
                this.subActiveZones.some((item, index, array) => array.indexOf(item) === index && item.contains(node))));
    }
    addSubActiveZone(activeZone) {
        this.subActiveZones = [...this.subActiveZones, activeZone];
    }
    removeSubActiveZone(activeZone) {
        const index = this.subActiveZones.findIndex(item => item === activeZone);
        this.subActiveZones = [
            ...this.subActiveZones.slice(0, index),
            ...this.subActiveZones.slice(index + 1),
        ];
    }
};
TuiActiveZoneDirective.ctorParameters = () => [
    { type: ElementRef, decorators: [{ type: Inject, args: [ElementRef,] }] },
    { type: TuiActiveZoneDirective, decorators: [{ type: Inject, args: [TuiActiveZoneDirective_1,] }, { type: Optional }, { type: SkipSelf }] },
    { type: NgZone, decorators: [{ type: Inject, args: [NgZone,] }] },
    { type: Window, decorators: [{ type: Inject, args: [WINDOW,] }] },
    { type: Document, decorators: [{ type: Inject, args: [DOCUMENT,] }] }
];
__decorate([
    Input('tuiActiveZoneParent'),
    tuiDefaultProp()
], TuiActiveZoneDirective.prototype, "tuiActiveZoneParentSetter", null);
__decorate([
    Output()
], TuiActiveZoneDirective.prototype, "tuiActiveZoneChange", void 0);
TuiActiveZoneDirective = TuiActiveZoneDirective_1 = __decorate([
    Directive({
        selector: '[tuiActiveZone]:not(ng-container), [tuiActiveZoneChange]:not(ng-container), [tuiActiveZoneParent]:not(ng-container)',
        exportAs: 'tuiActiveZone',
    }),
    __param(0, Inject(ElementRef)),
    __param(1, Inject(TuiActiveZoneDirective_1)),
    __param(1, Optional()),
    __param(1, SkipSelf()),
    __param(2, Inject(NgZone)),
    __param(3, Inject(WINDOW)),
    __param(4, Inject(DOCUMENT))
], TuiActiveZoneDirective);
// Chrome workaround for triggering `focusout` event upon element removal
function isValidFocusoutEvent({ relatedTarget, sourceCapabilities, }) {
    return sourceCapabilities !== null || relatedTarget !== null;
}

let TuiActiveZoneModule = class TuiActiveZoneModule {
};
TuiActiveZoneModule = __decorate([
    NgModule({
        declarations: [TuiActiveZoneDirective],
        exports: [TuiActiveZoneDirective],
    })
], TuiActiveZoneModule);

/**
 * Generated bundle index. Do not edit.
 */

export { TuiActiveZoneDirective, TuiActiveZoneModule };
//# sourceMappingURL=taiga-ui-cdk-directives-active-zone.js.map
