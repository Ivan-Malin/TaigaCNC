import { isPresent, getOriginalArrayFromQueryList } from '@taiga-ui/cdk/utils/miscellaneous';
import { fromEvent, merge, concat, pipe, timer, Observable } from 'rxjs';
import { first, map, endWith, takeWhile, repeat, switchMapTo, mapTo, startWith, distinctUntilChanged, shareReplay, take, filter, ignoreElements, withLatestFrom, tap } from 'rxjs/operators';
import { isNativeFocused } from '@taiga-ui/cdk/utils/focus';

function typedFromEvent(target, event, options = {}) {
    return fromEvent(target, event, options);
}

/**
 * Letting go of the mouse after it was pressed
 * @param target
 */
function mouseDragFinishFrom(target) {
    return merge(typedFromEvent(target, 'mouseup'), typedFromEvent(target, 'dragend'));
}

class TuiDragState {
    constructor(stage, event) {
        this.stage = stage;
        this.event = event;
    }
}
function dragAndDropFrom(element) {
    const { ownerDocument } = element;
    if (!ownerDocument) {
        throw new Error('element does not have ownerDocument');
    }
    return concat(typedFromEvent(element, 'mousedown').pipe(first(), map(event => new TuiDragState(0 /* Start */, event))), merge(typedFromEvent(ownerDocument, 'mousemove').pipe(map(event => new TuiDragState(1 /* Continues */, event))), mouseDragFinishFrom(ownerDocument).pipe(first(), map(event => new TuiDragState(2 /* End */, event)), endWith(null))).pipe(takeWhile(isPresent))).pipe(repeat());
}

/**
 * Operator to set lifespan after which current value is considered obsolete
 */
function tuiIsAlive(lifespan = 0) {
    return pipe(switchMapTo(timer(lifespan).pipe(mapTo(false), startWith(true))), distinctUntilChanged());
}

let documentMouseUpIsAlive$;
let documentMouseDownIsAlive$;
function focusVisibleObservable(element) {
    const elementBlur$ = typedFromEvent(element, 'blur');
    const { ownerDocument } = element;
    if (!ownerDocument) {
        throw new Error('element does not have ownerDocument');
    }
    if (!documentMouseDownIsAlive$ || !documentMouseUpIsAlive$) {
        documentMouseUpIsAlive$ = typedFromEvent(ownerDocument, 'mouseup', {
            capture: true,
        }).pipe(tuiIsAlive(), startWith(false), shareReplay(1));
        documentMouseDownIsAlive$ = typedFromEvent(ownerDocument, 'mousedown', {
            capture: true,
        }).pipe(tuiIsAlive(), startWith(false), shareReplay(1));
    }
    return merge(
    // focus events excluding ones that came right after mouse action
    concat(typedFromEvent(element, 'focus').pipe(take(1)), 
    // filtering out blur events when element remains focused so that we ignore browser tab focus loss
    elementBlur$.pipe(filter(() => !isNativeFocused(element)), take(1), ignoreElements())).pipe(repeat(), withLatestFrom(documentMouseDownIsAlive$, documentMouseUpIsAlive$, (_event, elementActual, documentActual) => elementActual || documentActual), filter(isUserFocus => !isUserFocus))).pipe(switchMapTo(elementBlur$.pipe(mapTo(false), take(1), startWith(true))), distinctUntilChanged());
}

/**
 * Converts changes observable of a QueryList to an Observable of arrays
 */
function itemsQueryListObservable(queryList) {
    return queryList.changes.pipe(map(() => getOriginalArrayFromQueryList(queryList)), startWith(getOriginalArrayFromQueryList(queryList)));
}

function mustBePresent() {
    return map(value => {
        if (!isPresent(value)) {
            throw new Error('Value must present');
        }
        return value;
    });
}

function pressedObservable(element) {
    const { ownerDocument } = element;
    if (!ownerDocument) {
        throw new Error('element does not have ownerDocument');
    }
    return typedFromEvent(element, 'mousedown').pipe(filter(({ isTrusted }) => isTrusted), switchMapTo(mouseDragFinishFrom(ownerDocument).pipe(mapTo(false), take(1), startWith(true))));
}

function preventDefault() {
    return tap(e => {
        e.preventDefault();
    });
}

/**
 * Turns AbstractControl/Abstract-control-directive valueChanges into ReplaySubject(1)
 */
function tuiReplayedValueChangesFrom(control) {
    return new Observable(subscriber => {
        if (!control.valueChanges) {
            throw new Error('Control does not have valueChanges');
        }
        control.valueChanges.pipe(startWith(control.value)).subscribe(subscriber);
    });
}

function watch(changeDetectorRef) {
    return tap(() => {
        changeDetectorRef.markForCheck();
    });
}

class TuiZonefreeOperator {
    constructor(ngZone) {
        this.ngZone = ngZone;
    }
    call(observer, source) {
        return this.ngZone.runOutsideAngular(() => source.subscribe(observer));
    }
}
function tuiZonefull(ngZone) {
    return source => new Observable(subscriber => source.subscribe({
        next: value => ngZone.run(() => subscriber.next(value)),
        error: error => ngZone.run(() => subscriber.error(error)),
        complete: () => ngZone.run(() => subscriber.complete()),
    }));
}
function tuiZonefree(ngZone) {
    return source => source.lift(new TuiZonefreeOperator(ngZone));
}
function tuiZoneOptimized(ngZone) {
    return pipe(tuiZonefree(ngZone), tuiZonefull(ngZone));
}

/**
 * Generated bundle index. Do not edit.
 */

export { TuiDragState, dragAndDropFrom, focusVisibleObservable, itemsQueryListObservable, mouseDragFinishFrom, mustBePresent, pressedObservable, preventDefault, tuiIsAlive, tuiReplayedValueChangesFrom, tuiZoneOptimized, tuiZonefree, tuiZonefull, typedFromEvent, watch };
//# sourceMappingURL=taiga-ui-cdk-observables.js.map
