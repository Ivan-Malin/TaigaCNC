import { tuiAssert } from '@taiga-ui/cdk/classes';

/**
 * Clamps a value between two inclusive limits
 *
 * @param value
 * @param min lower limit
 * @param max upper limit
 */
function clamp(value, min, max) {
    tuiAssert.assert(!isNaN(value));
    tuiAssert.assert(!isNaN(min));
    tuiAssert.assert(!isNaN(max));
    tuiAssert.assert(max >= min);
    return Math.min(max, Math.max(min, value));
}

/**
 * Checks if the value is in range
 *
 * @param value
 * @param fromInclude lower inclusive limit
 * @param toExclude upper exclusive limit
 */
function inRange(value, fromInclude, toExclude) {
    tuiAssert.assert(!isNaN(value));
    tuiAssert.assert(!isNaN(fromInclude));
    tuiAssert.assert(!isNaN(toExclude));
    tuiAssert.assert(fromInclude < toExclude);
    return value >= fromInclude && value < toExclude;
}

/**
 * Normalizes any number to an integer within inclusive range
 *
 * @param value
 * @param min lower inclusive integer
 * @param max upper inclusive integer
 * @return an integer between min and max inclusive
 */
function normalizeToIntNumber(value, min, max) {
    tuiAssert.assert(Number.isInteger(min));
    tuiAssert.assert(Number.isInteger(max));
    tuiAssert.assert(min <= max);
    if (isNaN(value) || value <= min) {
        return min;
    }
    if (value >= max) {
        return max;
    }
    return Math.round(value);
}

/**
 * Rounds a number to the closest value in a fixed discrete series
 *
 * @param value
 * @param quantum series step
 */
function quantize(value, quantum) {
    tuiAssert.assert(Number.isFinite(value));
    tuiAssert.assert(Number.isFinite(quantum));
    tuiAssert.assert(quantum > 0);
    const remainder = value % quantum;
    return remainder < quantum / 2 ? value - remainder : value + quantum - remainder;
}

const MAX_PRECISION = 292;
function round(value, precision = 0) {
    return calculate(value, precision, Math.round);
}
function ceil(value, precision = 0) {
    return calculate(value, precision, Math.ceil);
}
function floor(value, precision = 0) {
    return calculate(value, precision, Math.floor);
}
/**
 * Rounding number to the set precision
 *
 * @param value
 * @param precision number of digits in a float part
 * @param func rounding function (round, floor, ceil)
 */
function calculate(value, precision, func) {
    if (value === Infinity) {
        return value;
    }
    tuiAssert.assert(!isNaN(value), 'Value must be number');
    tuiAssert.assert(Number.isInteger(precision), 'Precision must be integer');
    precision = Math.min(precision, MAX_PRECISION);
    const pair = `${value}e`.split('e');
    const tempValue = func(Number(`${pair[0]}e${Number(pair[1]) + precision}`));
    const processedPair = `${tempValue}e`.split('e');
    return Number(`${processedPair[0]}e${Number(processedPair[1]) - precision}`);
}

/**
 * Calculates sum of any number of passed arguments
 */
function sum(...args) {
    return args.reduce((a, b) => a + b, 0);
}

/**
 * Converts angle in degrees to radians
 */
function toRadians(deg) {
    return (deg * Math.PI) / 180;
}

/**
 * Generated bundle index. Do not edit.
 */

export { ceil, clamp, floor, inRange, normalizeToIntNumber, quantize, round, sum, toRadians };
//# sourceMappingURL=taiga-ui-cdk-utils-math.js.map
