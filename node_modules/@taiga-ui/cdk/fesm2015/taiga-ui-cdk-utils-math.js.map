{"version":3,"file":"taiga-ui-cdk-utils-math.js","sources":["ng://@taiga-ui/cdk/utils/math/clamp.ts","ng://@taiga-ui/cdk/utils/math/in-range.ts","ng://@taiga-ui/cdk/utils/math/normalize-to-int-number.ts","ng://@taiga-ui/cdk/utils/math/quantize.ts","ng://@taiga-ui/cdk/utils/math/round.ts","ng://@taiga-ui/cdk/utils/math/sum.ts","ng://@taiga-ui/cdk/utils/math/to-radians.ts","ng://@taiga-ui/cdk/utils/math/taiga-ui-cdk-utils-math.ts"],"sourcesContent":["import {tuiAssert} from '@taiga-ui/cdk/classes';\n\n/**\n * Clamps a value between two inclusive limits\n *\n * @param value\n * @param min lower limit\n * @param max upper limit\n */\nexport function clamp(value: number, min: number, max: number): number {\n    tuiAssert.assert(!isNaN(value));\n    tuiAssert.assert(!isNaN(min));\n    tuiAssert.assert(!isNaN(max));\n    tuiAssert.assert(max >= min);\n\n    return Math.min(max, Math.max(min, value));\n}\n","import {tuiAssert} from '@taiga-ui/cdk/classes';\n\n/**\n * Checks if the value is in range\n *\n * @param value\n * @param fromInclude lower inclusive limit\n * @param toExclude upper exclusive limit\n */\nexport function inRange(value: number, fromInclude: number, toExclude: number): boolean {\n    tuiAssert.assert(!isNaN(value));\n    tuiAssert.assert(!isNaN(fromInclude));\n    tuiAssert.assert(!isNaN(toExclude));\n    tuiAssert.assert(fromInclude < toExclude);\n\n    return value >= fromInclude && value < toExclude;\n}\n","import {tuiAssert} from '@taiga-ui/cdk/classes';\n\n/**\n * Normalizes any number to an integer within inclusive range\n *\n * @param value\n * @param min lower inclusive integer\n * @param max upper inclusive integer\n * @return an integer between min and max inclusive\n */\nexport function normalizeToIntNumber(value: number, min: number, max: number): number {\n    tuiAssert.assert(Number.isInteger(min));\n    tuiAssert.assert(Number.isInteger(max));\n    tuiAssert.assert(min <= max);\n\n    if (isNaN(value) || value <= min) {\n        return min;\n    }\n\n    if (value >= max) {\n        return max;\n    }\n\n    return Math.round(value);\n}\n","import {tuiAssert} from '@taiga-ui/cdk/classes';\n\n/**\n * Rounds a number to the closest value in a fixed discrete series\n *\n * @param value\n * @param quantum series step\n */\nexport function quantize(value: number, quantum: number): number {\n    tuiAssert.assert(Number.isFinite(value));\n    tuiAssert.assert(Number.isFinite(quantum));\n    tuiAssert.assert(quantum > 0);\n\n    const remainder = value % quantum;\n\n    return remainder < quantum / 2 ? value - remainder : value + quantum - remainder;\n}\n","import {tuiAssert} from '@taiga-ui/cdk/classes';\n\nconst MAX_PRECISION = 292;\n\nexport function round(value: number, precision: number = 0): number {\n    return calculate(value, precision, Math.round);\n}\n\nexport function ceil(value: number, precision: number = 0): number {\n    return calculate(value, precision, Math.ceil);\n}\n\nexport function floor(value: number, precision: number = 0): number {\n    return calculate(value, precision, Math.floor);\n}\n\n/**\n * Rounding number to the set precision\n *\n * @param value\n * @param precision number of digits in a float part\n * @param func rounding function (round, floor, ceil)\n */\nfunction calculate(\n    value: number,\n    precision: number,\n    func: (x: number) => number,\n): number {\n    if (value === Infinity) {\n        return value;\n    }\n\n    tuiAssert.assert(!isNaN(value), 'Value must be number');\n    tuiAssert.assert(Number.isInteger(precision), 'Precision must be integer');\n\n    precision = Math.min(precision, MAX_PRECISION);\n\n    const pair = `${value}e`.split('e');\n    const tempValue = func(Number(`${pair[0]}e${Number(pair[1]) + precision}`));\n    const processedPair = `${tempValue}e`.split('e');\n\n    return Number(`${processedPair[0]}e${Number(processedPair[1]) - precision}`);\n}\n","/**\n * Calculates sum of any number of passed arguments\n */\nexport function sum(...args: number[]): number {\n    return args.reduce((a, b) => a + b, 0);\n}\n","/**\n * Converts angle in degrees to radians\n */\nexport function toRadians(deg: number): number {\n    return (deg * Math.PI) / 180;\n}\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],"names":[],"mappings":"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"}