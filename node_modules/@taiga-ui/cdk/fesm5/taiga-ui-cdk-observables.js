import { isPresent, getOriginalArrayFromQueryList } from '@taiga-ui/cdk/utils/miscellaneous';
import { fromEvent, merge, concat, pipe, timer, Observable } from 'rxjs';
import { first, map, endWith, takeWhile, repeat, switchMapTo, mapTo, startWith, distinctUntilChanged, shareReplay, take, filter, ignoreElements, withLatestFrom, tap } from 'rxjs/operators';
import { isNativeFocused } from '@taiga-ui/cdk/utils/focus';

function typedFromEvent(target, event, options) {
    if (options === void 0) { options = {}; }
    return fromEvent(target, event, options);
}

/**
 * Letting go of the mouse after it was pressed
 * @param target
 */
function mouseDragFinishFrom(target) {
    return merge(typedFromEvent(target, 'mouseup'), typedFromEvent(target, 'dragend'));
}

var TuiDragState = /** @class */ (function () {
    function TuiDragState(stage, event) {
        this.stage = stage;
        this.event = event;
    }
    return TuiDragState;
}());
function dragAndDropFrom(element) {
    var ownerDocument = element.ownerDocument;
    if (!ownerDocument) {
        throw new Error('element does not have ownerDocument');
    }
    return concat(typedFromEvent(element, 'mousedown').pipe(first(), map(function (event) { return new TuiDragState(0 /* Start */, event); })), merge(typedFromEvent(ownerDocument, 'mousemove').pipe(map(function (event) { return new TuiDragState(1 /* Continues */, event); })), mouseDragFinishFrom(ownerDocument).pipe(first(), map(function (event) { return new TuiDragState(2 /* End */, event); }), endWith(null))).pipe(takeWhile(isPresent))).pipe(repeat());
}

/**
 * Operator to set lifespan after which current value is considered obsolete
 */
function tuiIsAlive(lifespan) {
    if (lifespan === void 0) { lifespan = 0; }
    return pipe(switchMapTo(timer(lifespan).pipe(mapTo(false), startWith(true))), distinctUntilChanged());
}

var documentMouseUpIsAlive$;
var documentMouseDownIsAlive$;
function focusVisibleObservable(element) {
    var elementBlur$ = typedFromEvent(element, 'blur');
    var ownerDocument = element.ownerDocument;
    if (!ownerDocument) {
        throw new Error('element does not have ownerDocument');
    }
    if (!documentMouseDownIsAlive$ || !documentMouseUpIsAlive$) {
        documentMouseUpIsAlive$ = typedFromEvent(ownerDocument, 'mouseup', {
            capture: true,
        }).pipe(tuiIsAlive(), startWith(false), shareReplay(1));
        documentMouseDownIsAlive$ = typedFromEvent(ownerDocument, 'mousedown', {
            capture: true,
        }).pipe(tuiIsAlive(), startWith(false), shareReplay(1));
    }
    return merge(
    // focus events excluding ones that came right after mouse action
    concat(typedFromEvent(element, 'focus').pipe(take(1)), 
    // filtering out blur events when element remains focused so that we ignore browser tab focus loss
    elementBlur$.pipe(filter(function () { return !isNativeFocused(element); }), take(1), ignoreElements())).pipe(repeat(), withLatestFrom(documentMouseDownIsAlive$, documentMouseUpIsAlive$, function (_event, elementActual, documentActual) {
        return elementActual || documentActual;
    }), filter(function (isUserFocus) { return !isUserFocus; }))).pipe(switchMapTo(elementBlur$.pipe(mapTo(false), take(1), startWith(true))), distinctUntilChanged());
}

/**
 * Converts changes observable of a QueryList to an Observable of arrays
 */
function itemsQueryListObservable(queryList) {
    return queryList.changes.pipe(map(function () { return getOriginalArrayFromQueryList(queryList); }), startWith(getOriginalArrayFromQueryList(queryList)));
}

function mustBePresent() {
    return map(function (value) {
        if (!isPresent(value)) {
            throw new Error('Value must present');
        }
        return value;
    });
}

function pressedObservable(element) {
    var ownerDocument = element.ownerDocument;
    if (!ownerDocument) {
        throw new Error('element does not have ownerDocument');
    }
    return typedFromEvent(element, 'mousedown').pipe(filter(function (_a) {
        var isTrusted = _a.isTrusted;
        return isTrusted;
    }), switchMapTo(mouseDragFinishFrom(ownerDocument).pipe(mapTo(false), take(1), startWith(true))));
}

function preventDefault() {
    return tap(function (e) {
        e.preventDefault();
    });
}

/**
 * Turns AbstractControl/Abstract-control-directive valueChanges into ReplaySubject(1)
 */
function tuiReplayedValueChangesFrom(control) {
    return new Observable(function (subscriber) {
        if (!control.valueChanges) {
            throw new Error('Control does not have valueChanges');
        }
        control.valueChanges.pipe(startWith(control.value)).subscribe(subscriber);
    });
}

function watch(changeDetectorRef) {
    return tap(function () {
        changeDetectorRef.markForCheck();
    });
}

var TuiZonefreeOperator = /** @class */ (function () {
    function TuiZonefreeOperator(ngZone) {
        this.ngZone = ngZone;
    }
    TuiZonefreeOperator.prototype.call = function (observer, source) {
        return this.ngZone.runOutsideAngular(function () { return source.subscribe(observer); });
    };
    return TuiZonefreeOperator;
}());
function tuiZonefull(ngZone) {
    return function (source) {
        return new Observable(function (subscriber) {
            return source.subscribe({
                next: function (value) { return ngZone.run(function () { return subscriber.next(value); }); },
                error: function (error) { return ngZone.run(function () { return subscriber.error(error); }); },
                complete: function () { return ngZone.run(function () { return subscriber.complete(); }); },
            });
        });
    };
}
function tuiZonefree(ngZone) {
    return function (source) { return source.lift(new TuiZonefreeOperator(ngZone)); };
}
function tuiZoneOptimized(ngZone) {
    return pipe(tuiZonefree(ngZone), tuiZonefull(ngZone));
}

/**
 * Generated bundle index. Do not edit.
 */

export { TuiDragState, dragAndDropFrom, focusVisibleObservable, itemsQueryListObservable, mouseDragFinishFrom, mustBePresent, pressedObservable, preventDefault, tuiIsAlive, tuiReplayedValueChangesFrom, tuiZoneOptimized, tuiZonefree, tuiZonefull, typedFromEvent, watch };
//# sourceMappingURL=taiga-ui-cdk-observables.js.map
