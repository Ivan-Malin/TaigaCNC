import { __extends, __decorate, __param, __spread, __read } from 'tslib';
import { Injectable, Inject, Renderer2, ɵɵdefineInjectable, ɵɵinject, ElementRef, ChangeDetectorRef, NgZone, Self } from '@angular/core';
import { Subject, Observable, merge, defer, fromEvent, interval, of, timer } from 'rxjs';
import { DOCUMENT } from '@angular/common';
import { TUI_DEFAULT_RENDERER } from '@taiga-ui/cdk/tokens';
import { focusVisibleObservable, watch, typedFromEvent, tuiZoneOptimized, tuiZonefree } from '@taiga-ui/cdk/observables';
import { takeUntil, switchMap, filter, take, mapTo, startWith, distinctUntilChanged, delay, map, catchError, debounceTime, tap, shareReplay } from 'rxjs/operators';
import { getActualTarget, getElementObscurers } from '@taiga-ui/cdk/utils/dom';
import { WINDOW, PERFORMANCE, ANIMATION_FRAME } from '@ng-web-apis/common';
import { POLLING_TIME, EMPTY_ARRAY } from '@taiga-ui/cdk/constants';
import { RESIZE_OBSERVER_SUPPORT, RESIZE_OPTION_BOX, ResizeObserverService } from '@ng-web-apis/resize-observer';
import { tuiAssert } from '@taiga-ui/cdk/classes';
import { clamp } from '@taiga-ui/cdk/utils/math';
import { easeInOutQuad } from '@taiga-ui/cdk/utils/miscellaneous';

/**
 * Observable abstraction over ngOnDestroy to use with takeUntil
 */
var TuiDestroyService = /** @class */ (function (_super) {
    __extends(TuiDestroyService, _super);
    function TuiDestroyService() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    TuiDestroyService.prototype.ngOnDestroy = function () {
        this.next();
        this.complete();
    };
    TuiDestroyService = __decorate([
        Injectable()
    ], TuiDestroyService);
    return TuiDestroyService;
}(Subject));

/**
 * Service to use styles with directives
 * @dynamic
 */
var TuiDirectiveStylesService = /** @class */ (function () {
    function TuiDirectiveStylesService(documentRef, renderer) {
        this.documentRef = documentRef;
        this.renderer = renderer;
    }
    TuiDirectiveStylesService.prototype.addStyle = function (styles, attribute) {
        if (this.documentRef.head.querySelector("style[" + attribute + "]")) {
            return;
        }
        var style = this.renderer.createElement('style');
        this.renderer.setProperty(style, 'textContent', styles);
        this.renderer.setAttribute(style, attribute, '');
        this.documentRef.head.appendChild(style);
    };
    TuiDirectiveStylesService.ctorParameters = function () { return [
        { type: Document, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
        { type: Renderer2, decorators: [{ type: Inject, args: [TUI_DEFAULT_RENDERER,] }] }
    ]; };
    TuiDirectiveStylesService.ɵprov = ɵɵdefineInjectable({ factory: function TuiDirectiveStylesService_Factory() { return new TuiDirectiveStylesService(ɵɵinject(DOCUMENT), ɵɵinject(TUI_DEFAULT_RENDERER)); }, token: TuiDirectiveStylesService, providedIn: "root" });
    TuiDirectiveStylesService = __decorate([
        Injectable({
            providedIn: 'root',
        }),
        __param(0, Inject(DOCUMENT)),
        __param(1, Inject(TUI_DEFAULT_RENDERER))
    ], TuiDirectiveStylesService);
    return TuiDirectiveStylesService;
}());

/**
 * Service to imitate :focus-visible
 * (https://developer.mozilla.org/en-US/docs/Web/CSS/:focus-visible)
 * in browsers that do not support it
 * @dynamic
 */
var TuiFocusVisibleService = /** @class */ (function (_super) {
    __extends(TuiFocusVisibleService, _super);
    function TuiFocusVisibleService(_a, changeDetectorRef, destroy$) {
        var nativeElement = _a.nativeElement;
        var _this = _super.call(this, function (subscriber) { return _this.focusVisible$.subscribe(subscriber); }) || this;
        _this.focusVisible$ = focusVisibleObservable(nativeElement).pipe(watch(changeDetectorRef), takeUntil(destroy$));
        return _this;
    }
    TuiFocusVisibleService.ctorParameters = function () { return [
        { type: ElementRef, decorators: [{ type: Inject, args: [ElementRef,] }] },
        { type: ChangeDetectorRef, decorators: [{ type: Inject, args: [ChangeDetectorRef,] }] },
        { type: Observable, decorators: [{ type: Inject, args: [TuiDestroyService,] }] }
    ]; };
    TuiFocusVisibleService = __decorate([
        Injectable(),
        __param(0, Inject(ElementRef)),
        __param(1, Inject(ChangeDetectorRef)),
        __param(2, Inject(TuiDestroyService))
    ], TuiFocusVisibleService);
    return TuiFocusVisibleService;
}(Observable));

// @dynamic
var TuiHoveredService = /** @class */ (function () {
    function TuiHoveredService(documentRef, ngZone) {
        this.ngZone = ngZone;
        this.documentEvents$ = merge(typedFromEvent(documentRef, 'mousemove'), typedFromEvent(documentRef, 'touchend'));
    }
    TuiHoveredService.prototype.createHovered$ = function (target, options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        return merge(typedFromEvent(target, 'mouseenter', options), typedFromEvent(target, 'touchstart', options)).pipe(switchMap(function () {
            return merge(typedFromEvent(target, 'mouseleave', options), _this.documentEvents$.pipe(filter(function (event) { return !target.contains(getActualTarget(event)); }), tuiZoneOptimized(_this.ngZone), take(1))).pipe(mapTo(false), startWith(true));
        }), distinctUntilChanged());
    };
    TuiHoveredService.ctorParameters = function () { return [
        { type: Document, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
        { type: NgZone, decorators: [{ type: Inject, args: [NgZone,] }] }
    ]; };
    TuiHoveredService.ɵprov = ɵɵdefineInjectable({ factory: function TuiHoveredService_Factory() { return new TuiHoveredService(ɵɵinject(DOCUMENT), ɵɵinject(NgZone)); }, token: TuiHoveredService, providedIn: "root" });
    TuiHoveredService = __decorate([
        Injectable({
            providedIn: 'root',
        }),
        __param(0, Inject(DOCUMENT)),
        __param(1, Inject(NgZone))
    ], TuiHoveredService);
    return TuiHoveredService;
}());

var TUI = 'tui_';
/**
 * Generates unique ids
 */
var TuiIdService = /** @class */ (function () {
    function TuiIdService() {
    }
    TuiIdService_1 = TuiIdService;
    TuiIdService.prototype.generate = function () {
        return "" + TUI + TuiIdService_1.autoId++ + Date.now();
    };
    var TuiIdService_1;
    TuiIdService.autoId = 0;
    TuiIdService.ɵprov = ɵɵdefineInjectable({ factory: function TuiIdService_Factory() { return new TuiIdService(); }, token: TuiIdService, providedIn: "root" });
    TuiIdService = TuiIdService_1 = __decorate([
        Injectable({
            providedIn: 'root',
        })
    ], TuiIdService);
    return TuiIdService;
}());

/**
 * Service that subscribes to scroll events of all parent elements
 */
// Ambient type cannot be used without dynamic https://github.com/angular/angular/issues/23395
// @dynamic
var TuiParentsScrollService = /** @class */ (function (_super) {
    __extends(TuiParentsScrollService, _super);
    function TuiParentsScrollService(_a, windowRef) {
        var nativeElement = _a.nativeElement;
        var _this = _super.call(this, function (subscriber) { return _this.callback$.subscribe(subscriber); }) || this;
        _this.callback$ = defer(function () {
            var eventTargets = [windowRef, nativeElement];
            while (nativeElement.parentElement) {
                nativeElement = nativeElement.parentElement;
                eventTargets.push(nativeElement);
            }
            return merge.apply(void 0, __spread(eventTargets.map(function (element) {
                return typedFromEvent(element, 'scroll');
            })));
        });
        return _this;
    }
    TuiParentsScrollService.ctorParameters = function () { return [
        { type: ElementRef, decorators: [{ type: Inject, args: [ElementRef,] }] },
        { type: Window, decorators: [{ type: Inject, args: [WINDOW,] }] }
    ]; };
    TuiParentsScrollService = __decorate([
        Injectable(),
        __param(0, Inject(ElementRef)),
        __param(1, Inject(WINDOW))
    ], TuiParentsScrollService);
    return TuiParentsScrollService;
}(Observable));

// @bad TODO: Consider Intersection Observer with fallback to current implementation
/**
 * Service that monitors element visibility by subscribing to scrolls
 * and polling with set interval, returns either null or an array
 * of elements that overlap given element edges
 */
// Ambient type cannot be used without dynamic https://github.com/angular/angular/issues/23395
// @dynamic
var TuiObscuredService = /** @class */ (function (_super) {
    __extends(TuiObscuredService, _super);
    function TuiObscuredService(parentsScroll$, _a, ngZone, windowRef, destroy$) {
        var nativeElement = _a.nativeElement;
        var _this = _super.call(this, function (subscriber) { return _this.obscured$.subscribe(subscriber); }) || this;
        _this.obscured$ = merge(
        // delay is added so it will not interfere with other listeners
        merge(parentsScroll$, fromEvent(windowRef, 'resize')).pipe(delay(0)), interval(POLLING_TIME)).pipe(map(function () { return getElementObscurers(nativeElement); }), startWith(null), distinctUntilChanged(), tuiZoneOptimized(ngZone), takeUntil(destroy$));
        return _this;
    }
    TuiObscuredService.ctorParameters = function () { return [
        { type: TuiParentsScrollService, decorators: [{ type: Inject, args: [TuiParentsScrollService,] }, { type: Self }] },
        { type: ElementRef, decorators: [{ type: Inject, args: [ElementRef,] }] },
        { type: NgZone, decorators: [{ type: Inject, args: [NgZone,] }] },
        { type: Window, decorators: [{ type: Inject, args: [WINDOW,] }] },
        { type: Observable, decorators: [{ type: Inject, args: [TuiDestroyService,] }] }
    ]; };
    TuiObscuredService = __decorate([
        Injectable(),
        __param(0, Inject(TuiParentsScrollService)),
        __param(0, Self()),
        __param(1, Inject(ElementRef)),
        __param(2, Inject(NgZone)),
        __param(3, Inject(WINDOW)),
        __param(4, Inject(TuiDestroyService))
    ], TuiObscuredService);
    return TuiObscuredService;
}(Observable));

// @dynamic
var TuiResizeService = /** @class */ (function (_super) {
    __extends(TuiResizeService, _super);
    function TuiResizeService(elementRef, ngZone, destroy$, support, box) {
        var _this = _super.call(this, elementRef, ngZone, support, box) || this;
        return _this.pipe(catchError(function () {
            return interval(POLLING_TIME).pipe(map(function () {
                return elementRef.nativeElement.clientWidth + " " + elementRef.nativeElement.clientHeight;
            }), distinctUntilChanged(), mapTo(EMPTY_ARRAY));
        }), takeUntil(destroy$), debounceTime(0), tuiZonefree(ngZone));
    }
    TuiResizeService.ctorParameters = function () { return [
        { type: ElementRef, decorators: [{ type: Inject, args: [ElementRef,] }] },
        { type: NgZone, decorators: [{ type: Inject, args: [NgZone,] }] },
        { type: Observable, decorators: [{ type: Inject, args: [TuiDestroyService,] }] },
        { type: Boolean, decorators: [{ type: Inject, args: [RESIZE_OBSERVER_SUPPORT,] }] },
        { type: undefined, decorators: [{ type: Inject, args: [RESIZE_OPTION_BOX,] }] }
    ]; };
    TuiResizeService = __decorate([
        Injectable(),
        __param(0, Inject(ElementRef)),
        __param(1, Inject(NgZone)),
        __param(2, Inject(TuiDestroyService)),
        __param(3, Inject(RESIZE_OBSERVER_SUPPORT)),
        __param(4, Inject(RESIZE_OPTION_BOX))
    ], TuiResizeService);
    return TuiResizeService;
}(ResizeObserverService));

var SCROLL_TIME = 300;
// @dynamic
var TuiScrollService = /** @class */ (function () {
    function TuiScrollService(performanceRef, animationFrame$) {
        this.performanceRef = performanceRef;
        this.animationFrame$ = animationFrame$;
    }
    TuiScrollService.prototype.scroll$ = function (element, scrollTop, scrollLeft, duration) {
        var _this = this;
        if (scrollLeft === void 0) { scrollLeft = element.scrollLeft; }
        if (duration === void 0) { duration = SCROLL_TIME; }
        tuiAssert.assert(duration >= 0, 'Duration cannot be negative');
        tuiAssert.assert(scrollTop >= 0, 'scrollTop cannot be negative');
        tuiAssert.assert(scrollLeft >= 0, 'scrollLeft cannot be negative');
        var initialTop = element.scrollTop;
        var initialLeft = element.scrollLeft;
        var deltaTop = scrollTop - initialTop;
        var deltaLeft = scrollLeft - initialLeft;
        var observable = !duration
            ? of([scrollTop, scrollLeft])
            : defer(function () { return of(_this.performanceRef.now()); }).pipe(switchMap(function (start) { return _this.animationFrame$.pipe(map(function (now) { return now - start; })); }), takeUntil(timer(duration)), map(function (elapsed) { return easeInOutQuad(clamp(elapsed / duration, 0, 1)); }), map(function (percent) {
                return [
                    initialTop + deltaTop * percent,
                    initialLeft + deltaLeft * percent,
                ];
            }));
        return observable.pipe(tap(function (_a) {
            var _b = __read(_a, 2), scrollTop = _b[0], scrollLeft = _b[1];
            element.scrollTop = scrollTop;
            element.scrollLeft = scrollLeft;
        }));
    };
    TuiScrollService.ctorParameters = function () { return [
        { type: Performance, decorators: [{ type: Inject, args: [PERFORMANCE,] }] },
        { type: Observable, decorators: [{ type: Inject, args: [ANIMATION_FRAME,] }] }
    ]; };
    TuiScrollService = __decorate([
        Injectable(),
        __param(0, Inject(PERFORMANCE)),
        __param(1, Inject(ANIMATION_FRAME))
    ], TuiScrollService);
    return TuiScrollService;
}());

var TuiStaticRequestService = /** @class */ (function () {
    function TuiStaticRequestService() {
        this.cache = new Map();
    }
    TuiStaticRequestService.prototype.request = function (url) {
        var cache = this.cache.get(url);
        if (cache) {
            return cache;
        }
        var observable = new Observable(function (observer) {
            var xhr = new XMLHttpRequest();
            xhr.onreadystatechange = function () {
                if (xhr.readyState === 4) {
                    var response = xhr.responseType ? xhr.response : xhr.responseText;
                    if (xhr.status === 200) {
                        observer.next(response);
                        observer.complete();
                    }
                    else {
                        observer.error(response);
                    }
                }
            };
            xhr.open('GET', url);
            xhr.send();
            return function () {
                xhr.abort();
            };
        });
        var piped = observable.pipe(shareReplay(1));
        this.cache.set(url, piped);
        return piped;
    };
    TuiStaticRequestService.ɵprov = ɵɵdefineInjectable({ factory: function TuiStaticRequestService_Factory() { return new TuiStaticRequestService(); }, token: TuiStaticRequestService, providedIn: "root" });
    TuiStaticRequestService = __decorate([
        Injectable({
            providedIn: 'root',
        })
    ], TuiStaticRequestService);
    return TuiStaticRequestService;
}());

/**
 * Generated bundle index. Do not edit.
 */

export { TuiDestroyService, TuiDirectiveStylesService, TuiFocusVisibleService, TuiHoveredService, TuiIdService, TuiObscuredService, TuiParentsScrollService, TuiResizeService, TuiScrollService, TuiStaticRequestService };
//# sourceMappingURL=taiga-ui-cdk-services.js.map
