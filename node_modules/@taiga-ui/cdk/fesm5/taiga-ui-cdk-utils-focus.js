import { svgNodeFilter } from '@taiga-ui/cdk/constants';

/**
 * Returns current active element, including shadow dom
 *
 * @return element or null
 */
function getNativeFocused(documentRef) {
    if (!documentRef.activeElement || !documentRef.activeElement.shadowRoot) {
        return documentRef.activeElement;
    }
    var element = documentRef.activeElement.shadowRoot.activeElement;
    while (element && element.shadowRoot) {
        element = element.shadowRoot.activeElement;
    }
    return element;
}

/**
 * Focuses or blurs and element
 *
 * @param element native element
 * @param focused boolean focused state
 * @param preventScroll optional flag to prevent native scroll to the element
 */
function setNativeFocused(element, focused, preventScroll) {
    if (focused === void 0) { focused = true; }
    if (preventScroll === void 0) { preventScroll = false; }
    if (focused) {
        element.focus({ preventScroll: preventScroll });
    }
    else {
        element.blur();
    }
}

/**
 * Finds and blurs current active element, including shadow DOM
 */
function blurNativeFocused(documentRef) {
    var activeElement = getNativeFocused(documentRef);
    if (activeElement instanceof HTMLElement) {
        setNativeFocused(activeElement, false);
    }
}

/**
 * Checks for signs that element can be focused with keyboard. tabIndex above 0 is ignored to
 * only target natural focus order. Not checking the possibility of an element to
 * be focused, for example element can have display: none applied to it or any other
 * circumstances could prevent actual focus.
 */
function isNativeKeyboardFocusable(element) {
    if (element.hasAttribute('disabled') || element.getAttribute('tabIndex') === '-1') {
        return false;
    }
    if ((element instanceof HTMLElement && element.isContentEditable) ||
        element.getAttribute('tabIndex') === '0') {
        return true;
    }
    switch (element.tagName) {
        case 'BUTTON':
        case 'SELECT':
        case 'TEXTAREA':
            return true;
        case 'VIDEO':
        case 'AUDIO':
            return element.hasAttribute('controls');
        case 'INPUT':
            return element.getAttribute('type') !== 'hidden';
        case 'A':
        case 'LINK':
            return element.hasAttribute('href');
        default:
            return false;
    }
}

/**
 * Finds closest element that can be focused with a keyboard in theory
 *
 * @param initial current HTML element
 * @param prev should it look backwards instead (find item that will be focused with Shift + Tab)
 * @param root top Node limiting the search area
 */
function getClosestKeyboardFocusable(initial, prev, root) {
    if (prev === void 0) { prev = false; }
    if (!root.ownerDocument) {
        return null;
    }
    // Deprecated but ony this overload works in IE
    // Filter must be a function in IE, other modern browsers are compliant to this format
    var treeWalker = root.ownerDocument.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, svgNodeFilter, false);
    treeWalker.currentNode = initial;
    while (prev ? treeWalker.previousNode() : treeWalker.nextNode()) {
        if (treeWalker.currentNode instanceof HTMLElement) {
            initial = treeWalker.currentNode;
        }
        if (isNativeKeyboardFocusable(initial)) {
            return initial;
        }
    }
    return null;
}

/**
 * Checks if element is focused.
 *
 * Could return true even after blur since element remains focused if you switch away from a browser tab.
 *
 * @param node or null (as a common return value of DOM nodes walking)
 * @return true if focused
 */
function isNativeFocused(node) {
    return (!!node && !!node.ownerDocument && getNativeFocused(node.ownerDocument) === node);
}

/**
 * Checks if focused element is within given element.
 *
 * @param node
 * @return true if focused node is contained within element
 */
function isNativeFocusedIn(node) {
    // !node.contains - check for IE11
    if (!node.ownerDocument || !node.contains) {
        return false;
    }
    var nativeFocused = getNativeFocused(node.ownerDocument);
    return nativeFocused !== null && node.contains(nativeFocused);
}

function isNativeMouseFocusable(element) {
    return (!element.hasAttribute('disabled') &&
        (element.getAttribute('tabIndex') === '-1' || isNativeKeyboardFocusable(element)));
}

/**
 * Utility method for moving focus in a list of elements
 *
 * @param currentIndex currently focused index
 * @param elements array of focusable elements
 * @param step a step to move focus by, typically -1 or 1
 */
function moveFocus(currentIndex, elements, step) {
    currentIndex += step;
    while (currentIndex >= 0 && currentIndex < elements.length) {
        setNativeFocused(elements[currentIndex]);
        if (isNativeFocused(elements[currentIndex])) {
            return;
        }
        currentIndex += step;
    }
}

/**
 * Focuses or blurs element with mouse action imitation (to spoof {@link TuiFocusVisibleService})
 *
 * @param element
 * @param focused desired focused state
 * @param preventScroll optionally prevent native browser scroll after focus
 */
function setNativeMouseFocused(element, focused, preventScroll) {
    if (preventScroll === void 0) { preventScroll = false; }
    if (!element.ownerDocument) {
        return;
    }
    if (typeof Event === 'function') {
        element.dispatchEvent(new Event('mousedown', { bubbles: true, cancelable: true }));
    }
    else {
        var event_1 = element.ownerDocument.createEvent('Event');
        event_1.initEvent('mousedown', true, true);
        element.dispatchEvent(event_1);
    }
    setNativeFocused(element, focused, preventScroll);
}

/**
 * Generated bundle index. Do not edit.
 */

export { blurNativeFocused, getClosestKeyboardFocusable, getNativeFocused, isNativeFocused, isNativeFocusedIn, isNativeKeyboardFocusable, isNativeMouseFocusable, moveFocus, setNativeFocused, setNativeMouseFocused };
//# sourceMappingURL=taiga-ui-cdk-utils-focus.js.map
