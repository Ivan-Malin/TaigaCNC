(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@taiga-ui/core/constants'), require('rxjs'), require('rxjs/operators')) :
    typeof define === 'function' && define.amd ? define('@taiga-ui/core/utils/miscellaneous', ['exports', '@taiga-ui/core/constants', 'rxjs', 'rxjs/operators'], factory) :
    (global = global || self, factory((global['taiga-ui'] = global['taiga-ui'] || {}, global['taiga-ui'].core = global['taiga-ui'].core || {}, global['taiga-ui'].core.utils = global['taiga-ui'].core.utils || {}, global['taiga-ui'].core.utils.miscellaneous = {}), global['taiga-ui'].core.constants, global.rxjs, global.rxjs.operators));
}(this, (function (exports, constants, rxjs, operators) { 'use strict';

    var PADDING_SMALL = 12;
    var PADDING_LARGE = 16;
    var ITEM_SIZE = 24;
    var CONTENT_SIZE = 40;
    function getPadding(sizeBig, hasIcon, hasCleaner, hasTooltip, hasContent) {
        if (hasCleaner === void 0) { hasCleaner = false; }
        if (hasTooltip === void 0) { hasTooltip = false; }
        if (hasContent === void 0) { hasContent = false; }
        var padding = sizeBig ? PADDING_LARGE : PADDING_SMALL;
        if (hasIcon) {
            padding += ITEM_SIZE;
        }
        if (hasCleaner) {
            padding += ITEM_SIZE;
        }
        if (hasTooltip) {
            padding += ITEM_SIZE;
        }
        if (hasContent) {
            padding += CONTENT_SIZE;
        }
        return padding;
    }

    function iconsPathFactory(staticPath) {
        var base = staticPath[staticPath.length - 1] === '/' ? staticPath : staticPath + '/';
        return function (name) {
            if (name.startsWith('tuiIcon')) {
                return "" + base + name + ".svg#" + name;
            }
            return constants.DEFAULT_ICONS_PATH(name);
        };
    }

    /**
     * Check if pressed key is interactive in terms of input field
     */
    function isEditingKey(key) {
        return key.length === 1 || constants.tuiEditingKeys.indexOf(key) !== -1;
    }

    function isPresumedHTMLString(candidate) {
        var trimmed = candidate.trim();
        return trimmed.startsWith('<') && trimmed.endsWith('>');
    }

    function modeFactory(mode, _a) {
        var nativeElement = _a.nativeElement;
        var mode$ = mode
            ? mode.change$.pipe(operators.startWith(null), operators.map(function () { return mode.mode; }))
            : rxjs.EMPTY;
        return (nativeElement['$.data-mode.attr'] = mode$);
    }

    var SIZES = ['xs', 's', 'm', 'l', 'xl', 'xxl'];
    /**
     * Compares size constants to determine if first size is bigger than the second
     *
     * @param size size that we need to compare
     * @param biggerThanSize size to compare with, 's' by default
     */
    function sizeBigger(size, biggerThanSize) {
        if (biggerThanSize === void 0) { biggerThanSize = 's'; }
        return SIZES.indexOf(size) > SIZES.indexOf(biggerThanSize);
    }

    exports.getPadding = getPadding;
    exports.iconsPathFactory = iconsPathFactory;
    exports.isEditingKey = isEditingKey;
    exports.isPresumedHTMLString = isPresumedHTMLString;
    exports.modeFactory = modeFactory;
    exports.sizeBigger = sizeBigger;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=taiga-ui-core-utils-miscellaneous.umd.js.map
