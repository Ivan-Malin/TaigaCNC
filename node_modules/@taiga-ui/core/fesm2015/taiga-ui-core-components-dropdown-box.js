import { __decorate, __param } from 'tslib';
import { Inject, NgZone, ElementRef, HostBinding, ViewChild, Component, ChangeDetectionStrategy, NgModule } from '@angular/core';
import { WINDOW, USER_AGENT } from '@ng-web-apis/common';
import { POLLING_TIME, tuiZonefree, getClosestElement, inRange, px, isIE, getClosestKeyboardFocusable, setNativeFocused, TuiDestroyService, TuiPortalHostComponent, tuiPure, TuiActiveZoneModule, TuiOverscrollModule } from '@taiga-ui/cdk';
import { tuiDropdownAnimation } from '@taiga-ui/core/animations';
import { DEFAULT_MARGIN, DEFAULT_MAX_WIDTH } from '@taiga-ui/core/constants';
import { TUI_DROPDOWN_DIRECTIVE } from '@taiga-ui/core/tokens';
import { getScreenWidth } from '@taiga-ui/core/utils/dom';
import { merge, interval, fromEvent } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import { TuiScrollbarModule } from '@taiga-ui/core/components/scrollbar';
import { TuiModeModule } from '@taiga-ui/core/directives/mode';
import { PolymorpheusModule } from '@tinkoff/ng-polymorpheus';

/**
 *  This component is used to show template in a portal using default style of white rounded box with a shadow
 */
// @bad TODO: OnPush
// Ambient type cannot be used without dynamic https://github.com/angular/angular/issues/23395
// @dynamic
let TuiDropdownBoxComponent = class TuiDropdownBoxComponent {
    constructor(destroy$, ngZone, directive, windowRef, elementRef, portalHost, userAgent) {
        this.directive = directive;
        this.windowRef = windowRef;
        this.elementRef = elementRef;
        this.portalHost = portalHost;
        this.userAgent = userAgent;
        /**
         * Is previous position on top (to prevent jumping up and down on scroll)
         */
        this.prevDirectionIsTop = false;
        merge(interval(POLLING_TIME), this.directive.refresh$, fromEvent(this.windowRef, 'resize'))
            .pipe(tuiZonefree(ngZone), takeUntil(destroy$))
            .subscribe(() => {
            this.calculatePositionAndSize();
        });
    }
    ngAfterViewChecked() {
        this.calculatePositionAndSize();
    }
    onTopFocus() {
        this.moveFocusOutside(true);
    }
    onBottomFocus() {
        this.moveFocusOutside(false);
    }
    get overscroll() {
        return this.inModal ? "all" /* All */ : "scroll" /* Scroll */;
    }
    get inModal() {
        // @awful TODO: get rid of component tag name dependency
        return !!getClosestElement(this.directive.host, 'tui-dialog-host');
    }
    calculatePositionAndSize() {
        const { clientRect } = this.directive;
        const { style } = this.elementRef.nativeElement;
        const hostRect = this.directive.fixed
            ? this.portalHost.fixedPositionOffset()
            : this.portalHost.clientRect;
        style.position = this.directive.fixed ? 'fixed' : 'absolute';
        this.calculateVerticalPosition(style, clientRect, hostRect);
        this.calculateHorizontalPosition(style, clientRect, hostRect);
        this.calculateWidth(style, clientRect);
    }
    getFinalAlign(style, directiveRect) {
        const dropdownRect = this.elementRef.nativeElement.getBoundingClientRect();
        const dropdownWidth = this.elementRef.nativeElement.offsetWidth;
        const screenWidth = getScreenWidth(this.windowRef.document);
        const isDropdownSizeHypotheticallyFitsViewport = directiveRect.left + dropdownWidth < screenWidth ||
            directiveRect.right - dropdownWidth > 0;
        const isDropdownSizeActuallyFitsViewport = dropdownRect.right <= screenWidth && dropdownRect.left >= 0;
        let finalAlign = this.directive.align;
        switch (this.directive.align) {
            case 'left':
                if (isDropdownSizeHypotheticallyFitsViewport &&
                    dropdownRect.right > screenWidth) {
                    finalAlign = 'right';
                }
                break;
            case 'right':
                if (isDropdownSizeHypotheticallyFitsViewport && dropdownRect.left < 0) {
                    finalAlign = 'left';
                }
                break;
        }
        if (style.right === 'auto' && isDropdownSizeActuallyFitsViewport) {
            finalAlign = 'left';
        }
        if (style.left === 'auto' && isDropdownSizeActuallyFitsViewport) {
            finalAlign = 'right';
        }
        return finalAlign;
    }
    /**
     * Calculates horizontal position
     *
     * @param style dropdownBox elementRef styles object
     * @param directiveRect ClientRect of hosting directive
     * @param hostRect ClientRect of  portal host
     */
    calculateHorizontalPosition(style, directiveRect, hostRect) {
        const offset = this.directive.sided
            ? this.elementRef.nativeElement.getBoundingClientRect().width + DEFAULT_MARGIN
            : 0;
        const left = Math.ceil(directiveRect.left - hostRect.left - offset);
        const right = Math.floor(hostRect.right - directiveRect.right - offset);
        switch (this.getFinalAlign(style, directiveRect)) {
            case 'left':
                if (right + DEFAULT_MARGIN > this.windowRef.innerWidth ||
                    inRange(left + DEFAULT_MARGIN, 0, this.windowRef.innerWidth)) {
                    style.left = px(left);
                    style.right = 'auto';
                }
                else {
                    style.left = 'auto';
                    style.right = px(right);
                }
                break;
            case 'right':
                if (inRange(right + DEFAULT_MARGIN, 0, this.windowRef.innerWidth) ||
                    left + DEFAULT_MARGIN > this.windowRef.innerWidth) {
                    style.left = 'auto';
                    style.right = px(right);
                }
                else {
                    style.left = px(left);
                    style.right = 'auto';
                }
                break;
        }
    }
    /**
     * Calculates vertical position and height
     *
     * @param style dropdownBox elementRef styles object
     * @param directiveRect ClientRect of hosting directive
     * @param hostRect ClientRect of  portal host
     */
    calculateVerticalPosition(style, directiveRect, hostRect) {
        const windowHeight = this.windowRef.innerHeight;
        // Maximum height of the box
        const boxHeightLimit = Math.min(this.directive.maxHeight, windowHeight - DEFAULT_MARGIN * 2);
        const offset = this.directive.sided
            ? DEFAULT_MARGIN - directiveRect.height
            : DEFAULT_MARGIN * 2;
        const topAvailableHeight = directiveRect.top - offset;
        const bottomAvailableHeight = windowHeight - directiveRect.bottom - offset;
        const finalDirection = this.getFinalDirection(directiveRect);
        this.prevDirectionIsTop = finalDirection === 'top';
        if (finalDirection === 'top') {
            this.dropdownAnimation = "fadeInBottom" /* FadeInBottom */;
            style.maxHeight = px(Math.min(boxHeightLimit, topAvailableHeight));
            style.top = 'auto';
            style.bottom = px(hostRect.bottom - directiveRect.top - DEFAULT_MARGIN + offset);
        }
        else {
            this.dropdownAnimation = "fadeInTop" /* FadeInTop */;
            style.maxHeight = px(Math.min(boxHeightLimit, bottomAvailableHeight));
            style.top = px(directiveRect.bottom - hostRect.top - DEFAULT_MARGIN + offset);
            style.bottom = 'auto';
        }
    }
    getFinalDirection(directiveRect) {
        const windowHeight = this.windowRef.innerHeight;
        const offset = this.directive.sided
            ? DEFAULT_MARGIN - directiveRect.height
            : DEFAULT_MARGIN * 2;
        // Maximum space available on top and on the bottom in the viewport
        const topAvailableHeight = directiveRect.top - offset;
        const bottomAvailableHeight = windowHeight - directiveRect.bottom - offset;
        let finalDirection = null;
        // Given direction is applied if we can fit the box in the limits that way
        switch (this.directive.direction) {
            case 'top':
                if (topAvailableHeight >= this.directive.minHeight) {
                    finalDirection = 'top';
                }
                break;
            case 'bottom':
                if (bottomAvailableHeight >= this.directive.minHeight) {
                    finalDirection = 'bottom';
                }
                break;
        }
        // Maximum height of the box
        const boxHeightLimit = Math.min(this.directive.maxHeight, windowHeight - DEFAULT_MARGIN * 2);
        // Choose direction if given direction did not fit
        if (finalDirection === null && this.contentElementRef) {
            // Box height if it fits without scroll
            const visualHeight = Math.min(this.contentElementRef.nativeElement.getBoundingClientRect().height +
                (this.elementRef.nativeElement.offsetHeight -
                    this.elementRef.nativeElement.clientHeight), boxHeightLimit);
            // If there is enough space to fit below without scroll,
            // choose 'bottom', unless it was previously on the top
            if (this.prevDirectionIsTop && topAvailableHeight >= visualHeight) {
                finalDirection = 'top';
            }
            else if (bottomAvailableHeight >= visualHeight) {
                finalDirection = 'bottom';
            }
            else {
                // Corner case â€” select direction with more space
                finalDirection =
                    bottomAvailableHeight >= topAvailableHeight ? 'bottom' : 'top';
            }
        }
        return finalDirection;
    }
    /**
     * Calculates width
     *
     * @param style dropdownBox elementRef styles object
     * @param directiveRect ClientRect of hosting directive
     */
    calculateWidth(style, directiveRect) {
        style.width =
            this.directive.limitMinWidth === "fixed" /* Fixed */ &&
                !this.directive.sided
                ? px(directiveRect.width)
                : '';
        if (isIE(this.userAgent) &&
            this.directive.limitMinWidth === "min" /* Min */ &&
            !this.directive.sided) {
            style.width = px(DEFAULT_MAX_WIDTH);
            return;
        }
        if (this.directive.limitMinWidth === "min" /* Min */ &&
            !this.directive.sided) {
            style.minWidth = px(directiveRect.width);
            style.maxWidth = px(DEFAULT_MAX_WIDTH);
            return;
        }
        style.minWidth = '';
        style.maxWidth = '';
    }
    moveFocusOutside(previous) {
        const { host } = this.directive;
        const { ownerDocument } = host;
        const root = ownerDocument ? ownerDocument.body : host;
        let focusable = getClosestKeyboardFocusable(host, previous, root);
        while (focusable !== null && host.contains(focusable)) {
            focusable = getClosestKeyboardFocusable(focusable, previous, root);
        }
        if (focusable === null) {
            return;
        }
        setNativeFocused(focusable);
    }
};
TuiDropdownBoxComponent.ctorParameters = () => [
    { type: TuiDestroyService, decorators: [{ type: Inject, args: [TuiDestroyService,] }] },
    { type: NgZone, decorators: [{ type: Inject, args: [NgZone,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [TUI_DROPDOWN_DIRECTIVE,] }] },
    { type: Window, decorators: [{ type: Inject, args: [WINDOW,] }] },
    { type: ElementRef, decorators: [{ type: Inject, args: [ElementRef,] }] },
    { type: TuiPortalHostComponent, decorators: [{ type: Inject, args: [TuiPortalHostComponent,] }] },
    { type: String, decorators: [{ type: Inject, args: [USER_AGENT,] }] }
];
__decorate([
    HostBinding('@tuiDropdownAnimation')
], TuiDropdownBoxComponent.prototype, "dropdownAnimation", void 0);
__decorate([
    ViewChild('content', { read: ElementRef })
], TuiDropdownBoxComponent.prototype, "contentElementRef", void 0);
__decorate([
    tuiPure
], TuiDropdownBoxComponent.prototype, "inModal", null);
TuiDropdownBoxComponent = __decorate([
    Component({
        selector: 'tui-dropdown-box',
        template: "<div\n    class=\"wrapper\"\n    [tuiOverscroll]=\"overscroll\"\n    [tuiMode]=\"null\"\n    [tuiActiveZoneParent]=\"directive.activeZone\"\n>\n    <tui-scrollbar class=\"scroll\">\n        <div tabindex=\"0\" (focus)=\"onTopFocus()\"></div>\n        <div\n            polymorpheus-outlet\n            #content\n            class=\"content\"\n            [content]=\"directive.content\"\n        ></div>\n        <div tabindex=\"0\" (focus)=\"onBottomFocus()\"></div>\n    </tui-scrollbar>\n</div>\n",
        changeDetection: ChangeDetectionStrategy.Default,
        providers: [TuiDestroyService],
        animations: [tuiDropdownAnimation],
        styles: [":host{z-index:0;box-shadow:0 8px 16px rgba(51,51,51,.2);position:absolute;top:0;left:0;display:flex;background-color:#fff;background-color:var(--tui-base-01);border-radius:var(--tui-radius-m);overflow:hidden;border:1px solid var(--tui-base-03);box-sizing:border-box}:host.ng-animating{pointer-events:none}.content{display:flex;flex-direction:column;max-height:100%}.wrapper{flex-grow:1;max-width:100%;max-height:inherit;overflow:visible}.scroll{height:100%}"]
    }),
    __param(0, Inject(TuiDestroyService)),
    __param(1, Inject(NgZone)),
    __param(2, Inject(TUI_DROPDOWN_DIRECTIVE)),
    __param(3, Inject(WINDOW)),
    __param(4, Inject(ElementRef)),
    __param(5, Inject(TuiPortalHostComponent)),
    __param(6, Inject(USER_AGENT))
], TuiDropdownBoxComponent);

let TuiDropdownBoxModule = class TuiDropdownBoxModule {
};
TuiDropdownBoxModule = __decorate([
    NgModule({
        imports: [
            TuiActiveZoneModule,
            PolymorpheusModule,
            TuiOverscrollModule,
            TuiScrollbarModule,
            TuiModeModule,
        ],
        entryComponents: [TuiDropdownBoxComponent],
        declarations: [TuiDropdownBoxComponent],
        exports: [TuiDropdownBoxComponent],
    })
], TuiDropdownBoxModule);

/**
 * Generated bundle index. Do not edit.
 */

export { TuiDropdownBoxComponent, TuiDropdownBoxModule };
//# sourceMappingURL=taiga-ui-core-components-dropdown-box.js.map
