import { __decorate, __param } from 'tslib';
import { DOCUMENT, ViewportScroller, CommonModule } from '@angular/common';
import { NgZone, Inject, Renderer2, ElementRef, Optional, Input, Directive, Component, ChangeDetectionStrategy, NgModule } from '@angular/core';
import { WINDOW } from '@ng-web-apis/common';
import { typedFromEvent, preventDefault, tuiZonefree, POLLING_TIME, TuiDestroyService, tuiZoneOptimized, TuiLetModule } from '@taiga-ui/cdk';
import { TUI_SCROLL_REF, TUI_MODE } from '@taiga-ui/core/tokens';
import { merge, fromEvent, interval, Observable } from 'rxjs';
import { switchMap, map, takeUntil, startWith, distinctUntilChanged } from 'rxjs/operators';
import { tuiFadeIn } from '@taiga-ui/core/animations';
import { MODE_PROVIDER } from '@taiga-ui/core/providers';

const MIN_WIDTH = 24;
// @bad TODO: add support for window scroll control
// @dynamic
let TuiScrollbarDirective = class TuiScrollbarDirective {
    constructor(ngZone, renderer, destroy$, container, documentRef, windowRef, elementRef, viewportScroller) {
        this.container = container;
        this.documentRef = documentRef;
        this.windowRef = windowRef;
        this.elementRef = elementRef;
        this.viewportScroller = viewportScroller;
        this.tuiScrollbar = "vertical" /* Vertical */;
        const { nativeElement } = this.elementRef;
        const mousedown$ = typedFromEvent(nativeElement, 'mousedown');
        const mousemove$ = typedFromEvent(this.documentRef, 'mousemove');
        const mouseup$ = typedFromEvent(this.documentRef, 'mouseup');
        mousedown$
            .pipe(preventDefault(), switchMap(event => {
            const rect = event.currentTarget.getBoundingClientRect();
            const vertical = getOffsetVertical(event, rect);
            const horizontal = getOffsetHorizontal(event, rect);
            return mousemove$.pipe(map(event => this.getScrolled(event, vertical, horizontal)), takeUntil(mouseup$));
        }), takeUntil(destroy$), tuiZonefree(ngZone))
            .subscribe(([scrollTop, scrollLeft]) => {
            const [x, y] = this.viewportScroller.getScrollPosition();
            if (!this.container) {
                this.viewportScroller.scrollToPosition([
                    this.tuiScrollbar === "vertical" /* Vertical */ ? x : scrollLeft,
                    this.tuiScrollbar === "vertical" /* Vertical */ ? scrollTop : y,
                ]);
                return;
            }
            if (this.tuiScrollbar === "vertical" /* Vertical */) {
                renderer.setProperty(this.container.nativeElement, 'scrollTop', scrollTop);
            }
            else {
                renderer.setProperty(this.container.nativeElement, 'scrollLeft', scrollLeft);
            }
        });
        merge(fromEvent(this.container ? this.container.nativeElement : this.windowRef, 'scroll'), interval(POLLING_TIME))
            .pipe(takeUntil(destroy$), tuiZonefree(ngZone))
            .subscribe(() => {
            if (this.tuiScrollbar === "vertical" /* Vertical */) {
                renderer.setStyle(nativeElement, 'top', `${this.thumb * 100}%`);
                renderer.setStyle(nativeElement, 'height', `${this.view * 100}%`);
            }
            else {
                renderer.setStyle(nativeElement, 'left', `${this.thumb * 100}%`);
                renderer.setStyle(nativeElement, 'width', `${this.view * 100}%`);
            }
        });
    }
    get scrolled() {
        const { scrollTop, scrollHeight, clientHeight, scrollLeft, scrollWidth, clientWidth, } = this.computedContainer;
        return this.tuiScrollbar === "vertical" /* Vertical */
            ? scrollTop / (scrollHeight - clientHeight)
            : scrollLeft / (scrollWidth - clientWidth);
    }
    get compensation() {
        const { clientHeight, scrollHeight, clientWidth, scrollWidth, } = this.computedContainer;
        if (((clientHeight * clientHeight) / scrollHeight > MIN_WIDTH &&
            this.tuiScrollbar === "vertical" /* Vertical */) ||
            ((clientWidth * clientWidth) / scrollWidth > MIN_WIDTH &&
                this.tuiScrollbar === "horizontal" /* Horizontal */)) {
            return 0;
        }
        return this.tuiScrollbar === "vertical" /* Vertical */
            ? MIN_WIDTH / clientHeight
            : MIN_WIDTH / clientWidth;
    }
    get thumb() {
        const compensation = this.compensation || this.view;
        return this.scrolled * (1 - compensation);
    }
    get view() {
        const { clientHeight, scrollHeight, clientWidth, scrollWidth, } = this.computedContainer;
        return this.tuiScrollbar === "vertical" /* Vertical */
            ? Math.ceil((clientHeight / scrollHeight) * 100) / 100
            : Math.ceil((clientWidth / scrollWidth) * 100) / 100;
    }
    get computedContainer() {
        return this.container
            ? this.container.nativeElement
            : this.documentRef.documentElement;
    }
    getScrolled({ clientY, clientX }, offsetVertical, offsetHorizontal) {
        const { innerWidth, innerHeight } = this.windowRef;
        const { offsetHeight, offsetWidth } = this.elementRef.nativeElement;
        const { top = 0, left = 0, width = innerWidth, height = innerHeight } = this
            .container
            ? this.container.nativeElement.getBoundingClientRect()
            : {};
        const maxTop = this.computedContainer.scrollHeight - height;
        const maxLeft = this.computedContainer.scrollWidth - width;
        const scrolledTop = (clientY - top - offsetHeight * offsetVertical) / (height - offsetHeight);
        const scrolledLeft = (clientX - left - offsetWidth * offsetHorizontal) / (width - offsetWidth);
        return [maxTop * scrolledTop, maxLeft * scrolledLeft];
    }
};
TuiScrollbarDirective.ctorParameters = () => [
    { type: NgZone, decorators: [{ type: Inject, args: [NgZone,] }] },
    { type: Renderer2, decorators: [{ type: Inject, args: [Renderer2,] }] },
    { type: Observable, decorators: [{ type: Inject, args: [TuiDestroyService,] }] },
    { type: ElementRef, decorators: [{ type: Optional }, { type: Inject, args: [TUI_SCROLL_REF,] }] },
    { type: Document, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: Window, decorators: [{ type: Inject, args: [WINDOW,] }] },
    { type: ElementRef, decorators: [{ type: Inject, args: [ElementRef,] }] },
    { type: ViewportScroller, decorators: [{ type: Inject, args: [ViewportScroller,] }] }
];
__decorate([
    Input()
], TuiScrollbarDirective.prototype, "tuiScrollbar", void 0);
TuiScrollbarDirective = __decorate([
    Directive({
        selector: '[tuiScrollbar]',
        providers: [TuiDestroyService],
    }),
    __param(0, Inject(NgZone)),
    __param(1, Inject(Renderer2)),
    __param(2, Inject(TuiDestroyService)),
    __param(3, Optional()),
    __param(3, Inject(TUI_SCROLL_REF)),
    __param(4, Inject(DOCUMENT)),
    __param(5, Inject(WINDOW)),
    __param(6, Inject(ElementRef)),
    __param(7, Inject(ViewportScroller))
], TuiScrollbarDirective);
function getOffsetVertical({ clientY }, { top, height }) {
    return (clientY - top) / height;
}
function getOffsetHorizontal({ clientX }, { left, width }) {
    return (clientX - left) / width;
}

// @bad TODO: handle click on bar to scroll to that position
// @dynamic
let TuiScrollControlsComponent = class TuiScrollControlsComponent {
    constructor(ngZone, documentRef, scrollRef, mode$) {
        this.ngZone = ngZone;
        this.documentRef = documentRef;
        this.scrollRef = scrollRef;
        this.mode$ = mode$;
        this.refresh$ = interval(300).pipe(map(() => this.scrollbars), startWith([false, false]), distinctUntilChanged((a, b) => a[0] === b[0] && a[1] === b[1]), tuiZoneOptimized(this.ngZone));
    }
    get scrollbars() {
        const { clientHeight, scrollHeight, clientWidth, scrollWidth } = this.scrollRef
            ? this.scrollRef.nativeElement
            : this.documentRef.documentElement;
        return [
            Math.ceil((clientHeight / scrollHeight) * 100) < 100,
            Math.ceil((clientWidth / scrollWidth) * 100) < 100,
        ];
    }
};
TuiScrollControlsComponent.ctorParameters = () => [
    { type: NgZone, decorators: [{ type: Inject, args: [NgZone,] }] },
    { type: Document, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: ElementRef, decorators: [{ type: Optional }, { type: Inject, args: [TUI_SCROLL_REF,] }] },
    { type: Observable, decorators: [{ type: Inject, args: [TUI_MODE,] }] }
];
TuiScrollControlsComponent = __decorate([
    Component({
        selector: 'tui-scroll-controls',
        template: "<ng-container *tuiLet=\"refresh$ | async as bars\">\n    <div\n        *ngIf=\"bars[0]\"\n        class=\"bar bar_vertical\"\n        [class.bar_has-horizontal]=\"bars[1]\"\n        [@tuiFadeIn]\n    >\n        <div tuiScrollbar=\"vertical\" class=\"thumb\"></div>\n    </div>\n    <div\n        *ngIf=\"bars[1]\"\n        class=\"bar bar_horizontal\"\n        [class.bar_has-vertical]=\"bars[0]\"\n        [@tuiFadeIn]\n    >\n        <div tuiScrollbar=\"horizontal\" class=\"thumb\"></div>\n    </div>\n</ng-container>\n",
        changeDetection: ChangeDetectionStrategy.OnPush,
        animations: [tuiFadeIn],
        providers: [MODE_PROVIDER],
        host: {
            '($.data-mode.attr)': 'mode$',
        },
        styles: [":host{position:-webkit-sticky;position:sticky;top:0;left:0;z-index:100;min-width:calc(100% - 1px);min-height:calc(100% - 1px);float:left;margin-right:calc(-100% + 1px);pointer-events:none}.bar{position:absolute;right:0;bottom:0}.bar_vertical{top:0}.bar_horizontal{left:0}.bar_has-horizontal{bottom:8px}.bar_has-vertical{right:8px}.thumb{transition-duration:.15s;transition-timing-function:ease-in-out;position:absolute;border-radius:100px;border:4px solid transparent;cursor:pointer;pointer-events:auto;background:var(--tui-text-01);background-clip:content-box;box-sizing:border-box;transition-property:width,height;opacity:.2}.thumb:hover{opacity:.24}.thumb:active{opacity:.48}:host[data-mode=onDark] .thumb{background-color:var(--tui-text-01-night)}.bar_vertical .thumb{right:0;width:12px;min-height:24px}.bar_vertical .thumb:active,.bar_vertical:hover .thumb{width:14px}.bar_horizontal .thumb{bottom:0;height:12px;min-width:24px}.bar_horizontal .thumb:active,.bar_horizontal:hover .thumb{height:14px}"]
    }),
    __param(0, Inject(NgZone)),
    __param(1, Inject(DOCUMENT)),
    __param(2, Optional()),
    __param(2, Inject(TUI_SCROLL_REF)),
    __param(3, Inject(TUI_MODE))
], TuiScrollControlsComponent);

let TuiScrollControlsModule = class TuiScrollControlsModule {
};
TuiScrollControlsModule = __decorate([
    NgModule({
        imports: [CommonModule, TuiLetModule],
        declarations: [TuiScrollbarDirective, TuiScrollControlsComponent],
        exports: [TuiScrollControlsComponent],
    })
], TuiScrollControlsModule);

/**
 * Generated bundle index. Do not edit.
 */

export { TuiScrollControlsComponent, TuiScrollControlsModule, TuiScrollbarDirective };
//# sourceMappingURL=taiga-ui-core-components-scroll-controls.js.map
