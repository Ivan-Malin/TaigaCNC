import { tuiAssert, isSafari, isNativeFocused, getDocumentOrShadowRoot, CHAR_NO_BREAK_SPACE, CHAR_EN_DASH } from '@taiga-ui/cdk';
import { MASK_CARET_TRAP, TUI_DIGIT_REGEXP, TUI_NON_DIGITS_REGEXP } from '@taiga-ui/core/constants';
import { otherDecimalSymbol } from '@taiga-ui/core/utils/format';

/**
 * Used to finish a number with zeros to a given precision
 */
function tuiCreateAutoCorrectedNumberPipe(decimalLimit = 0, decimalSymbol = ',', nativeInput) {
    tuiAssert.assert(Number.isInteger(decimalLimit));
    tuiAssert.assert(decimalLimit >= 0);
    // Guess for which browser I need this :)
    let previousCaret = -1;
    const unlucky = !!nativeInput && isSafari(nativeInput);
    if (nativeInput && unlucky) {
        nativeInput.addEventListener('beforeinput', () => {
            previousCaret = nativeInput.selectionStart || 0;
        });
    }
    return (conformedValue, config) => {
        // remove these hacks after text mask library has changed
        if (nativeInput && unlucky && isNativeFocused(nativeInput)) {
            const caret = calculateSafariCaret(config.previousConformedValue, conformedValue, previousCaret);
            setTimeout(() => {
                nativeInput.setSelectionRange(caret, caret);
            });
        }
        if (nativeInput &&
            nativeInput.ownerDocument !== getDocumentOrShadowRoot(nativeInput) &&
            isNativeFocused(nativeInput) &&
            config.currentCaretPosition) {
            const realCaretPosition = config.currentCaretPosition +
                calculateCaretGap(config.previousConformedValue, conformedValue);
            setTimeout(() => {
                nativeInput.setSelectionRange(realCaretPosition, realCaretPosition);
            });
        }
        if (conformedValue === '' || !decimalLimit) {
            return { value: conformedValue };
        }
        const withDecimalSymbol = addDecimalSymbolIfNeeded(conformedValue, decimalSymbol);
        const decimalPart = withDecimalSymbol.split(decimalSymbol)[1];
        const zeroPaddingSize = decimalLimit - decimalPart.length;
        return {
            value: withDecimalSymbol + '0'.repeat(zeroPaddingSize),
        };
    };
}
function addDecimalSymbolIfNeeded(value, decimalSymbol = ',') {
    return value.indexOf(decimalSymbol) === -1 ? value + decimalSymbol : value;
}
function calculateSafariCaret(previousValue = '', current, previousCaret, decimalSymbol = ',') {
    const tailRegex = new RegExp(`${decimalSymbol}.+`);
    const previousWithoutTail = previousValue.replace(tailRegex, '');
    const currentWithoutTail = current.replace(tailRegex, '');
    const pasteOrCutOperation = Math.abs(previousWithoutTail.length - currentWithoutTail.length) > 2;
    if (pasteOrCutOperation) {
        return current.length;
    }
    if (previousValue.length === current.length) {
        if (previousValue.indexOf(decimalSymbol) <= previousCaret) {
            return calculateChangedTailIndex(previousValue, current);
        }
        return previousWithoutTail === currentWithoutTail
            ? previousCaret - 1
            : previousCaret + 1;
    }
    if (previousValue.length === 0) {
        return 1;
    }
    const changeLength = current.length - previousValue.length;
    return previousCaret + changeLength;
}
function calculateChangedTailIndex(previous, current) {
    for (let i = 0; i < current.length; i++) {
        if (previous[i] !== current[i]) {
            return current[i] === '0' ? i : i + 1;
        }
    }
    return current.length;
}
function calculateCaretGap(previousValue = '', current) {
    const pasteOrCutOperation = Math.abs(previousValue.length - current.length) > 2;
    if (pasteOrCutOperation) {
        return 0;
    }
    const wereSpaces = previousValue.split(CHAR_NO_BREAK_SPACE).length;
    const nowSpaces = current.split(CHAR_NO_BREAK_SPACE).length;
    return nowSpaces - wereSpaces;
}

const ASSERTION = 'Correction function must return single char or null';
function tuiCreateCorrectionMask(allowed, correctionHandler) {
    return rawValue => {
        const mask = rawValue.split('').reduce((result, char, index) => {
            const corrected = correctionHandler(char, index);
            tuiAssert.assert(corrected === null || corrected.length === 1, ASSERTION);
            if (!allowed.test(char) && !corrected) {
                return result;
            }
            if (allowed.test(char)) {
                return [...result, allowed];
            }
            if (corrected) {
                return [...result, corrected, MASK_CARET_TRAP];
            }
            return result;
        }, []);
        const lastIndex = mask.lastIndexOf(MASK_CARET_TRAP);
        const filtered = mask.filter((item, index) => item !== MASK_CARET_TRAP || index === lastIndex);
        return filtered.some(item => item !== allowed)
            ? [...filtered, allowed]
            : filtered;
    };
}

const NON_ZERO_DIGIT = /[1-9]/;
/**
 * Adaptation for {@link https://github.com/text-mask/text-mask/tree/master/addons#createnumbermask `createNumberMask`}
 */
function tuiCreateNumberMask({ allowDecimal = false, decimalSymbol = ',', autoCorrectDecimalSymbol = true, decimalLimit = 2, requireDecimal = false, allowNegative = false, integerLimit = 0, } = {}) {
    tuiAssert.assert(Number.isInteger(decimalLimit));
    tuiAssert.assert(decimalLimit > 0);
    tuiAssert.assert(Number.isInteger(integerLimit));
    tuiAssert.assert(integerLimit >= 0);
    return (rawValue, { previousConformedValue }) => {
        if (previousConformedValue && requireDecimal) {
            const conformedWithoutSeparator = rawValue
                .split(CHAR_NO_BREAK_SPACE)
                .join('');
            const previousConformedValueWithoutDecimalSymbolAndSeparator = previousConformedValue
                .split(CHAR_NO_BREAK_SPACE)
                .join('')
                .split(',')
                .join('');
            // Forbid removal of decimal separator if decimal part is required
            if (conformedWithoutSeparator ===
                previousConformedValueWithoutDecimalSymbolAndSeparator) {
                rawValue = previousConformedValue;
            }
        }
        const isNegative = (rawValue[0] === '-' || rawValue[0] === CHAR_EN_DASH) && allowNegative;
        if (isDecimalSymbol(rawValue, decimalSymbol, autoCorrectDecimalSymbol) &&
            allowDecimal) {
            return ['0', decimalSymbol, TUI_DIGIT_REGEXP];
        }
        if (isNegative) {
            rawValue = rawValue.substr(1);
        }
        const decimalIndex = getDecimalSymbolIndex(rawValue, decimalSymbol, autoCorrectDecimalSymbol);
        const hasDecimal = decimalIndex !== -1;
        const integer = hasDecimal ? rawValue.slice(0, decimalIndex) : rawValue;
        const thousandSeparators = integer.match(new RegExp(CHAR_NO_BREAK_SPACE, 'g')) || [];
        const integerCapped = integerLimit
            ? integer.slice(0, integerLimit + thousandSeparators.length)
            : integer;
        const integerCappedClean = integerCapped
            .replace(TUI_NON_DIGITS_REGEXP, '')
            .replace(/^0+(?!\.|$)/, '0');
        const withSeparator = addThousandsSeparator(integerCappedClean);
        const mask = convertToMask(withSeparator);
        if ((hasDecimal && allowDecimal) || requireDecimal) {
            const fraction = hasDecimal
                ? convertToMask(rawValue.slice(decimalIndex + 1).replace(TUI_NON_DIGITS_REGEXP, ''))
                : [];
            const fractionCapped = decimalLimit
                ? fraction.slice(0, decimalLimit)
                : fraction;
            if (rawValue[decimalIndex] !== otherDecimalSymbol(decimalSymbol)) {
                mask.push(MASK_CARET_TRAP);
            }
            mask.push(decimalSymbol, MASK_CARET_TRAP, ...fractionCapped);
            for (let i = 0; i < decimalLimit - fractionCapped.length; i++) {
                mask.push(TUI_DIGIT_REGEXP);
            }
        }
        if (isNegative) {
            if (mask.length === 0) {
                mask.push(TUI_DIGIT_REGEXP);
            }
            mask.unshift('-');
        }
        return preventLeadingZeroes(mask);
    };
}
function preventLeadingZeroes(mask) {
    const firstDigitIndex = mask.indexOf(TUI_DIGIT_REGEXP);
    if (firstDigitIndex !== -1 && mask[firstDigitIndex + 1] === TUI_DIGIT_REGEXP) {
        mask[firstDigitIndex] = NON_ZERO_DIGIT;
    }
    return mask;
}
function getDecimalSymbolIndex(str, decimalSymbol, autoCorrectDecimalSymbol) {
    if (!autoCorrectDecimalSymbol) {
        return str.lastIndexOf(decimalSymbol);
    }
    return Math.max(str.lastIndexOf(decimalSymbol), str.lastIndexOf(otherDecimalSymbol(decimalSymbol)));
}
function isDecimalSymbol(str, decimalSymbol, autoCorrectDecimalSymbol) {
    if (autoCorrectDecimalSymbol) {
        return /^[,.]$/.test(str);
    }
    return str === decimalSymbol;
}
function convertToMask(strNumber) {
    return strNumber
        .split('')
        .map(char => (TUI_DIGIT_REGEXP.test(char) ? TUI_DIGIT_REGEXP : char));
}
function addThousandsSeparator(strNumber) {
    return strNumber.length > 3
        ? strNumber.replace(/\B(?=(\d{3})+(?!\d))/g, CHAR_NO_BREAK_SPACE)
        : strNumber;
}

function maskedMoneyValueIsEmpty(value) {
    switch (value) {
        case '':
        case '-':
        case ',':
        case '-,':
            return true;
        default:
            return false;
    }
}

function maskedNumberStringToNumber(value) {
    return parseFloat(value.split(CHAR_NO_BREAK_SPACE).join('').split(',').join('.'));
}

/**
 * Generated bundle index. Do not edit.
 */

export { maskedMoneyValueIsEmpty, maskedNumberStringToNumber, tuiCreateAutoCorrectedNumberPipe, tuiCreateCorrectionMask, tuiCreateNumberMask };
//# sourceMappingURL=taiga-ui-core-utils-mask.js.map
