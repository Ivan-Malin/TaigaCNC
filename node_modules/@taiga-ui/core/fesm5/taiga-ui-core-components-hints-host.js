import { __decorate, __param } from 'tslib';
import { ElementRef, Inject, ChangeDetectorRef, Component, ChangeDetectionStrategy, NgZone, Input, HostBinding, ViewChild, NgModule } from '@angular/core';
import { TuiDestroyService, tuiZonefree, px, TUI_IS_MOBILE, tuiDefaultProp, tuiPure, TuiHoveredModule } from '@taiga-ui/cdk';
import { tuiFadeIn } from '@taiga-ui/core/animations';
import { TuiHintDirective } from '@taiga-ui/core/directives/hint';
import { TuiHintService } from '@taiga-ui/core/services';
import { Observable } from 'rxjs';
import { skip, takeUntil } from 'rxjs/operators';
import { CommonModule } from '@angular/common';
import { PolymorpheusModule } from '@tinkoff/ng-polymorpheus';
import { ANIMATION_FRAME, WINDOW } from '@ng-web-apis/common';
import { TuiPointerHintDirective } from '@taiga-ui/core/directives/pointer-hint';

var TuiHintsHostComponent = /** @class */ (function () {
    function TuiHintsHostComponent(elementRef, hints$, changeDetectorRef, destroy$) {
        var _this = this;
        this.elementRef = elementRef;
        this.changeDetectorRef = changeDetectorRef;
        /**
         * @awful TODO: remove hints variable
         * and use hints$ after resolving issue with Change Detection
         */
        this.hints = [];
        hints$.pipe(skip(1), takeUntil(destroy$)).subscribe(function (hints) {
            _this.hints = hints;
            _this.changeDetectorRef.detectChanges();
        });
    }
    Object.defineProperty(TuiHintsHostComponent.prototype, "clientRect", {
        get: function () {
            return this.elementRef.nativeElement.getBoundingClientRect();
        },
        enumerable: true,
        configurable: true
    });
    TuiHintsHostComponent.prototype.onHovered = function (hovered, directive) {
        if (directive instanceof TuiHintDirective) {
            directive.componentHovered$.next(hovered);
        }
    };
    TuiHintsHostComponent.ctorParameters = function () { return [
        { type: ElementRef, decorators: [{ type: Inject, args: [ElementRef,] }] },
        { type: TuiHintService, decorators: [{ type: Inject, args: [TuiHintService,] }] },
        { type: ChangeDetectorRef, decorators: [{ type: Inject, args: [ChangeDetectorRef,] }] },
        { type: Observable, decorators: [{ type: Inject, args: [TuiDestroyService,] }] }
    ]; };
    TuiHintsHostComponent = __decorate([
        Component({
            selector: 'tui-hints-host',
            template: "<tui-hint-box\n    *ngFor=\"let hint of hints\"\n    role=\"tooltip\"\n    [attr.id]=\"hint.id\"\n    [@tuiFadeIn]\n    [mode]=\"hint.mode\"\n    [direction]=\"hint.direction\"\n    [hint]=\"hint\"\n    (tuiHoveredChange)=\"onHovered($event, hint)\"\n>\n    <div polymorpheus-outlet [content]=\"hint.content\">\n        <ng-template let-text>\n            <span class=\"text\">{{text}}</span>\n        </ng-template>\n    </div>\n</tui-hint-box>\n",
            changeDetection: ChangeDetectionStrategy.OnPush,
            animations: [tuiFadeIn],
            providers: [TuiDestroyService],
            host: {
                'aria-live': 'polite',
            },
            styles: [":host{position:fixed;bottom:0;left:0;width:100%;height:0}.text{white-space:pre-wrap}"]
        }),
        __param(0, Inject(ElementRef)),
        __param(1, Inject(TuiHintService)),
        __param(2, Inject(ChangeDetectorRef)),
        __param(3, Inject(TuiDestroyService))
    ], TuiHintsHostComponent);
    return TuiHintsHostComponent;
}());

var SPACE = 8;
var BORDER_WIDTH = 1;
var LEFT_PADDING = 16;
var TOP_PADDING = 12;
var ARROW_SIZE = 8;
var ARROW_OFFSET = 16;
var ARROWHEAD_OFFSET = ARROW_OFFSET + (ARROW_SIZE * Math.sqrt(2)) / 2;
var reverseDirectionsVertical = {
    'top-left': 'bottom-left',
    'top-right': 'bottom-right',
    'bottom-left': 'top-left',
    'bottom-right': 'top-right',
    left: 'right',
    right: 'left',
};
var reverseDirectionsHorizontal = {
    'top-left': 'top-right',
    'top-right': 'top-left',
    'bottom-left': 'bottom-right',
    'bottom-right': 'bottom-left',
    left: 'right',
    right: 'left',
};
// TODO: consider abstracting UI and move to CDK
// Ambient type cannot be used without dynamic https://github.com/angular/angular/issues/23395
// @dynamic
var TuiHintBoxComponent = /** @class */ (function () {
    function TuiHintBoxComponent(animationFrame$, destroy$, ngZone, elementRef, windowRef, isMobile, hintsHost) {
        var _this = this;
        this.elementRef = elementRef;
        this.windowRef = windowRef;
        this.isMobile = isMobile;
        this.hintsHost = hintsHost;
        this.direction = 'bottom-left';
        this.mode = null;
        animationFrame$.pipe(tuiZonefree(ngZone), takeUntil(destroy$)).subscribe(function () {
            _this.calculatePosition();
        });
    }
    Object.defineProperty(TuiHintBoxComponent.prototype, "isUntouchable", {
        get: function () {
            return this.hint instanceof TuiPointerHintDirective;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Calculates wrapper position.
     * Styles are set directly to avoid visual shake of element
     */
    TuiHintBoxComponent.prototype.calculatePosition = function () {
        if (this.mode !== "overflow" /* Overflow */) {
            this.calculateCoordinates();
        }
        else {
            this.setOverflowStyles();
        }
    };
    TuiHintBoxComponent.prototype.calculateCoordinates = function () {
        if (this.isMobile) {
            this.calculateMobileCoordinates();
            return;
        }
        if (!this.hint) {
            throw new Error('Hint directive is missing');
        }
        var hostRect = this.hint.getElementClientRect();
        var portalRect = this.hintsHost.clientRect;
        var tooltip = this.elementRef.nativeElement;
        var style = tooltip.style;
        var tooltipRect = tooltip.getBoundingClientRect();
        var isHostLong = hostRect.width > ARROWHEAD_OFFSET * 2;
        var directions = [
            'left',
            'right',
            'bottom-left',
            'bottom-right',
            'top-left',
            'top-right',
        ];
        var top = 0;
        var left = 0;
        var direction = this.direction;
        var horizontalTop = hostRect.top + hostRect.height / 2 - tooltipRect.height / 2 - portalRect.top;
        var horizontalLeft = hostRect.left - tooltipRect.width - SPACE - portalRect.left;
        var horizontalRight = hostRect.left + hostRect.width + SPACE - portalRect.left;
        var verticalBottom = hostRect.bottom + SPACE - portalRect.top;
        var verticalTop = hostRect.top - tooltipRect.height - SPACE - portalRect.top;
        var verticalRight = isHostLong
            ? hostRect.left - portalRect.left
            : hostRect.left + hostRect.width / 2 - ARROWHEAD_OFFSET - portalRect.left;
        var verticalLeft = isHostLong
            ? hostRect.left - tooltipRect.width + hostRect.width - portalRect.left
            : hostRect.left -
                tooltipRect.width +
                hostRect.width / 2 +
                ARROWHEAD_OFFSET -
                portalRect.left;
        directions.splice(directions.indexOf(direction), 1);
        while (true) {
            switch (direction) {
                case 'left':
                    top = horizontalTop;
                    left = horizontalLeft;
                    break;
                case 'right':
                    top = horizontalTop;
                    left = horizontalRight;
                    break;
                case 'top-right':
                    top = verticalTop;
                    left = verticalRight;
                    break;
                case 'top-left':
                    top = verticalTop;
                    left = verticalLeft;
                    break;
                case 'bottom-right':
                    top = verticalBottom;
                    left = verticalRight;
                    break;
                case 'bottom-left':
                    top = verticalBottom;
                    left = verticalLeft;
                    break;
            }
            var verticalFit = top + portalRect.top > SPACE &&
                top + tooltipRect.height + SPACE + portalRect.top <
                    this.windowRef.innerHeight;
            var horizontalFit = left > SPACE &&
                left + tooltipRect.width + SPACE + portalRect.left < portalRect.width;
            if (directions.length === 0 || (verticalFit && horizontalFit)) {
                break;
            }
            direction = verticalFit
                ? reverseDirectionsHorizontal[direction]
                : reverseDirectionsVertical[direction];
            direction =
                directions.splice(directions.indexOf(direction), 1)[0] || direction;
        }
        style.top = px(top);
        style.left = px(left);
        tooltip.setAttribute('data-tui-host-direction', direction);
    };
    TuiHintBoxComponent.prototype.calculateMobileCoordinates = function () {
        if (!this.hint) {
            throw new Error('Hint directive is missing');
        }
        var hostRect = this.hint.getElementClientRect();
        var portalRect = this.hintsHost.clientRect;
        var tooltip = this.elementRef.nativeElement;
        var style = tooltip.style;
        var tooltipRect = tooltip.getBoundingClientRect();
        var verticalTop = hostRect.top - tooltipRect.height - SPACE - portalRect.top;
        var verticalBottom = hostRect.bottom + SPACE - portalRect.top;
        var verticalTopFit = verticalTop + portalRect.top > SPACE &&
            hostRect.top < this.windowRef.innerHeight;
        var verticalBottomFit = hostRect.bottom > 0 &&
            hostRect.bottom + 2 * SPACE + tooltipRect.height < this.windowRef.innerHeight;
        var direction = (this.direction.includes('top') && verticalTopFit) || !verticalBottomFit
            ? 'top'
            : 'bottom';
        var attemptedLeft = portalRect.left + hostRect.left + hostRect.width / 2 - tooltipRect.width / 2;
        var left = Math.max(attemptedLeft + tooltipRect.width + SPACE > portalRect.right
            ? portalRect.right - SPACE - tooltipRect.width
            : attemptedLeft, SPACE * 2);
        style.left = px(left);
        style.top = direction === 'top' ? px(verticalTop) : px(verticalBottom);
        if (this.arrow) {
            this.arrow.nativeElement.style.left = px(hostRect.left <= SPACE * 2 && hostRect.width > ARROW_OFFSET * 2
                ? ARROW_OFFSET
                : hostRect.left + hostRect.width / 2 - left - ARROW_SIZE / 2);
        }
        tooltip.setAttribute('data-tui-host-direction', direction);
    };
    TuiHintBoxComponent.prototype.setOverflowStyles = function () {
        if (!this.hint) {
            throw new Error('Hint directive is missing');
        }
        var hostRect = this.hint.getElementClientRect();
        var style = this.elementRef.nativeElement.style;
        style.top = px(hostRect.top - window.innerHeight - TOP_PADDING - BORDER_WIDTH);
        style.left = px(hostRect.left - LEFT_PADDING - BORDER_WIDTH);
        style.width = px(hostRect.width + LEFT_PADDING * 2 + BORDER_WIDTH * 2);
    };
    TuiHintBoxComponent.ctorParameters = function () { return [
        { type: Observable, decorators: [{ type: Inject, args: [ANIMATION_FRAME,] }] },
        { type: Observable, decorators: [{ type: Inject, args: [TuiDestroyService,] }] },
        { type: NgZone, decorators: [{ type: Inject, args: [NgZone,] }] },
        { type: ElementRef, decorators: [{ type: Inject, args: [ElementRef,] }] },
        { type: Window, decorators: [{ type: Inject, args: [WINDOW,] }] },
        { type: Boolean, decorators: [{ type: Inject, args: [TUI_IS_MOBILE,] }] },
        { type: TuiHintsHostComponent, decorators: [{ type: Inject, args: [TuiHintsHostComponent,] }] }
    ]; };
    __decorate([
        Input()
    ], TuiHintBoxComponent.prototype, "hint", void 0);
    __decorate([
        Input(),
        tuiDefaultProp()
    ], TuiHintBoxComponent.prototype, "direction", void 0);
    __decorate([
        Input(),
        HostBinding('attr.data-mode'),
        tuiDefaultProp()
    ], TuiHintBoxComponent.prototype, "mode", void 0);
    __decorate([
        ViewChild('arrow')
    ], TuiHintBoxComponent.prototype, "arrow", void 0);
    __decorate([
        tuiPure,
        HostBinding('class._untouchable')
    ], TuiHintBoxComponent.prototype, "isUntouchable", null);
    TuiHintBoxComponent = __decorate([
        Component({
            selector: 'tui-hint-box',
            template: "<!-- @bad TODO: Refactor to use this arrow in all cases -->\n<div *ngIf=\"isMobile\" #arrow class=\"arrow\"></div>\n<div class=\"tooltip\" automation-id=\"tui-hint-box__tooltip\">\n    <ng-content></ng-content>\n</div>\n",
            changeDetection: ChangeDetectionStrategy.OnPush,
            providers: [TuiDestroyService],
            styles: [":host{position:absolute;top:0;left:0;max-width:288px;min-height:var(--tui-height-m);padding:12px 16px;background:var(--tui-primary);border-radius:var(--tui-radius-l);color:var(--tui-primary-text);box-sizing:border-box}:host .arrow,:host:not([data-mode=overflow]):before{content:'';position:absolute;width:8px;height:8px;border-radius:2px;box-sizing:border-box;background-color:inherit;transform:rotate(45deg)}:host[data-tui-host-direction=top] .arrow{bottom:-4px}:host[data-tui-host-direction=bottom] .arrow{top:-4px}:host[data-tui-host-direction=bottom]:before,:host[data-tui-host-direction=top]:before{display:none}:host[data-tui-host-direction=top-left]:before,:host[data-tui-host-direction=top-right]:before{bottom:-4px}:host[data-tui-host-direction=bottom-left]:before,:host[data-tui-host-direction=bottom-right]:before{top:-4px}:host[data-tui-host-direction=bottom-left]:before,:host[data-tui-host-direction=top-left]:before{right:17.2px}:host[data-tui-host-direction=bottom-right]:before,:host[data-tui-host-direction=top-right]:before{left:17.2px}:host[data-tui-host-direction=left]:before,:host[data-tui-host-direction=right]:before{top:50%;margin-top:-4px}:host[data-tui-host-direction=left]:before{right:-4px}:host[data-tui-host-direction=right]:before{left:-4px}:host[data-mode=error]{background-color:var(--tui-error-fill)}:host[data-mode=onDark],:host[data-mode=overflow]{box-shadow:0 8px 16px rgba(51,51,51,.2);border:1px solid var(--tui-base-03);background-color:var(--tui-base-01);color:var(--tui-text-01)}:host[data-mode=onDark]:before,:host[data-mode=overflow]:before{border:1px solid var(--tui-base-03)}:host[data-mode=onDark][data-tui-host-direction=left]:before,:host[data-mode=overflow][data-tui-host-direction=left]:before{border-left-color:transparent;border-bottom-color:transparent}:host[data-mode=onDark][data-tui-host-direction=right]:before,:host[data-mode=overflow][data-tui-host-direction=right]:before{border-right-color:transparent;border-top-color:transparent}:host[data-mode=onDark][data-tui-host-direction=top-left]:before,:host[data-mode=onDark][data-tui-host-direction=top-right]:before,:host[data-mode=overflow][data-tui-host-direction=top-left]:before,:host[data-mode=overflow][data-tui-host-direction=top-right]:before{border-left-color:transparent;border-top-color:transparent}:host[data-mode=onDark][data-tui-host-direction=bottom-left]:before,:host[data-mode=onDark][data-tui-host-direction=bottom-right]:before,:host[data-mode=overflow][data-tui-host-direction=bottom-left]:before,:host[data-mode=overflow][data-tui-host-direction=bottom-right]:before{border-right-color:transparent;border-bottom-color:transparent}:host[data-mode=overflow]{max-width:none}:host._untouchable{pointer-events:none}.tooltip{font:var(--tui-font-text-s);word-wrap:break-word}:host[data-mode=overflow] .tooltip{font:inherit}"]
        }),
        __param(0, Inject(ANIMATION_FRAME)),
        __param(1, Inject(TuiDestroyService)),
        __param(2, Inject(NgZone)),
        __param(3, Inject(ElementRef)),
        __param(4, Inject(WINDOW)),
        __param(5, Inject(TUI_IS_MOBILE)),
        __param(6, Inject(TuiHintsHostComponent))
    ], TuiHintBoxComponent);
    return TuiHintBoxComponent;
}());

var TuiHintBoxModule = /** @class */ (function () {
    function TuiHintBoxModule() {
    }
    TuiHintBoxModule = __decorate([
        NgModule({
            imports: [CommonModule],
            declarations: [TuiHintBoxComponent],
            exports: [TuiHintBoxComponent],
        })
    ], TuiHintBoxModule);
    return TuiHintBoxModule;
}());

var TuiHintsHostModule = /** @class */ (function () {
    function TuiHintsHostModule() {
    }
    TuiHintsHostModule = __decorate([
        NgModule({
            imports: [CommonModule, PolymorpheusModule, TuiHoveredModule, TuiHintBoxModule],
            declarations: [TuiHintsHostComponent],
            exports: [TuiHintsHostComponent],
            entryComponents: [TuiHintsHostComponent],
        })
    ], TuiHintsHostModule);
    return TuiHintsHostModule;
}());

/**
 * Generated bundle index. Do not edit.
 */

export { TuiHintBoxComponent, TuiHintBoxModule, TuiHintsHostComponent, TuiHintsHostModule };
//# sourceMappingURL=taiga-ui-core-components-hints-host.js.map
