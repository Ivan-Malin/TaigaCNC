import { tuiAssert, isSafari, isNativeFocused, getDocumentOrShadowRoot, CHAR_NO_BREAK_SPACE, CHAR_EN_DASH } from '@taiga-ui/cdk';
import { __spread } from 'tslib';
import { MASK_CARET_TRAP, TUI_DIGIT_REGEXP, TUI_NON_DIGITS_REGEXP } from '@taiga-ui/core/constants';
import { otherDecimalSymbol } from '@taiga-ui/core/utils/format';

/**
 * Used to finish a number with zeros to a given precision
 */
function tuiCreateAutoCorrectedNumberPipe(decimalLimit, decimalSymbol, nativeInput) {
    if (decimalLimit === void 0) { decimalLimit = 0; }
    if (decimalSymbol === void 0) { decimalSymbol = ','; }
    tuiAssert.assert(Number.isInteger(decimalLimit));
    tuiAssert.assert(decimalLimit >= 0);
    // Guess for which browser I need this :)
    var previousCaret = -1;
    var unlucky = !!nativeInput && isSafari(nativeInput);
    if (nativeInput && unlucky) {
        nativeInput.addEventListener('beforeinput', function () {
            previousCaret = nativeInput.selectionStart || 0;
        });
    }
    return function (conformedValue, config) {
        // remove these hacks after text mask library has changed
        if (nativeInput && unlucky && isNativeFocused(nativeInput)) {
            var caret_1 = calculateSafariCaret(config.previousConformedValue, conformedValue, previousCaret);
            setTimeout(function () {
                nativeInput.setSelectionRange(caret_1, caret_1);
            });
        }
        if (nativeInput &&
            nativeInput.ownerDocument !== getDocumentOrShadowRoot(nativeInput) &&
            isNativeFocused(nativeInput) &&
            config.currentCaretPosition) {
            var realCaretPosition_1 = config.currentCaretPosition +
                calculateCaretGap(config.previousConformedValue, conformedValue);
            setTimeout(function () {
                nativeInput.setSelectionRange(realCaretPosition_1, realCaretPosition_1);
            });
        }
        if (conformedValue === '' || !decimalLimit) {
            return { value: conformedValue };
        }
        var withDecimalSymbol = addDecimalSymbolIfNeeded(conformedValue, decimalSymbol);
        var decimalPart = withDecimalSymbol.split(decimalSymbol)[1];
        var zeroPaddingSize = decimalLimit - decimalPart.length;
        return {
            value: withDecimalSymbol + '0'.repeat(zeroPaddingSize),
        };
    };
}
function addDecimalSymbolIfNeeded(value, decimalSymbol) {
    if (decimalSymbol === void 0) { decimalSymbol = ','; }
    return value.indexOf(decimalSymbol) === -1 ? value + decimalSymbol : value;
}
function calculateSafariCaret(previousValue, current, previousCaret, decimalSymbol) {
    if (previousValue === void 0) { previousValue = ''; }
    if (decimalSymbol === void 0) { decimalSymbol = ','; }
    var tailRegex = new RegExp(decimalSymbol + ".+");
    var previousWithoutTail = previousValue.replace(tailRegex, '');
    var currentWithoutTail = current.replace(tailRegex, '');
    var pasteOrCutOperation = Math.abs(previousWithoutTail.length - currentWithoutTail.length) > 2;
    if (pasteOrCutOperation) {
        return current.length;
    }
    if (previousValue.length === current.length) {
        if (previousValue.indexOf(decimalSymbol) <= previousCaret) {
            return calculateChangedTailIndex(previousValue, current);
        }
        return previousWithoutTail === currentWithoutTail
            ? previousCaret - 1
            : previousCaret + 1;
    }
    if (previousValue.length === 0) {
        return 1;
    }
    var changeLength = current.length - previousValue.length;
    return previousCaret + changeLength;
}
function calculateChangedTailIndex(previous, current) {
    for (var i = 0; i < current.length; i++) {
        if (previous[i] !== current[i]) {
            return current[i] === '0' ? i : i + 1;
        }
    }
    return current.length;
}
function calculateCaretGap(previousValue, current) {
    if (previousValue === void 0) { previousValue = ''; }
    var pasteOrCutOperation = Math.abs(previousValue.length - current.length) > 2;
    if (pasteOrCutOperation) {
        return 0;
    }
    var wereSpaces = previousValue.split(CHAR_NO_BREAK_SPACE).length;
    var nowSpaces = current.split(CHAR_NO_BREAK_SPACE).length;
    return nowSpaces - wereSpaces;
}

var ASSERTION = 'Correction function must return single char or null';
function tuiCreateCorrectionMask(allowed, correctionHandler) {
    return function (rawValue) {
        var mask = rawValue.split('').reduce(function (result, char, index) {
            var corrected = correctionHandler(char, index);
            tuiAssert.assert(corrected === null || corrected.length === 1, ASSERTION);
            if (!allowed.test(char) && !corrected) {
                return result;
            }
            if (allowed.test(char)) {
                return __spread(result, [allowed]);
            }
            if (corrected) {
                return __spread(result, [corrected, MASK_CARET_TRAP]);
            }
            return result;
        }, []);
        var lastIndex = mask.lastIndexOf(MASK_CARET_TRAP);
        var filtered = mask.filter(function (item, index) { return item !== MASK_CARET_TRAP || index === lastIndex; });
        return filtered.some(function (item) { return item !== allowed; })
            ? __spread(filtered, [allowed]) : filtered;
    };
}

var NON_ZERO_DIGIT = /[1-9]/;
/**
 * Adaptation for {@link https://github.com/text-mask/text-mask/tree/master/addons#createnumbermask `createNumberMask`}
 */
function tuiCreateNumberMask(_a) {
    var _b = _a === void 0 ? {} : _a, _c = _b.allowDecimal, allowDecimal = _c === void 0 ? false : _c, _d = _b.decimalSymbol, decimalSymbol = _d === void 0 ? ',' : _d, _e = _b.autoCorrectDecimalSymbol, autoCorrectDecimalSymbol = _e === void 0 ? true : _e, _f = _b.decimalLimit, decimalLimit = _f === void 0 ? 2 : _f, _g = _b.requireDecimal, requireDecimal = _g === void 0 ? false : _g, _h = _b.allowNegative, allowNegative = _h === void 0 ? false : _h, _j = _b.integerLimit, integerLimit = _j === void 0 ? 0 : _j;
    tuiAssert.assert(Number.isInteger(decimalLimit));
    tuiAssert.assert(decimalLimit > 0);
    tuiAssert.assert(Number.isInteger(integerLimit));
    tuiAssert.assert(integerLimit >= 0);
    return function (rawValue, _a) {
        var previousConformedValue = _a.previousConformedValue;
        if (previousConformedValue && requireDecimal) {
            var conformedWithoutSeparator = rawValue
                .split(CHAR_NO_BREAK_SPACE)
                .join('');
            var previousConformedValueWithoutDecimalSymbolAndSeparator = previousConformedValue
                .split(CHAR_NO_BREAK_SPACE)
                .join('')
                .split(',')
                .join('');
            // Forbid removal of decimal separator if decimal part is required
            if (conformedWithoutSeparator ===
                previousConformedValueWithoutDecimalSymbolAndSeparator) {
                rawValue = previousConformedValue;
            }
        }
        var isNegative = (rawValue[0] === '-' || rawValue[0] === CHAR_EN_DASH) && allowNegative;
        if (isDecimalSymbol(rawValue, decimalSymbol, autoCorrectDecimalSymbol) &&
            allowDecimal) {
            return ['0', decimalSymbol, TUI_DIGIT_REGEXP];
        }
        if (isNegative) {
            rawValue = rawValue.substr(1);
        }
        var decimalIndex = getDecimalSymbolIndex(rawValue, decimalSymbol, autoCorrectDecimalSymbol);
        var hasDecimal = decimalIndex !== -1;
        var integer = hasDecimal ? rawValue.slice(0, decimalIndex) : rawValue;
        var thousandSeparators = integer.match(new RegExp(CHAR_NO_BREAK_SPACE, 'g')) || [];
        var integerCapped = integerLimit
            ? integer.slice(0, integerLimit + thousandSeparators.length)
            : integer;
        var integerCappedClean = integerCapped
            .replace(TUI_NON_DIGITS_REGEXP, '')
            .replace(/^0+(?!\.|$)/, '0');
        var withSeparator = addThousandsSeparator(integerCappedClean);
        var mask = convertToMask(withSeparator);
        if ((hasDecimal && allowDecimal) || requireDecimal) {
            var fraction = hasDecimal
                ? convertToMask(rawValue.slice(decimalIndex + 1).replace(TUI_NON_DIGITS_REGEXP, ''))
                : [];
            var fractionCapped = decimalLimit
                ? fraction.slice(0, decimalLimit)
                : fraction;
            if (rawValue[decimalIndex] !== otherDecimalSymbol(decimalSymbol)) {
                mask.push(MASK_CARET_TRAP);
            }
            mask.push.apply(mask, __spread([decimalSymbol, MASK_CARET_TRAP], fractionCapped));
            for (var i = 0; i < decimalLimit - fractionCapped.length; i++) {
                mask.push(TUI_DIGIT_REGEXP);
            }
        }
        if (isNegative) {
            if (mask.length === 0) {
                mask.push(TUI_DIGIT_REGEXP);
            }
            mask.unshift('-');
        }
        return preventLeadingZeroes(mask);
    };
}
function preventLeadingZeroes(mask) {
    var firstDigitIndex = mask.indexOf(TUI_DIGIT_REGEXP);
    if (firstDigitIndex !== -1 && mask[firstDigitIndex + 1] === TUI_DIGIT_REGEXP) {
        mask[firstDigitIndex] = NON_ZERO_DIGIT;
    }
    return mask;
}
function getDecimalSymbolIndex(str, decimalSymbol, autoCorrectDecimalSymbol) {
    if (!autoCorrectDecimalSymbol) {
        return str.lastIndexOf(decimalSymbol);
    }
    return Math.max(str.lastIndexOf(decimalSymbol), str.lastIndexOf(otherDecimalSymbol(decimalSymbol)));
}
function isDecimalSymbol(str, decimalSymbol, autoCorrectDecimalSymbol) {
    if (autoCorrectDecimalSymbol) {
        return /^[,.]$/.test(str);
    }
    return str === decimalSymbol;
}
function convertToMask(strNumber) {
    return strNumber
        .split('')
        .map(function (char) { return (TUI_DIGIT_REGEXP.test(char) ? TUI_DIGIT_REGEXP : char); });
}
function addThousandsSeparator(strNumber) {
    return strNumber.length > 3
        ? strNumber.replace(/\B(?=(\d{3})+(?!\d))/g, CHAR_NO_BREAK_SPACE)
        : strNumber;
}

function maskedMoneyValueIsEmpty(value) {
    switch (value) {
        case '':
        case '-':
        case ',':
        case '-,':
            return true;
        default:
            return false;
    }
}

function maskedNumberStringToNumber(value) {
    return parseFloat(value.split(CHAR_NO_BREAK_SPACE).join('').split(',').join('.'));
}

/**
 * Generated bundle index. Do not edit.
 */

export { maskedMoneyValueIsEmpty, maskedNumberStringToNumber, tuiCreateAutoCorrectedNumberPipe, tuiCreateCorrectionMask, tuiCreateNumberMask };
//# sourceMappingURL=taiga-ui-core-utils-mask.js.map
