{"version":3,"file":"taiga-ui-core-utils-mask.js","sources":["ng://@taiga-ui/core/utils/mask/create-auto-corrected-money-pipe.ts","ng://@taiga-ui/core/utils/mask/create-correction-mask.ts","ng://@taiga-ui/core/utils/mask/create-number-mask.ts","ng://@taiga-ui/core/utils/mask/masked-money-value-is-empty.ts","ng://@taiga-ui/core/utils/mask/masked-number-string-to-number.ts","ng://@taiga-ui/core/utils/mask/taiga-ui-core-utils-mask.ts"],"sourcesContent":["import {\n    CHAR_NO_BREAK_SPACE,\n    getDocumentOrShadowRoot,\n    isNativeFocused,\n    isSafari,\n    tuiAssert,\n} from '@taiga-ui/cdk';\nimport {TuiTextMaskPipeHandler} from '@taiga-ui/core/mask';\nimport {TuiDecimalSymbol} from '@taiga-ui/core/types';\n\n/**\n * Used to finish a number with zeros to a given precision\n */\nexport function tuiCreateAutoCorrectedNumberPipe(\n    decimalLimit: number = 0,\n    decimalSymbol: TuiDecimalSymbol = ',',\n    nativeInput?: HTMLInputElement,\n): TuiTextMaskPipeHandler {\n    tuiAssert.assert(Number.isInteger(decimalLimit));\n    tuiAssert.assert(decimalLimit >= 0);\n\n    // Guess for which browser I need this :)\n    let previousCaret = -1;\n\n    const unlucky = !!nativeInput && isSafari(nativeInput);\n\n    if (nativeInput && unlucky) {\n        nativeInput.addEventListener('beforeinput', () => {\n            previousCaret = nativeInput.selectionStart || 0;\n        });\n    }\n\n    return (conformedValue, config) => {\n        // remove these hacks after text mask library has changed\n        if (nativeInput && unlucky && isNativeFocused(nativeInput)) {\n            const caret = calculateSafariCaret(\n                config.previousConformedValue,\n                conformedValue,\n                previousCaret,\n            );\n\n            setTimeout(() => {\n                nativeInput.setSelectionRange(caret, caret);\n            });\n        }\n\n        if (\n            nativeInput &&\n            nativeInput.ownerDocument !== getDocumentOrShadowRoot(nativeInput) &&\n            isNativeFocused(nativeInput) &&\n            config.currentCaretPosition\n        ) {\n            const realCaretPosition =\n                config.currentCaretPosition +\n                calculateCaretGap(config.previousConformedValue, conformedValue);\n\n            setTimeout(() => {\n                nativeInput.setSelectionRange(realCaretPosition, realCaretPosition);\n            });\n        }\n\n        if (conformedValue === '' || !decimalLimit) {\n            return {value: conformedValue};\n        }\n\n        const withDecimalSymbol = addDecimalSymbolIfNeeded(conformedValue, decimalSymbol);\n        const decimalPart = withDecimalSymbol.split(decimalSymbol)[1];\n        const zeroPaddingSize = decimalLimit - decimalPart.length;\n\n        return {\n            value: withDecimalSymbol + '0'.repeat(zeroPaddingSize),\n        };\n    };\n}\n\nfunction addDecimalSymbolIfNeeded(\n    value: string,\n    decimalSymbol: TuiDecimalSymbol = ',',\n): string {\n    return value.indexOf(decimalSymbol) === -1 ? value + decimalSymbol : value;\n}\n\nfunction calculateSafariCaret(\n    previousValue: string = '',\n    current: string,\n    previousCaret: number,\n    decimalSymbol: string = ',',\n): number {\n    const tailRegex = new RegExp(`${decimalSymbol}.+`);\n    const previousWithoutTail = previousValue.replace(tailRegex, '');\n    const currentWithoutTail = current.replace(tailRegex, '');\n\n    const pasteOrCutOperation =\n        Math.abs(previousWithoutTail.length - currentWithoutTail.length) > 2;\n\n    if (pasteOrCutOperation) {\n        return current.length;\n    }\n\n    if (previousValue.length === current.length) {\n        if (previousValue.indexOf(decimalSymbol) <= previousCaret) {\n            return calculateChangedTailIndex(previousValue, current);\n        }\n\n        return previousWithoutTail === currentWithoutTail\n            ? previousCaret - 1\n            : previousCaret + 1;\n    }\n\n    if (previousValue.length === 0) {\n        return 1;\n    }\n\n    const changeLength = current.length - previousValue.length;\n\n    return previousCaret + changeLength;\n}\n\nfunction calculateChangedTailIndex(previous: string, current: string): number {\n    for (let i = 0; i < current.length; i++) {\n        if (previous[i] !== current[i]) {\n            return current[i] === '0' ? i : i + 1;\n        }\n    }\n\n    return current.length;\n}\n\nfunction calculateCaretGap(previousValue: string = '', current: string): number {\n    const pasteOrCutOperation = Math.abs(previousValue.length - current.length) > 2;\n\n    if (pasteOrCutOperation) {\n        return 0;\n    }\n\n    const wereSpaces = previousValue.split(CHAR_NO_BREAK_SPACE).length;\n    const nowSpaces = current.split(CHAR_NO_BREAK_SPACE).length;\n\n    return nowSpaces - wereSpaces;\n}\n","import {tuiAssert} from '@taiga-ui/cdk';\nimport {MASK_CARET_TRAP} from '@taiga-ui/core/constants';\nimport {\n    TuiTextMaskCorrectionHandler,\n    TuiTextMaskList,\n    TuiTextMaskListHandler,\n} from '@taiga-ui/core/mask';\n\nconst ASSERTION = 'Correction function must return single char or null';\n\nexport function tuiCreateCorrectionMask(\n    allowed: RegExp,\n    correctionHandler: TuiTextMaskCorrectionHandler,\n): TuiTextMaskListHandler {\n    return rawValue => {\n        const mask = rawValue.split('').reduce<TuiTextMaskList>((result, char, index) => {\n            const corrected = correctionHandler(char, index);\n\n            tuiAssert.assert(corrected === null || corrected.length === 1, ASSERTION);\n\n            if (!allowed.test(char) && !corrected) {\n                return result;\n            }\n\n            if (allowed.test(char)) {\n                return [...result, allowed];\n            }\n\n            if (corrected) {\n                return [...result, corrected, MASK_CARET_TRAP];\n            }\n\n            return result;\n        }, []);\n        const lastIndex = mask.lastIndexOf(MASK_CARET_TRAP);\n        const filtered = mask.filter(\n            (item, index) => item !== MASK_CARET_TRAP || index === lastIndex,\n        );\n\n        return filtered.some(item => item !== allowed)\n            ? [...filtered, allowed]\n            : filtered;\n    };\n}\n","import {CHAR_EN_DASH, CHAR_NO_BREAK_SPACE, tuiAssert} from '@taiga-ui/cdk';\nimport {\n    MASK_CARET_TRAP,\n    TUI_DIGIT_REGEXP,\n    TUI_NON_DIGITS_REGEXP,\n} from '@taiga-ui/core/constants';\nimport {TuiNumberMaskOptions, TuiTextMaskListHandler} from '@taiga-ui/core/mask';\nimport {TuiDecimalSymbol} from '@taiga-ui/core/types';\nimport {otherDecimalSymbol} from '@taiga-ui/core/utils/format';\n\nconst NON_ZERO_DIGIT = /[1-9]/;\n\n/**\n * Adaptation for {@link https://github.com/text-mask/text-mask/tree/master/addons#createnumbermask `createNumberMask`}\n */\nexport function tuiCreateNumberMask({\n    allowDecimal = false,\n    decimalSymbol = ',',\n    autoCorrectDecimalSymbol = true,\n    decimalLimit = 2,\n    requireDecimal = false,\n    allowNegative = false,\n    integerLimit = 0,\n}: TuiNumberMaskOptions = {}): TuiTextMaskListHandler {\n    tuiAssert.assert(Number.isInteger(decimalLimit));\n    tuiAssert.assert(decimalLimit > 0);\n    tuiAssert.assert(Number.isInteger(integerLimit));\n    tuiAssert.assert(integerLimit >= 0);\n\n    return (rawValue, {previousConformedValue}) => {\n        if (previousConformedValue && requireDecimal) {\n            const conformedWithoutSeparator = rawValue\n                .split(CHAR_NO_BREAK_SPACE)\n                .join('');\n            const previousConformedValueWithoutDecimalSymbolAndSeparator = previousConformedValue\n                .split(CHAR_NO_BREAK_SPACE)\n                .join('')\n                .split(',')\n                .join('');\n\n            // Forbid removal of decimal separator if decimal part is required\n            if (\n                conformedWithoutSeparator ===\n                previousConformedValueWithoutDecimalSymbolAndSeparator\n            ) {\n                rawValue = previousConformedValue;\n            }\n        }\n\n        const isNegative =\n            (rawValue[0] === '-' || rawValue[0] === CHAR_EN_DASH) && allowNegative;\n\n        if (\n            isDecimalSymbol(rawValue, decimalSymbol, autoCorrectDecimalSymbol) &&\n            allowDecimal\n        ) {\n            return ['0', decimalSymbol, TUI_DIGIT_REGEXP];\n        }\n\n        if (isNegative) {\n            rawValue = rawValue.substr(1);\n        }\n\n        const decimalIndex = getDecimalSymbolIndex(\n            rawValue,\n            decimalSymbol,\n            autoCorrectDecimalSymbol,\n        );\n        const hasDecimal = decimalIndex !== -1;\n        const integer = hasDecimal ? rawValue.slice(0, decimalIndex) : rawValue;\n        const thousandSeparators =\n            integer.match(new RegExp(CHAR_NO_BREAK_SPACE, 'g')) || [];\n        const integerCapped = integerLimit\n            ? integer.slice(0, integerLimit + thousandSeparators.length)\n            : integer;\n        const integerCappedClean = integerCapped\n            .replace(TUI_NON_DIGITS_REGEXP, '')\n            .replace(/^0+(?!\\.|$)/, '0');\n        const withSeparator = addThousandsSeparator(integerCappedClean);\n        const mask = convertToMask(withSeparator);\n\n        if ((hasDecimal && allowDecimal) || requireDecimal) {\n            const fraction = hasDecimal\n                ? convertToMask(\n                      rawValue.slice(decimalIndex + 1).replace(TUI_NON_DIGITS_REGEXP, ''),\n                  )\n                : [];\n            const fractionCapped = decimalLimit\n                ? fraction.slice(0, decimalLimit)\n                : fraction;\n\n            if (rawValue[decimalIndex] !== otherDecimalSymbol(decimalSymbol)) {\n                mask.push(MASK_CARET_TRAP);\n            }\n\n            mask.push(decimalSymbol, MASK_CARET_TRAP, ...fractionCapped);\n\n            for (let i = 0; i < decimalLimit - fractionCapped.length; i++) {\n                mask.push(TUI_DIGIT_REGEXP);\n            }\n        }\n\n        if (isNegative) {\n            if (mask.length === 0) {\n                mask.push(TUI_DIGIT_REGEXP);\n            }\n\n            mask.unshift('-');\n        }\n\n        return preventLeadingZeroes(mask);\n    };\n}\n\nfunction preventLeadingZeroes(mask: Array<string | RegExp>): Array<string | RegExp> {\n    const firstDigitIndex = mask.indexOf(TUI_DIGIT_REGEXP);\n\n    if (firstDigitIndex !== -1 && mask[firstDigitIndex + 1] === TUI_DIGIT_REGEXP) {\n        mask[firstDigitIndex] = NON_ZERO_DIGIT;\n    }\n\n    return mask;\n}\n\nfunction getDecimalSymbolIndex(\n    str: string,\n    decimalSymbol: TuiDecimalSymbol,\n    autoCorrectDecimalSymbol: boolean,\n): number {\n    if (!autoCorrectDecimalSymbol) {\n        return str.lastIndexOf(decimalSymbol);\n    }\n\n    return Math.max(\n        str.lastIndexOf(decimalSymbol),\n        str.lastIndexOf(otherDecimalSymbol(decimalSymbol)),\n    );\n}\n\nfunction isDecimalSymbol(\n    str: string,\n    decimalSymbol: TuiDecimalSymbol,\n    autoCorrectDecimalSymbol: boolean,\n): boolean {\n    if (autoCorrectDecimalSymbol) {\n        return /^[,.]$/.test(str);\n    }\n\n    return str === decimalSymbol;\n}\n\nfunction convertToMask(strNumber: string): Array<string | RegExp> {\n    return strNumber\n        .split('')\n        .map(char => (TUI_DIGIT_REGEXP.test(char) ? TUI_DIGIT_REGEXP : char));\n}\n\nfunction addThousandsSeparator(strNumber: string): string {\n    return strNumber.length > 3\n        ? strNumber.replace(/\\B(?=(\\d{3})+(?!\\d))/g, CHAR_NO_BREAK_SPACE)\n        : strNumber;\n}\n","export function maskedMoneyValueIsEmpty(value: string): boolean {\n    switch (value) {\n        case '':\n        case '-':\n        case ',':\n        case '-,':\n            return true;\n        default:\n            return false;\n    }\n}\n","import {CHAR_NO_BREAK_SPACE} from '@taiga-ui/cdk';\n\nexport function maskedNumberStringToNumber(value: string): number {\n    return parseFloat(value.split(CHAR_NO_BREAK_SPACE).join('').split(',').join('.'));\n}\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],"names":[],"mappings":"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"}