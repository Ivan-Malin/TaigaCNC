{"version":3,"sources":["ng://@taiga-ui/kit/utils/dom/get-word-range.ts","ng://@taiga-ui/kit/utils/dom/scroll-to-element.ts","ng://@taiga-ui/kit/utils/dom/set-range-offset.ts"],"names":["currentRange","range","cloneRange","startContainer","startOffset","endContainer","endOffset","ownerDocument","treeWalker","createTreeWalker","body","NodeFilter","SHOW_TEXT","svgNodeFilter","currentNode","textContent","container","content","substr","offset","Math","max","lastIndexOf","CHAR_NO_BREAK_SPACE","CHAR_ZERO_WIDTH_SPACE","setStart","previousNode","indexOf","reduce","result","item","min","setEnd","length","nextNode","element","scrolledWidth","offsetWidth","scrollLeft","elementWidth","elementX","getBoundingClientRect","left","elementDidNotFitRight","elementDidNotFitLeft","deltaXRight","deltaXLeft","node","method","nodeType","Node","TEXT_NODE","length_1","nodeValue"],"mappings":"wbAQ6BA,GACzB,IAAMC,EAAQD,EAAaE,aACpBC,EAAAF,EAAAE,eAAgBC,EAAAH,EAAAG,YAAaC,EAAAJ,EAAAI,aAAcC,EAAAL,EAAAK,UAC3CC,EAAAJ,EAAAI,cAEP,IAAKA,EACD,OAAON,EAGX,IAAMO,EAAaD,EAAcE,iBAC7BF,EAAcG,KACdC,WAAWC,UACXC,EAAAA,eACA,GAGJL,EAAWM,YAAcX,EAEzB,EAAG,CACC,IACMY,GADAC,EAAYR,EAAWM,aACCC,aAAe,GACvCE,EACFD,IAAcb,EACRY,EAAYG,OAAO,EAAGd,EAAc,GACpCW,EACJI,EACFC,KAAKC,IACDJ,EAAQK,YAAY,KACpBL,EAAQK,YAAYC,EAAAA,qBACpBN,EAAQK,YAAYE,EAAAA,wBACpB,EAIR,GAFAvB,EAAMwB,SAAST,EAAW,GAEtBG,EAAQ,CACRlB,EAAMwB,SAAST,EAAWG,GAC1B,aAECX,EAAWkB,gBAEpBlB,EAAWM,YAAcT,EAEzB,EAAG,CACC,IAAMW,EACAD,GADAC,EAAYR,EAAWM,aACCC,aAAe,GAGvCI,EAAS,EAFTF,EACFD,IAAcX,EAAeU,EAAYG,OAAOZ,EAAY,GAAKS,GAEzDY,QAAQ,KAChBV,EAAQU,QAAQJ,EAAAA,qBAChBN,EAAQU,QAAQH,EAAAA,wBAClBI,QACE,SAACC,EAAQC,GACL,OAAY,IAAZD,IAA2B,IAAVC,EACXV,KAAKC,IAAIQ,EAAQC,GACjBV,KAAKW,IAAIF,EAAQC,MAC1B,GAKL,GAFA7B,EAAM+B,OAAOhB,EAAWD,EAAYkB,SAEpB,IAAZd,EAAe,CACflB,EAAM+B,OAAOhB,EAAWG,EAASJ,EAAYkB,OAAShB,EAAQgB,QAC9D,aAECzB,EAAW0B,YAEpB,OAAOjC,8BC3EqBkC,EAAsBnB,GAClD,IAAMoB,EAAgBpB,EAAUqB,YAAcrB,EAAUsB,WAClDC,EAAeJ,EAAQE,YACvBG,EACFxB,EAAUsB,WACVH,EAAQM,wBAAwBC,KAChC1B,EAAUyB,wBAAwBC,KAChCC,EAAwBH,EAAWD,EAAeH,EAClDQ,EAAuB5B,EAAUsB,WAAaE,EAC9CK,EAAcL,EAAWD,EAAeH,EACxCU,EAAaN,EAAWxB,EAAUsB,WAEpCK,IACA3B,EAAUsB,YAAcO,GAGxBD,IACA5B,EAAUsB,YAAcQ,8BCX5B7C,EACA8C,EACA5B,EACA6B,GAEO,IAAAzC,EAAAwC,EAAAxC,cAEP,GAAKA,EAAL,CAIA,IAAMC,EAAaD,EAAcE,iBAC7BsC,EACApC,WAAWC,UACXC,EAAAA,eACA,GAKJ,IAFAL,EAAWM,YAAciC,EAElBvC,EAAW0B,YACd,GAAI1B,EAAWM,YAAYmC,WAAaC,KAAKC,UAAW,CACpD,IAAMC,EAAS5C,EAAWM,YAAYuC,UAChC7C,EAAWM,YAAYuC,UAAUpB,OACjC,EAEFd,EAASiC,EACTjC,GAAUiC,EAEVnD,EAAM+C,GAAQxC,EAAWM,YAAaK","sourcesContent":["import {CHAR_NO_BREAK_SPACE, CHAR_ZERO_WIDTH_SPACE, svgNodeFilter} from '@taiga-ui/cdk';\n\n/**\n * Creates a cloned range with its boundaries set at word boundaries\n *\n * @param currentRange a range to clone\n * @return modified range\n */\nexport function getWordRange(currentRange: Range): Range {\n    const range = currentRange.cloneRange();\n    const {startContainer, startOffset, endContainer, endOffset} = range;\n    const {ownerDocument} = startContainer;\n\n    if (!ownerDocument) {\n        return range;\n    }\n\n    const treeWalker = ownerDocument.createTreeWalker(\n        ownerDocument.body,\n        NodeFilter.SHOW_TEXT,\n        svgNodeFilter,\n        false,\n    );\n\n    treeWalker.currentNode = startContainer;\n\n    do {\n        const container = treeWalker.currentNode;\n        const textContent = container.textContent || '';\n        const content =\n            container === startContainer\n                ? textContent.substr(0, startOffset + 1)\n                : textContent;\n        const offset =\n            Math.max(\n                content.lastIndexOf(' '),\n                content.lastIndexOf(CHAR_NO_BREAK_SPACE),\n                content.lastIndexOf(CHAR_ZERO_WIDTH_SPACE),\n            ) + 1;\n\n        range.setStart(container, 0);\n\n        if (offset) {\n            range.setStart(container, offset);\n            break;\n        }\n    } while (treeWalker.previousNode());\n\n    treeWalker.currentNode = endContainer;\n\n    do {\n        const container = treeWalker.currentNode;\n        const textContent = container.textContent || '';\n        const content =\n            container === endContainer ? textContent.substr(endOffset + 1) : textContent;\n        const offset = [\n            content.indexOf(' '),\n            content.indexOf(CHAR_NO_BREAK_SPACE),\n            content.indexOf(CHAR_ZERO_WIDTH_SPACE),\n        ].reduce(\n            (result, item) =>\n                result === -1 || item === -1\n                    ? Math.max(result, item)\n                    : Math.min(result, item),\n            -1,\n        );\n\n        range.setEnd(container, textContent.length);\n\n        if (offset !== -1) {\n            range.setEnd(container, offset + textContent.length - content.length);\n            break;\n        }\n    } while (treeWalker.nextNode());\n\n    return range;\n}\n","export function scrollToElement(element: HTMLElement, container: HTMLElement) {\n    const scrolledWidth = container.offsetWidth + container.scrollLeft;\n    const elementWidth = element.offsetWidth;\n    const elementX =\n        container.scrollLeft +\n        element.getBoundingClientRect().left -\n        container.getBoundingClientRect().left;\n    const elementDidNotFitRight = elementX + elementWidth > scrolledWidth;\n    const elementDidNotFitLeft = container.scrollLeft > elementX;\n    const deltaXRight = elementX + elementWidth - scrolledWidth;\n    const deltaXLeft = elementX - container.scrollLeft;\n\n    if (elementDidNotFitRight) {\n        container.scrollLeft += deltaXRight;\n    }\n\n    if (elementDidNotFitLeft) {\n        container.scrollLeft += deltaXLeft;\n    }\n}\n","import {svgNodeFilter} from '@taiga-ui/cdk';\n\n/**\n * Range.setStart/set-end, except it uses offset in characters only\n */\nexport function setRangeOffset(\n    range: Range,\n    node: HTMLElement,\n    offset: number,\n    method: 'setStart' | 'setEnd',\n) {\n    const {ownerDocument} = node;\n\n    if (!ownerDocument) {\n        return;\n    }\n\n    const treeWalker = ownerDocument.createTreeWalker(\n        node,\n        NodeFilter.SHOW_TEXT,\n        svgNodeFilter,\n        false,\n    );\n\n    treeWalker.currentNode = node;\n\n    while (treeWalker.nextNode()) {\n        if (treeWalker.currentNode.nodeType === Node.TEXT_NODE) {\n            const length = treeWalker.currentNode.nodeValue\n                ? treeWalker.currentNode.nodeValue.length\n                : 0;\n\n            if (offset > length) {\n                offset -= length;\n            } else {\n                range[method](treeWalker.currentNode, offset);\n            }\n        }\n    }\n}\n"]}