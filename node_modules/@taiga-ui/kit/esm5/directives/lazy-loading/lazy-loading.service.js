import { __decorate, __extends, __param, __read } from "tslib";
import { ChangeDetectorRef, Inject, Injectable } from '@angular/core';
import { IntersectionObserverService } from '@ng-web-apis/intersection-observer';
import { TuiDestroyService, watch } from '@taiga-ui/cdk';
import { Observable, of, Subject } from 'rxjs';
import { catchError, filter, mapTo, switchMap, take, takeUntil } from 'rxjs/operators';
var TuiLazyLoadingService = /** @class */ (function (_super) {
    __extends(TuiLazyLoadingService, _super);
    function TuiLazyLoadingService(changeDetectorRef, destroy$, intersections$) {
        var _this = _super.call(this, function (subscriber) {
            return _this.src$
                .pipe(switchMap(function (src) {
                return intersections$.pipe(filter(function (_a) {
                    var _b = __read(_a, 1), isIntersecting = _b[0].isIntersecting;
                    return isIntersecting;
                }), mapTo(src), catchError(function () { return of(src); }), watch(changeDetectorRef), take(1));
            }), takeUntil(destroy$))
                .subscribe(subscriber);
        }) || this;
        _this.src$ = new Subject();
        return _this;
    }
    TuiLazyLoadingService.prototype.next = function (src) {
        this.src$.next(src);
    };
    TuiLazyLoadingService.ctorParameters = function () { return [
        { type: ChangeDetectorRef, decorators: [{ type: Inject, args: [ChangeDetectorRef,] }] },
        { type: Observable, decorators: [{ type: Inject, args: [TuiDestroyService,] }] },
        { type: Observable, decorators: [{ type: Inject, args: [IntersectionObserverService,] }] }
    ]; };
    TuiLazyLoadingService = __decorate([
        Injectable(),
        __param(0, Inject(ChangeDetectorRef)),
        __param(1, Inject(TuiDestroyService)),
        __param(2, Inject(IntersectionObserverService))
    ], TuiLazyLoadingService);
    return TuiLazyLoadingService;
}(Observable));
export { TuiLazyLoadingService };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGF6eS1sb2FkaW5nLnNlcnZpY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AdGFpZ2EtdWkva2l0L2RpcmVjdGl2ZXMvbGF6eS1sb2FkaW5nLyIsInNvdXJjZXMiOlsibGF6eS1sb2FkaW5nLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBQyxpQkFBaUIsRUFBRSxNQUFNLEVBQUUsVUFBVSxFQUFDLE1BQU0sZUFBZSxDQUFDO0FBQ3BFLE9BQU8sRUFBQywyQkFBMkIsRUFBQyxNQUFNLG9DQUFvQyxDQUFDO0FBQy9FLE9BQU8sRUFBQyxpQkFBaUIsRUFBRSxLQUFLLEVBQUMsTUFBTSxlQUFlLENBQUM7QUFDdkQsT0FBTyxFQUFDLFVBQVUsRUFBRSxFQUFFLEVBQUUsT0FBTyxFQUFDLE1BQU0sTUFBTSxDQUFDO0FBQzdDLE9BQU8sRUFBQyxVQUFVLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBQyxNQUFNLGdCQUFnQixDQUFDO0FBR3JGO0lBQTJDLHlDQUFrQjtJQUd6RCwrQkFDK0IsaUJBQW9DLEVBQ3BDLFFBQTBCLEVBRXJELGNBQXVEO1FBSjNELFlBTUksa0JBQU0sVUFBQSxVQUFVO1lBQ1osT0FBQSxLQUFJLENBQUMsSUFBSTtpQkFDSixJQUFJLENBQ0QsU0FBUyxDQUFDLFVBQUEsR0FBRztnQkFDVCxPQUFBLGNBQWMsQ0FBQyxJQUFJLENBQ2YsTUFBTSxDQUFDLFVBQUMsRUFBa0I7d0JBQWxCLGtCQUFrQixFQUFoQixxQ0FBYztvQkFBTyxPQUFBLGNBQWM7Z0JBQWQsQ0FBYyxDQUFDLEVBQzlDLEtBQUssQ0FBQyxHQUFHLENBQUMsRUFDVixVQUFVLENBQUMsY0FBTSxPQUFBLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBUCxDQUFPLENBQUMsRUFDekIsS0FBSyxDQUFDLGlCQUFpQixDQUFDLEVBQ3hCLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FDVjtZQU5ELENBTUMsQ0FDSixFQUNELFNBQVMsQ0FBQyxRQUFRLENBQUMsQ0FDdEI7aUJBQ0EsU0FBUyxDQUFDLFVBQVUsQ0FBQztRQWIxQixDQWEwQixDQUM3QixTQUNKO1FBeEJPLFVBQUksR0FBRyxJQUFJLE9BQU8sRUFBVSxDQUFDOztJQXdCckMsQ0FBQztJQUVELG9DQUFJLEdBQUosVUFBSyxHQUFXO1FBQ1osSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDeEIsQ0FBQzs7Z0JBekJpRCxpQkFBaUIsdUJBQTlELE1BQU0sU0FBQyxpQkFBaUI7Z0JBQ1ksVUFBVSx1QkFBOUMsTUFBTSxTQUFDLGlCQUFpQjtnQkFFVCxVQUFVLHVCQUR6QixNQUFNLFNBQUMsMkJBQTJCOztJQU45QixxQkFBcUI7UUFEakMsVUFBVSxFQUFFO1FBS0osV0FBQSxNQUFNLENBQUMsaUJBQWlCLENBQUMsQ0FBQTtRQUN6QixXQUFBLE1BQU0sQ0FBQyxpQkFBaUIsQ0FBQyxDQUFBO1FBQ3pCLFdBQUEsTUFBTSxDQUFDLDJCQUEyQixDQUFDLENBQUE7T0FOL0IscUJBQXFCLENBOEJqQztJQUFELDRCQUFDO0NBQUEsQUE5QkQsQ0FBMkMsVUFBVSxHQThCcEQ7U0E5QlkscUJBQXFCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtDaGFuZ2VEZXRlY3RvclJlZiwgSW5qZWN0LCBJbmplY3RhYmxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7SW50ZXJzZWN0aW9uT2JzZXJ2ZXJTZXJ2aWNlfSBmcm9tICdAbmctd2ViLWFwaXMvaW50ZXJzZWN0aW9uLW9ic2VydmVyJztcbmltcG9ydCB7VHVpRGVzdHJveVNlcnZpY2UsIHdhdGNofSBmcm9tICdAdGFpZ2EtdWkvY2RrJztcbmltcG9ydCB7T2JzZXJ2YWJsZSwgb2YsIFN1YmplY3R9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHtjYXRjaEVycm9yLCBmaWx0ZXIsIG1hcFRvLCBzd2l0Y2hNYXAsIHRha2UsIHRha2VVbnRpbH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgVHVpTGF6eUxvYWRpbmdTZXJ2aWNlIGV4dGVuZHMgT2JzZXJ2YWJsZTxzdHJpbmc+IHtcbiAgICBwcml2YXRlIHNyYyQgPSBuZXcgU3ViamVjdDxzdHJpbmc+KCk7XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgQEluamVjdChDaGFuZ2VEZXRlY3RvclJlZikgY2hhbmdlRGV0ZWN0b3JSZWY6IENoYW5nZURldGVjdG9yUmVmLFxuICAgICAgICBASW5qZWN0KFR1aURlc3Ryb3lTZXJ2aWNlKSBkZXN0cm95JDogT2JzZXJ2YWJsZTx2b2lkPixcbiAgICAgICAgQEluamVjdChJbnRlcnNlY3Rpb25PYnNlcnZlclNlcnZpY2UpXG4gICAgICAgIGludGVyc2VjdGlvbnMkOiBPYnNlcnZhYmxlPEludGVyc2VjdGlvbk9ic2VydmVyRW50cnlbXT4sXG4gICAgKSB7XG4gICAgICAgIHN1cGVyKHN1YnNjcmliZXIgPT5cbiAgICAgICAgICAgIHRoaXMuc3JjJFxuICAgICAgICAgICAgICAgIC5waXBlKFxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2hNYXAoc3JjID0+XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcnNlY3Rpb25zJC5waXBlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlcigoW3tpc0ludGVyc2VjdGluZ31dKSA9PiBpc0ludGVyc2VjdGluZyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwVG8oc3JjKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaEVycm9yKCgpID0+IG9mKHNyYykpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhdGNoKGNoYW5nZURldGVjdG9yUmVmKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWtlKDEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgdGFrZVVudGlsKGRlc3Ryb3kkKSxcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgLnN1YnNjcmliZShzdWJzY3JpYmVyKSxcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBuZXh0KHNyYzogc3RyaW5nKSB7XG4gICAgICAgIHRoaXMuc3JjJC5uZXh0KHNyYyk7XG4gICAgfVxufVxuIl19