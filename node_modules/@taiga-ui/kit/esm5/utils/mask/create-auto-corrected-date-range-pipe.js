import { RANGE_SEPARATOR_CHAR, TuiDay, TuiDayRange } from '@taiga-ui/cdk';
function parseWithLimit(value, config) {
    return TuiDay.normalizeParse(value.slice(0, config.filler.length)).dayLimit(config.min, config.max);
}
function processRawValue(value, config) {
    switch (value.length) {
        case config.filler.length:
            return parseWithLimit(value, config).toString();
        case config.filler.length + RANGE_SEPARATOR_CHAR.length:
            return parseWithLimit(value, config).toString() + RANGE_SEPARATOR_CHAR;
        case config.rangeFiller && config.rangeFiller.length:
            return config.value && config.value.toString() === value
                ? value
                : TuiDayRange.sort(parseWithLimit(value.slice(0, config.filler.length), config), parseWithLimit(value.slice(config.filler.length + RANGE_SEPARATOR_CHAR.length), config)).toString();
        default:
            return value;
    }
}
/**
 * Normalizes date in formatted string
 *
 * Normalizes when:
 *
 * 1. It is a single date
 * 2. It is a single date and a separator
 * 3. It is two dates and a separator between them
 *
 * In **other** cases, the value does not change.
 *
 * @param config with min and max date
 * @return mask pipe handler that handles `min` and `max`
 */
export function tuiCreateAutoCorrectedDateRangePipe(config) {
    return function (value) { return ({ value: processRawValue(value, config) }); };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY3JlYXRlLWF1dG8tY29ycmVjdGVkLWRhdGUtcmFuZ2UtcGlwZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0B0YWlnYS11aS9raXQvdXRpbHMvbWFzay8iLCJzb3VyY2VzIjpbImNyZWF0ZS1hdXRvLWNvcnJlY3RlZC1kYXRlLXJhbmdlLXBpcGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFDLG9CQUFvQixFQUFFLE1BQU0sRUFBRSxXQUFXLEVBQUMsTUFBTSxlQUFlLENBQUM7QUFLeEUsU0FBUyxjQUFjLENBQ25CLEtBQWEsRUFDYixNQUEwRDtJQUUxRCxPQUFPLE1BQU0sQ0FBQyxjQUFjLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FDdkUsTUFBTSxDQUFDLEdBQUcsRUFDVixNQUFNLENBQUMsR0FBRyxDQUNiLENBQUM7QUFDTixDQUFDO0FBRUQsU0FBUyxlQUFlLENBQ3BCLEtBQWEsRUFDYixNQUEwRDtJQUUxRCxRQUFRLEtBQUssQ0FBQyxNQUFNLEVBQUU7UUFDbEIsS0FBSyxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU07WUFDckIsT0FBTyxjQUFjLENBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBQyxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBQ3BELEtBQUssTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEdBQUcsb0JBQW9CLENBQUMsTUFBTTtZQUNuRCxPQUFPLGNBQWMsQ0FBQyxLQUFLLEVBQUUsTUFBTSxDQUFDLENBQUMsUUFBUSxFQUFFLEdBQUcsb0JBQW9CLENBQUM7UUFDM0UsS0FBSyxNQUFNLENBQUMsV0FBVyxJQUFJLE1BQU0sQ0FBQyxXQUFXLENBQUMsTUFBTTtZQUNoRCxPQUFPLE1BQU0sQ0FBQyxLQUFLLElBQUksTUFBTSxDQUFDLEtBQUssQ0FBQyxRQUFRLEVBQUUsS0FBSyxLQUFLO2dCQUNwRCxDQUFDLENBQUMsS0FBSztnQkFDUCxDQUFDLENBQUMsV0FBVyxDQUFDLElBQUksQ0FDWixjQUFjLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRSxNQUFNLENBQUMsRUFDNUQsY0FBYyxDQUNWLEtBQUssQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEdBQUcsb0JBQW9CLENBQUMsTUFBTSxDQUFDLEVBQy9ELE1BQU0sQ0FDVCxDQUNKLENBQUMsUUFBUSxFQUFFLENBQUM7UUFDdkI7WUFDSSxPQUFPLEtBQUssQ0FBQztLQUNwQjtBQUNMLENBQUM7QUFFRDs7Ozs7Ozs7Ozs7OztHQWFHO0FBQ0gsTUFBTSxVQUFVLG1DQUFtQyxDQUMvQyxNQUEwRDtJQUUxRCxPQUFPLFVBQUEsS0FBSyxJQUFJLE9BQUEsQ0FBQyxFQUFDLEtBQUssRUFBRSxlQUFlLENBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBQyxFQUFDLENBQUMsRUFBekMsQ0FBeUMsQ0FBQztBQUM5RCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtSQU5HRV9TRVBBUkFUT1JfQ0hBUiwgVHVpRGF5LCBUdWlEYXlSYW5nZX0gZnJvbSAnQHRhaWdhLXVpL2Nkayc7XG5pbXBvcnQge1R1aVRleHRNYXNrUGlwZUhhbmRsZXJ9IGZyb20gJ0B0YWlnYS11aS9jb3JlJztcblxuaW1wb3J0IHtXaXRoRGF0ZU1hc2tQaXBlQ29uZmlnfSBmcm9tICdAdGFpZ2EtdWkva2l0L2ludGVyZmFjZXMnO1xuXG5mdW5jdGlvbiBwYXJzZVdpdGhMaW1pdChcbiAgICB2YWx1ZTogc3RyaW5nLFxuICAgIGNvbmZpZzogV2l0aERhdGVNYXNrUGlwZUNvbmZpZzxUdWlEYXlSYW5nZSB8IG51bGwsIFR1aURheT4sXG4pOiBUdWlEYXkge1xuICAgIHJldHVybiBUdWlEYXkubm9ybWFsaXplUGFyc2UodmFsdWUuc2xpY2UoMCwgY29uZmlnLmZpbGxlci5sZW5ndGgpKS5kYXlMaW1pdChcbiAgICAgICAgY29uZmlnLm1pbixcbiAgICAgICAgY29uZmlnLm1heCxcbiAgICApO1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzUmF3VmFsdWUoXG4gICAgdmFsdWU6IHN0cmluZyxcbiAgICBjb25maWc6IFdpdGhEYXRlTWFza1BpcGVDb25maWc8VHVpRGF5UmFuZ2UgfCBudWxsLCBUdWlEYXk+LFxuKTogc3RyaW5nIHtcbiAgICBzd2l0Y2ggKHZhbHVlLmxlbmd0aCkge1xuICAgICAgICBjYXNlIGNvbmZpZy5maWxsZXIubGVuZ3RoOlxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlV2l0aExpbWl0KHZhbHVlLCBjb25maWcpLnRvU3RyaW5nKCk7XG4gICAgICAgIGNhc2UgY29uZmlnLmZpbGxlci5sZW5ndGggKyBSQU5HRV9TRVBBUkFUT1JfQ0hBUi5sZW5ndGg6XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VXaXRoTGltaXQodmFsdWUsIGNvbmZpZykudG9TdHJpbmcoKSArIFJBTkdFX1NFUEFSQVRPUl9DSEFSO1xuICAgICAgICBjYXNlIGNvbmZpZy5yYW5nZUZpbGxlciAmJiBjb25maWcucmFuZ2VGaWxsZXIubGVuZ3RoOlxuICAgICAgICAgICAgcmV0dXJuIGNvbmZpZy52YWx1ZSAmJiBjb25maWcudmFsdWUudG9TdHJpbmcoKSA9PT0gdmFsdWVcbiAgICAgICAgICAgICAgICA/IHZhbHVlXG4gICAgICAgICAgICAgICAgOiBUdWlEYXlSYW5nZS5zb3J0KFxuICAgICAgICAgICAgICAgICAgICAgIHBhcnNlV2l0aExpbWl0KHZhbHVlLnNsaWNlKDAsIGNvbmZpZy5maWxsZXIubGVuZ3RoKSwgY29uZmlnKSxcbiAgICAgICAgICAgICAgICAgICAgICBwYXJzZVdpdGhMaW1pdChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUuc2xpY2UoY29uZmlnLmZpbGxlci5sZW5ndGggKyBSQU5HRV9TRVBBUkFUT1JfQ0hBUi5sZW5ndGgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICkudG9TdHJpbmcoKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG59XG5cbi8qKlxuICogTm9ybWFsaXplcyBkYXRlIGluIGZvcm1hdHRlZCBzdHJpbmdcbiAqXG4gKiBOb3JtYWxpemVzIHdoZW46XG4gKlxuICogMS4gSXQgaXMgYSBzaW5nbGUgZGF0ZVxuICogMi4gSXQgaXMgYSBzaW5nbGUgZGF0ZSBhbmQgYSBzZXBhcmF0b3JcbiAqIDMuIEl0IGlzIHR3byBkYXRlcyBhbmQgYSBzZXBhcmF0b3IgYmV0d2VlbiB0aGVtXG4gKlxuICogSW4gKipvdGhlcioqIGNhc2VzLCB0aGUgdmFsdWUgZG9lcyBub3QgY2hhbmdlLlxuICpcbiAqIEBwYXJhbSBjb25maWcgd2l0aCBtaW4gYW5kIG1heCBkYXRlXG4gKiBAcmV0dXJuIG1hc2sgcGlwZSBoYW5kbGVyIHRoYXQgaGFuZGxlcyBgbWluYCBhbmQgYG1heGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHR1aUNyZWF0ZUF1dG9Db3JyZWN0ZWREYXRlUmFuZ2VQaXBlKFxuICAgIGNvbmZpZzogV2l0aERhdGVNYXNrUGlwZUNvbmZpZzxUdWlEYXlSYW5nZSB8IG51bGwsIFR1aURheT4sXG4pOiBUdWlUZXh0TWFza1BpcGVIYW5kbGVyIHtcbiAgICByZXR1cm4gdmFsdWUgPT4gKHt2YWx1ZTogcHJvY2Vzc1Jhd1ZhbHVlKHZhbHVlLCBjb25maWcpfSk7XG59XG4iXX0=