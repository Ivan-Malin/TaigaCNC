import { __decorate, __param } from 'tslib';
import { Optional, Self, Inject, ChangeDetectorRef, Input, Component, NgModule } from '@angular/core';
import { NgControl, FormArrayName, FormGroupName, FormGroupDirective, ReactiveFormsModule } from '@angular/forms';
import { tuiAssert, TuiValidationError, tuiRequiredSetter } from '@taiga-ui/cdk';
import { tuiHeightCollapse, tuiFadeIn, TuiErrorModule } from '@taiga-ui/core';
import { TUI_VALIDATION_ERRORS } from '@taiga-ui/kit/tokens';
import { Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import { CommonModule } from '@angular/common';

// TODO: Refactor
// @dynamic
let TuiFieldErrorComponent = class TuiFieldErrorComponent {
    constructor(ngControl, formArrayName, formGroupName, formGroup, changeDetectorRef, validationErrors) {
        this.ngControl = ngControl;
        this.formArrayName = formArrayName;
        this.formGroupName = formGroupName;
        this.formGroup = formGroup;
        this.changeDetectorRef = changeDetectorRef;
        this.validationErrors = validationErrors;
        this.firstError = null;
        this.errorsOrder = [];
        this.destroy$ = new Subject();
        tuiAssert.assert(!!this.ngControl, `NgControl not injected in ${this.constructor.name}!` +
            ' Use [(ngModel)] or [formControl] or formControlName for correct work.');
        if (this.ngControl) {
            this.ngControl.valueAccessor = this;
        }
    }
    set order(value) {
        this.errorsOrder = value;
        this.updateErrorText();
    }
    ngOnInit() {
        const control = this.control;
        if (!control) {
            return;
        }
        // Temporary workaround until issue with async validators will be resolved.
        // https://github.com/angular/angular/issues/13200
        if (control.asyncValidator) {
            control.updateValueAndValidity();
        }
        this.updateErrorText();
        control.statusChanges.pipe(takeUntil(this.destroy$)).subscribe(() => {
            this.updateErrorText();
        });
    }
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
    }
    get computedError() {
        return this.invalid && this.touched && this.firstError ? this.firstError : null;
    }
    get invalid() {
        const control = this.control;
        return control && control.invalid !== null ? control.invalid : false;
    }
    get touched() {
        const control = this.control;
        return control && control.touched !== null ? control.touched : false;
    }
    get control() {
        if (this.ngControl) {
            return this.ngControl.control;
        }
        if (this.formArrayName) {
            return this.formArrayName.control;
        }
        if (this.formGroupName) {
            return this.formGroupName.control;
        }
        if (this.formGroup) {
            return this.formGroup.control;
        }
        return null;
    }
    registerOnChange() {
        this.markForCheck();
    }
    registerOnTouched() {
        this.markForCheck();
    }
    setDisabledState() {
        this.markForCheck();
    }
    writeValue() {
        this.markForCheck();
    }
    get firstErrorIdByOrder() {
        const firstErrorId = this.errorsOrder &&
            this.errorsOrder.find(errorId => !!this.controlErrors[errorId]);
        return firstErrorId || null;
    }
    get firstErrorId() {
        const errorIds = Object.keys(this.controlErrors);
        return errorIds[0];
    }
    get controlErrors() {
        const control = this.control;
        return (control && control.errors) || {};
    }
    updateErrorText() {
        this.firstError = this.getErrorText();
    }
    getErrorText() {
        const firstErrorId = this.firstErrorIdByOrder || this.firstErrorId;
        const firstError = firstErrorId && this.controlErrors[firstErrorId];
        // @bad TODO: Remove firstError.message check after everybody migrates to TuiValidationError
        if (firstError &&
            (firstError instanceof TuiValidationError ||
                typeof firstError.message === 'string')) {
            return firstError;
        }
        return firstErrorId
            ? new TuiValidationError(this.validationErrors[firstErrorId], firstError)
            : null;
    }
    markForCheck() {
        this.changeDetectorRef.markForCheck();
    }
};
TuiFieldErrorComponent.ctorParameters = () => [
    { type: NgControl, decorators: [{ type: Optional }, { type: Self }, { type: Inject, args: [NgControl,] }] },
    { type: FormArrayName, decorators: [{ type: Optional }, { type: Self }, { type: Inject, args: [FormArrayName,] }] },
    { type: FormGroupName, decorators: [{ type: Optional }, { type: Self }, { type: Inject, args: [FormGroupName,] }] },
    { type: FormGroupDirective, decorators: [{ type: Optional }, { type: Self }, { type: Inject, args: [FormGroupDirective,] }] },
    { type: ChangeDetectorRef, decorators: [{ type: Inject, args: [ChangeDetectorRef,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [TUI_VALIDATION_ERRORS,] }] }
];
__decorate([
    Input(),
    tuiRequiredSetter()
], TuiFieldErrorComponent.prototype, "order", null);
TuiFieldErrorComponent = __decorate([
    Component({
        selector: 'tui-field-error',
        // @bad TODO: find a way to get 'touched' state change
        // https://github.com/angular/angular/issues/10887
        // changeDetection: ChangeDetectionStrategy.OnPush,
        template: "<tui-error [error]=\"computedError\"></tui-error>\n",
        animations: [tuiHeightCollapse, tuiFadeIn],
        styles: [":host{display:block}"]
    }),
    __param(0, Optional()),
    __param(0, Self()),
    __param(0, Inject(NgControl)),
    __param(1, Optional()),
    __param(1, Self()),
    __param(1, Inject(FormArrayName)),
    __param(2, Optional()),
    __param(2, Self()),
    __param(2, Inject(FormGroupName)),
    __param(3, Optional()),
    __param(3, Self()),
    __param(3, Inject(FormGroupDirective)),
    __param(4, Inject(ChangeDetectorRef)),
    __param(5, Inject(TUI_VALIDATION_ERRORS))
], TuiFieldErrorComponent);

let TuiFieldErrorModule = class TuiFieldErrorModule {
};
TuiFieldErrorModule = __decorate([
    NgModule({
        imports: [CommonModule, ReactiveFormsModule, TuiErrorModule],
        declarations: [TuiFieldErrorComponent],
        exports: [TuiFieldErrorComponent],
    })
], TuiFieldErrorModule);

/**
 * Generated bundle index. Do not edit.
 */

export { TuiFieldErrorComponent, TuiFieldErrorModule };
//# sourceMappingURL=taiga-ui-kit-components-field-error.js.map
