import { svgNodeFilter, CHAR_NO_BREAK_SPACE, CHAR_ZERO_WIDTH_SPACE } from '@taiga-ui/cdk';

/**
 * Creates a cloned range with its boundaries set at word boundaries
 *
 * @param currentRange a range to clone
 * @return modified range
 */
function getWordRange(currentRange) {
    const range = currentRange.cloneRange();
    const { startContainer, startOffset, endContainer, endOffset } = range;
    const { ownerDocument } = startContainer;
    if (!ownerDocument) {
        return range;
    }
    const treeWalker = ownerDocument.createTreeWalker(ownerDocument.body, NodeFilter.SHOW_TEXT, svgNodeFilter, false);
    treeWalker.currentNode = startContainer;
    do {
        const container = treeWalker.currentNode;
        const textContent = container.textContent || '';
        const content = container === startContainer
            ? textContent.substr(0, startOffset + 1)
            : textContent;
        const offset = Math.max(content.lastIndexOf(' '), content.lastIndexOf(CHAR_NO_BREAK_SPACE), content.lastIndexOf(CHAR_ZERO_WIDTH_SPACE)) + 1;
        range.setStart(container, 0);
        if (offset) {
            range.setStart(container, offset);
            break;
        }
    } while (treeWalker.previousNode());
    treeWalker.currentNode = endContainer;
    do {
        const container = treeWalker.currentNode;
        const textContent = container.textContent || '';
        const content = container === endContainer ? textContent.substr(endOffset + 1) : textContent;
        const offset = [
            content.indexOf(' '),
            content.indexOf(CHAR_NO_BREAK_SPACE),
            content.indexOf(CHAR_ZERO_WIDTH_SPACE),
        ].reduce((result, item) => result === -1 || item === -1
            ? Math.max(result, item)
            : Math.min(result, item), -1);
        range.setEnd(container, textContent.length);
        if (offset !== -1) {
            range.setEnd(container, offset + textContent.length - content.length);
            break;
        }
    } while (treeWalker.nextNode());
    return range;
}

function scrollToElement(element, container) {
    const scrolledWidth = container.offsetWidth + container.scrollLeft;
    const elementWidth = element.offsetWidth;
    const elementX = container.scrollLeft +
        element.getBoundingClientRect().left -
        container.getBoundingClientRect().left;
    const elementDidNotFitRight = elementX + elementWidth > scrolledWidth;
    const elementDidNotFitLeft = container.scrollLeft > elementX;
    const deltaXRight = elementX + elementWidth - scrolledWidth;
    const deltaXLeft = elementX - container.scrollLeft;
    if (elementDidNotFitRight) {
        container.scrollLeft += deltaXRight;
    }
    if (elementDidNotFitLeft) {
        container.scrollLeft += deltaXLeft;
    }
}

/**
 * Range.setStart/set-end, except it uses offset in characters only
 */
function setRangeOffset(range, node, offset, method) {
    const { ownerDocument } = node;
    if (!ownerDocument) {
        return;
    }
    const treeWalker = ownerDocument.createTreeWalker(node, NodeFilter.SHOW_TEXT, svgNodeFilter, false);
    treeWalker.currentNode = node;
    while (treeWalker.nextNode()) {
        if (treeWalker.currentNode.nodeType === Node.TEXT_NODE) {
            const length = treeWalker.currentNode.nodeValue
                ? treeWalker.currentNode.nodeValue.length
                : 0;
            if (offset > length) {
                offset -= length;
            }
            else {
                range[method](treeWalker.currentNode, offset);
            }
        }
    }
}

/**
 * Generated bundle index. Do not edit.
 */

export { getWordRange, scrollToElement, setRangeOffset };
//# sourceMappingURL=taiga-ui-kit-utils-dom.js.map
