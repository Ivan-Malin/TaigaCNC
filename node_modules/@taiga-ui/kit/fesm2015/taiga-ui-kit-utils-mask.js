import { TuiDay, TuiDayRange, RANGE_SEPARATOR_CHAR } from '@taiga-ui/cdk';
import { DATE_TIME_SEPARATOR, TUI_TIME_MASK } from '@taiga-ui/kit/constants';
import { TUI_DIGIT_REGEXP } from '@taiga-ui/core';

function normalizeDateValue(dateValue, { value, min, max }) {
    return value && value.toString() === dateValue
        ? dateValue
        : TuiDay.normalizeParse(dateValue).dayLimit(min, max).toString();
}
function tuiCreateAutoCorrectedDatePipe(config) {
    return value => {
        if (value.length !== config.filler.length) {
            return { value };
        }
        return {
            value: normalizeDateValue(value, config),
        };
    };
}

function parseWithLimit(value, config) {
    return TuiDay.normalizeParse(value.slice(0, config.filler.length)).dayLimit(config.min, config.max);
}
function processRawValue(value, config) {
    switch (value.length) {
        case config.filler.length:
            return parseWithLimit(value, config).toString();
        case config.filler.length + RANGE_SEPARATOR_CHAR.length:
            return parseWithLimit(value, config).toString() + RANGE_SEPARATOR_CHAR;
        case config.rangeFiller && config.rangeFiller.length:
            return config.value && config.value.toString() === value
                ? value
                : TuiDayRange.sort(parseWithLimit(value.slice(0, config.filler.length), config), parseWithLimit(value.slice(config.filler.length + RANGE_SEPARATOR_CHAR.length), config)).toString();
        default:
            return value;
    }
}
/**
 * Normalizes date in formatted string
 *
 * Normalizes when:
 *
 * 1. It is a single date
 * 2. It is a single date and a separator
 * 3. It is two dates and a separator between them
 *
 * In **other** cases, the value does not change.
 *
 * @param config with min and max date
 * @return mask pipe handler that handles `min` and `max`
 */
function tuiCreateAutoCorrectedDateRangePipe(config) {
    return value => ({ value: processRawValue(value, config) });
}

/**
 * Adjusts the entered time by omitting only suitable values ​​for hours and minutes
 * @returns time as a string
 */
function tuiCreateAutoCorrectedTimePipe(timeMode = 'HH:MM') {
    const timeFormatArray = ['HH', 'MM', 'SS', 'MS'];
    const maxValue = { HH: 23, MM: 59, SS: 59, MS: 999 };
    return (conformedValue) => {
        const indexesOfPipedChars = [];
        const conformedValueArr = conformedValue.split('');
        timeFormatArray.forEach(format => {
            const position = timeMode.indexOf(format);
            const maxFirstDigit = parseInt(maxValue[format].toString().substr(0, 1), 10);
            if (parseInt(conformedValueArr[position], 10) > maxFirstDigit) {
                conformedValueArr[position + 1] = conformedValueArr[position];
                conformedValueArr[position] = '0';
                indexesOfPipedChars.push(position);
            }
        });
        const isInvalid = timeFormatArray.some(format => parseInt(conformedValue.substr(timeMode.indexOf(format), 2), 10) >
            maxValue[format]);
        return isInvalid
            ? false
            : {
                value: conformedValueArr.join(''),
                indexesOfPipedChars,
            };
    };
}

function tuiCreateAutoCorrectedDateTimePipe(config, timeMode) {
    const timePipe = tuiCreateAutoCorrectedTimePipe(timeMode);
    return value => {
        if (value.length < config.filler.length) {
            return { value };
        }
        const [date, time] = value.split(DATE_TIME_SEPARATOR);
        const formattedDate = normalizeDateValue(date, config);
        if (!time) {
            return { value: formattedDate };
        }
        const pipedTime = timePipe(time, {});
        if (!pipedTime || typeof pipedTime === 'string') {
            return false;
        }
        return {
            value: `${formattedDate}${DATE_TIME_SEPARATOR}${pipedTime.value}`,
            indexesOfPipedChars: !!pipedTime.indexesOfPipedChars
                ? pipedTime.indexesOfPipedChars.map(i => i + date.length + 2)
                : undefined,
        };
    };
}

function tuiCreateTimeMask(mode) {
    return [
        ...TUI_TIME_MASK,
        ...(mode.includes('HH:MM:SS') ? [':', TUI_DIGIT_REGEXP, TUI_DIGIT_REGEXP] : []),
        ...(mode === 'HH:MM:SS.MSS'
            ? ['.', TUI_DIGIT_REGEXP, TUI_DIGIT_REGEXP, TUI_DIGIT_REGEXP]
            : []),
    ];
}

/**
 * Generated bundle index. Do not edit.
 */

export { normalizeDateValue, tuiCreateAutoCorrectedDatePipe, tuiCreateAutoCorrectedDateRangePipe, tuiCreateAutoCorrectedDateTimePipe, tuiCreateAutoCorrectedTimePipe, tuiCreateTimeMask };
//# sourceMappingURL=taiga-ui-kit-utils-mask.js.map
