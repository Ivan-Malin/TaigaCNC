import { TuiDay, TuiDayRange, RANGE_SEPARATOR_CHAR } from '@taiga-ui/cdk';
import { __read, __spread } from 'tslib';
import { DATE_TIME_SEPARATOR, TUI_TIME_MASK } from '@taiga-ui/kit/constants';
import { TUI_DIGIT_REGEXP } from '@taiga-ui/core';

function normalizeDateValue(dateValue, _a) {
    var value = _a.value, min = _a.min, max = _a.max;
    return value && value.toString() === dateValue
        ? dateValue
        : TuiDay.normalizeParse(dateValue).dayLimit(min, max).toString();
}
function tuiCreateAutoCorrectedDatePipe(config) {
    return function (value) {
        if (value.length !== config.filler.length) {
            return { value: value };
        }
        return {
            value: normalizeDateValue(value, config),
        };
    };
}

function parseWithLimit(value, config) {
    return TuiDay.normalizeParse(value.slice(0, config.filler.length)).dayLimit(config.min, config.max);
}
function processRawValue(value, config) {
    switch (value.length) {
        case config.filler.length:
            return parseWithLimit(value, config).toString();
        case config.filler.length + RANGE_SEPARATOR_CHAR.length:
            return parseWithLimit(value, config).toString() + RANGE_SEPARATOR_CHAR;
        case config.rangeFiller && config.rangeFiller.length:
            return config.value && config.value.toString() === value
                ? value
                : TuiDayRange.sort(parseWithLimit(value.slice(0, config.filler.length), config), parseWithLimit(value.slice(config.filler.length + RANGE_SEPARATOR_CHAR.length), config)).toString();
        default:
            return value;
    }
}
/**
 * Normalizes date in formatted string
 *
 * Normalizes when:
 *
 * 1. It is a single date
 * 2. It is a single date and a separator
 * 3. It is two dates and a separator between them
 *
 * In **other** cases, the value does not change.
 *
 * @param config with min and max date
 * @return mask pipe handler that handles `min` and `max`
 */
function tuiCreateAutoCorrectedDateRangePipe(config) {
    return function (value) { return ({ value: processRawValue(value, config) }); };
}

/**
 * Adjusts the entered time by omitting only suitable values ​​for hours and minutes
 * @returns time as a string
 */
function tuiCreateAutoCorrectedTimePipe(timeMode) {
    if (timeMode === void 0) { timeMode = 'HH:MM'; }
    var timeFormatArray = ['HH', 'MM', 'SS', 'MS'];
    var maxValue = { HH: 23, MM: 59, SS: 59, MS: 999 };
    return function (conformedValue) {
        var indexesOfPipedChars = [];
        var conformedValueArr = conformedValue.split('');
        timeFormatArray.forEach(function (format) {
            var position = timeMode.indexOf(format);
            var maxFirstDigit = parseInt(maxValue[format].toString().substr(0, 1), 10);
            if (parseInt(conformedValueArr[position], 10) > maxFirstDigit) {
                conformedValueArr[position + 1] = conformedValueArr[position];
                conformedValueArr[position] = '0';
                indexesOfPipedChars.push(position);
            }
        });
        var isInvalid = timeFormatArray.some(function (format) {
            return parseInt(conformedValue.substr(timeMode.indexOf(format), 2), 10) >
                maxValue[format];
        });
        return isInvalid
            ? false
            : {
                value: conformedValueArr.join(''),
                indexesOfPipedChars: indexesOfPipedChars,
            };
    };
}

function tuiCreateAutoCorrectedDateTimePipe(config, timeMode) {
    var timePipe = tuiCreateAutoCorrectedTimePipe(timeMode);
    return function (value) {
        if (value.length < config.filler.length) {
            return { value: value };
        }
        var _a = __read(value.split(DATE_TIME_SEPARATOR), 2), date = _a[0], time = _a[1];
        var formattedDate = normalizeDateValue(date, config);
        if (!time) {
            return { value: formattedDate };
        }
        var pipedTime = timePipe(time, {});
        if (!pipedTime || typeof pipedTime === 'string') {
            return false;
        }
        return {
            value: "" + formattedDate + DATE_TIME_SEPARATOR + pipedTime.value,
            indexesOfPipedChars: !!pipedTime.indexesOfPipedChars
                ? pipedTime.indexesOfPipedChars.map(function (i) { return i + date.length + 2; })
                : undefined,
        };
    };
}

function tuiCreateTimeMask(mode) {
    return __spread(TUI_TIME_MASK, (mode.includes('HH:MM:SS') ? [':', TUI_DIGIT_REGEXP, TUI_DIGIT_REGEXP] : []), (mode === 'HH:MM:SS.MSS'
        ? ['.', TUI_DIGIT_REGEXP, TUI_DIGIT_REGEXP, TUI_DIGIT_REGEXP]
        : []));
}

/**
 * Generated bundle index. Do not edit.
 */

export { normalizeDateValue, tuiCreateAutoCorrectedDatePipe, tuiCreateAutoCorrectedDateRangePipe, tuiCreateAutoCorrectedDateTimePipe, tuiCreateAutoCorrectedTimePipe, tuiCreateTimeMask };
//# sourceMappingURL=taiga-ui-kit-utils-mask.js.map
