import { EVENT_MANAGER_PLUGINS } from '@angular/platform-browser';
import { Injectable } from '@angular/core';
import { EMPTY, concat, defer } from 'rxjs';
import { takeWhile } from 'rxjs/operators';

/**
 * @fileoverview added by tsickle
 * Generated from: utils/dasharize.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} camel
 * @return {?}
 */
function dasharize(camel) {
    return camel.replace(/[a-z][A-Z]/g, (/**
     * @param {?} letterLetter
     * @return {?}
     */
    (letterLetter) => {
        return `${letterLetter[0]}-${letterLetter[1].toLowerCase()}`;
    }));
}

/**
 * @fileoverview added by tsickle
 * Generated from: plugins/abstract.plugin.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
class AbstractEventPlugin {
    /**
     * @param {?} event
     * @return {?}
     */
    supports(event) {
        return event.split('.').indexOf(this.modifier) !== -1;
    }
    /**
     * @param {?} _element
     * @param {?} _event
     * @param {?} _handler
     * @return {?}
     */
    addGlobalEventListener(_element, _event, _handler) {
        throw new Error(`Global event targets are not supported by ${this.modifier} plugin`);
    }
    /**
     * @protected
     * @param {?} event
     * @return {?}
     */
    unwrap(event) {
        return event
            .split('.')
            .filter((/**
         * @param {?} v
         * @return {?}
         */
        v => v !== this.modifier))
            .join('.');
    }
}
if (false) {
    /**
     * @type {?}
     * @protected
     */
    AbstractEventPlugin.prototype.modifier;
    /** @type {?} */
    AbstractEventPlugin.prototype.manager;
    /**
     * @abstract
     * @param {?} element
     * @param {?} event
     * @param {?} handler
     * @return {?}
     */
    AbstractEventPlugin.prototype.addEventListener = function (element, event, handler) { };
}

/**
 * @fileoverview added by tsickle
 * Generated from: plugins/bind.plugin.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class BindEventPlugin extends AbstractEventPlugin {
    constructor() {
        super(...arguments);
        this.modifier = '$';
    }
    /**
     * @param {?} element
     * @param {?} event
     * @return {?}
     */
    addEventListener(element, event) {
        var _a;
        element[event] = (_a = element[event]) !== null && _a !== void 0 ? _a : EMPTY;
        /** @type {?} */
        const method = this.getMethod(element, event);
        /** @type {?} */
        const zone$ = this.manager.getZone().onStable;
        /** @type {?} */
        const sub = concat(zone$.pipe(takeWhile((/**
         * @return {?}
         */
        () => element[event] === EMPTY))), defer((/**
         * @return {?}
         */
        () => element[event]))).subscribe(method);
        return (/**
         * @return {?}
         */
        () => sub.unsubscribe());
    }
    /**
     * @private
     * @param {?} element
     * @param {?} event
     * @return {?}
     */
    getMethod(element, event) {
        const [, key, value, unit = ''] = event.split('.');
        if (event.endsWith('.attr')) {
            return (/**
             * @param {?} v
             * @return {?}
             */
            v => v === null
                ? element.removeAttribute(key)
                : element.setAttribute(key, String(v)));
        }
        if (key === 'class') {
            return (/**
             * @param {?} v
             * @return {?}
             */
            v => element.classList.toggle(value, !!v));
        }
        if (key === 'style') {
            return (/**
             * @param {?} v
             * @return {?}
             */
            v => element.style.setProperty(dasharize(value), `${v}${unit}`));
        }
        return (/**
         * @param {?} v
         * @return {?}
         */
        v => (element[key] = v));
    }
}
BindEventPlugin.decorators = [
    { type: Injectable }
];
if (false) {
    /**
     * @type {?}
     * @protected
     */
    BindEventPlugin.prototype.modifier;
}

/**
 * @fileoverview added by tsickle
 * Generated from: plugins/capture.plugin.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CaptureEventPlugin extends AbstractEventPlugin {
    constructor() {
        super(...arguments);
        this.modifier = 'capture';
    }
    /**
     * @param {?} event
     * @return {?}
     */
    supports(event) {
        /** @type {?} */
        const split = event.split('.');
        return split.length === 2 && split.indexOf(this.modifier) !== -1;
    }
    /**
     * @param {?} element
     * @param {?} event
     * @param {?} handler
     * @return {?}
     */
    addEventListener(element, event, handler) {
        element.addEventListener(this.unwrap(event), handler, true);
        return (/**
         * @return {?}
         */
        () => element.removeEventListener(this.unwrap(event), handler));
    }
}
CaptureEventPlugin.decorators = [
    { type: Injectable }
];
if (false) {
    /**
     * @type {?}
     * @protected
     */
    CaptureEventPlugin.prototype.modifier;
}

/**
 * @fileoverview added by tsickle
 * Generated from: plugins/prevent.plugin.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PreventEventPlugin extends AbstractEventPlugin {
    constructor() {
        super(...arguments);
        this.modifier = 'prevent';
    }
    /**
     * @param {?} element
     * @param {?} event
     * @param {?} handler
     * @return {?}
     */
    addEventListener(element, event, handler) {
        /** @type {?} */
        const wrapped = (/**
         * @param {?} event
         * @return {?}
         */
        (event) => {
            event.preventDefault();
            handler(event);
        });
        return this.manager.addEventListener(element, this.unwrap(event), wrapped);
    }
    /**
     * @param {?} element
     * @param {?} event
     * @param {?} handler
     * @return {?}
     */
    addGlobalEventListener(element, event, handler) {
        /** @type {?} */
        const wrapped = (/**
         * @param {?} event
         * @return {?}
         */
        (event) => {
            event.preventDefault();
            handler(event);
        });
        return this.manager.addGlobalEventListener(element, this.unwrap(event), wrapped);
    }
}
PreventEventPlugin.decorators = [
    { type: Injectable }
];
if (false) {
    /**
     * @type {?}
     * @protected
     */
    PreventEventPlugin.prototype.modifier;
}

/**
 * @fileoverview added by tsickle
 * Generated from: plugins/silent.plugin.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SilentEventPlugin extends AbstractEventPlugin {
    constructor() {
        super(...arguments);
        this.modifier = 'silent';
    }
    /**
     * @param {?} element
     * @param {?} event
     * @param {?} handler
     * @return {?}
     */
    addEventListener(element, event, handler) {
        return this.manager
            .getZone()
            .runOutsideAngular((/**
         * @return {?}
         */
        () => this.manager.addEventListener(element, this.unwrap(event), handler)));
    }
    /**
     * @param {?} element
     * @param {?} event
     * @param {?} handler
     * @return {?}
     */
    addGlobalEventListener(element, event, handler) {
        return this.manager
            .getZone()
            .runOutsideAngular((/**
         * @return {?}
         */
        () => this.manager.addGlobalEventListener(element, this.unwrap(event), handler)));
    }
}
SilentEventPlugin.decorators = [
    { type: Injectable }
];
if (false) {
    /**
     * @type {?}
     * @protected
     */
    SilentEventPlugin.prototype.modifier;
}

/**
 * @fileoverview added by tsickle
 * Generated from: plugins/stop.plugin.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class StopEventPlugin extends AbstractEventPlugin {
    constructor() {
        super(...arguments);
        this.modifier = 'stop';
    }
    /**
     * @param {?} element
     * @param {?} event
     * @param {?} handler
     * @return {?}
     */
    addEventListener(element, event, handler) {
        /** @type {?} */
        const wrapped = (/**
         * @param {?} event
         * @return {?}
         */
        (event) => {
            event.stopPropagation();
            handler(event);
        });
        return this.manager.addEventListener(element, this.unwrap(event), wrapped);
    }
    /**
     * @param {?} element
     * @param {?} event
     * @param {?} handler
     * @return {?}
     */
    addGlobalEventListener(element, event, handler) {
        /** @type {?} */
        const wrapped = (/**
         * @param {?} event
         * @return {?}
         */
        (event) => {
            event.stopPropagation();
            handler(event);
        });
        return this.manager.addGlobalEventListener(element, this.unwrap(event), wrapped);
    }
}
StopEventPlugin.decorators = [
    { type: Injectable }
];
if (false) {
    /**
     * @type {?}
     * @protected
     */
    StopEventPlugin.prototype.modifier;
}

/**
 * @fileoverview added by tsickle
 * Generated from: plugins/zone.plugin.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * TODO: This will not be needed in Angular 10
 * when libraries are allowed to use Ivy renderer and markDirty becomes stable API
 */
class ZoneEventPlugin extends AbstractEventPlugin {
    constructor() {
        super(...arguments);
        this.modifier = 'init';
    }
    /**
     * @param {?} _element
     * @param {?} _event
     * @param {?} handler
     * @return {?}
     */
    addEventListener(_element, _event, handler) {
        return this.handle(handler);
    }
    /**
     * @param {?} _element
     * @param {?} _event
     * @param {?} handler
     * @return {?}
     */
    addGlobalEventListener(_element, _event, handler) {
        return this.handle(handler);
    }
    /**
     * @private
     * @param {?} handler
     * @return {?}
     */
    handle(handler) {
        /** @type {?} */
        const zone = this.manager.getZone();
        /** @type {?} */
        const subscription = zone.onStable.subscribe((/**
         * @return {?}
         */
        () => {
            subscription.unsubscribe();
            handler(zone);
        }));
        return (/**
         * @return {?}
         */
        () => { });
    }
}
ZoneEventPlugin.decorators = [
    { type: Injectable }
];
if (false) {
    /**
     * @type {?}
     * @protected
     */
    ZoneEventPlugin.prototype.modifier;
}

/**
 * @fileoverview added by tsickle
 * Generated from: constants/plugins.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const NG_EVENT_PLUGINS = [
    {
        provide: EVENT_MANAGER_PLUGINS,
        useClass: SilentEventPlugin,
        multi: true,
    },
    {
        provide: EVENT_MANAGER_PLUGINS,
        useClass: PreventEventPlugin,
        multi: true,
    },
    {
        provide: EVENT_MANAGER_PLUGINS,
        useClass: StopEventPlugin,
        multi: true,
    },
    {
        provide: EVENT_MANAGER_PLUGINS,
        useClass: ZoneEventPlugin,
        multi: true,
    },
    {
        provide: EVENT_MANAGER_PLUGINS,
        useClass: CaptureEventPlugin,
        multi: true,
    },
    {
        provide: EVENT_MANAGER_PLUGINS,
        useClass: BindEventPlugin,
        multi: true,
    },
];

/**
 * @fileoverview added by tsickle
 * Generated from: decorators/should-call.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * TODO: This will not be needed in Angular 10
 * when libraries are allowed to use Ivy renderer and markDirty becomes stable API
 * @template T
 * @param {?} predicate
 * @return {?}
 */
function shouldCall(predicate) {
    return (/**
     * @param {?} _
     * @param {?} key
     * @param {?} desc
     * @return {?}
     */
    (_, key, desc) => {
        const { value } = desc;
        desc.value = (/**
         * @return {?}
         */
        function () {
            /** @type {?} */
            const zone = (/** @type {?} */ (arguments[0]));
            Object.defineProperty(this, key, {
                /**
                 * @this {?}
                 * @param {...?} args
                 * @return {?}
                 */
                value(...args) {
                    if (predicate.apply(this, args)) {
                        zone.run((/**
                         * @return {?}
                         */
                        () => {
                            value.apply(this, args);
                        }));
                    }
                },
            });
        });
    });
}

/**
 * @fileoverview added by tsickle
 * Generated from: types/predicate.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: utils/as-callable.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 * @param {?} a
 * @return {?}
 */
function asCallable(a) {
    return (/** @type {?} */ (a));
}

/**
 * @fileoverview added by tsickle
 * Generated from: public-api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: tinkoff-ng-event-plugins.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { BindEventPlugin, CaptureEventPlugin, NG_EVENT_PLUGINS, PreventEventPlugin, SilentEventPlugin, StopEventPlugin, ZoneEventPlugin, asCallable, shouldCall, AbstractEventPlugin as ɵa };
//# sourceMappingURL=tinkoff-ng-event-plugins.js.map
